"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunk_N_E"] = self["webpackChunk_N_E"] || []).push([["_app-pages-browser_node_modules_locomotive-scroll_dist_locomotive-scroll_esm_js"],{

/***/ "(app-pages-browser)/./node_modules/locomotive-scroll/dist/locomotive-scroll.esm.js":
/*!**********************************************************************!*\
  !*** ./node_modules/locomotive-scroll/dist/locomotive-scroll.esm.js ***!
  \**********************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Native: function() { return /* binding */ Native; },\n/* harmony export */   Smooth: function() { return /* binding */ Smooth; }\n/* harmony export */ });\n/* locomotive-scroll v4.1.3 | MIT License | https://github.com/locomotivemtl/locomotive-scroll */ function _classCallCheck(instance, Constructor) {\n    if (!(instance instanceof Constructor)) {\n        throw new TypeError(\"Cannot call a class as a function\");\n    }\n}\nfunction _defineProperties(target, props) {\n    for(var i = 0; i < props.length; i++){\n        var descriptor = props[i];\n        descriptor.enumerable = descriptor.enumerable || false;\n        descriptor.configurable = true;\n        if (\"value\" in descriptor) descriptor.writable = true;\n        Object.defineProperty(target, descriptor.key, descriptor);\n    }\n}\nfunction _createClass(Constructor, protoProps, staticProps) {\n    if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) _defineProperties(Constructor, staticProps);\n    return Constructor;\n}\nfunction _defineProperty(obj, key, value) {\n    if (key in obj) {\n        Object.defineProperty(obj, key, {\n            value: value,\n            enumerable: true,\n            configurable: true,\n            writable: true\n        });\n    } else {\n        obj[key] = value;\n    }\n    return obj;\n}\nfunction ownKeys(object, enumerableOnly) {\n    var keys = Object.keys(object);\n    if (Object.getOwnPropertySymbols) {\n        var symbols = Object.getOwnPropertySymbols(object);\n        if (enumerableOnly) symbols = symbols.filter(function(sym) {\n            return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n        });\n        keys.push.apply(keys, symbols);\n    }\n    return keys;\n}\nfunction _objectSpread2(target) {\n    for(var i = 1; i < arguments.length; i++){\n        var source = arguments[i] != null ? arguments[i] : {};\n        if (i % 2) {\n            ownKeys(Object(source), true).forEach(function(key) {\n                _defineProperty(target, key, source[key]);\n            });\n        } else if (Object.getOwnPropertyDescriptors) {\n            Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n        } else {\n            ownKeys(Object(source)).forEach(function(key) {\n                Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n            });\n        }\n    }\n    return target;\n}\nfunction _inherits(subClass, superClass) {\n    if (typeof superClass !== \"function\" && superClass !== null) {\n        throw new TypeError(\"Super expression must either be null or a function\");\n    }\n    subClass.prototype = Object.create(superClass && superClass.prototype, {\n        constructor: {\n            value: subClass,\n            writable: true,\n            configurable: true\n        }\n    });\n    if (superClass) _setPrototypeOf(subClass, superClass);\n}\nfunction _getPrototypeOf(o) {\n    _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {\n        return o.__proto__ || Object.getPrototypeOf(o);\n    };\n    return _getPrototypeOf(o);\n}\nfunction _setPrototypeOf(o, p) {\n    _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {\n        o.__proto__ = p;\n        return o;\n    };\n    return _setPrototypeOf(o, p);\n}\nfunction _isNativeReflectConstruct() {\n    if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n    if (Reflect.construct.sham) return false;\n    if (typeof Proxy === \"function\") return true;\n    try {\n        Date.prototype.toString.call(Reflect.construct(Date, [], function() {}));\n        return true;\n    } catch (e) {\n        return false;\n    }\n}\nfunction _assertThisInitialized(self1) {\n    if (self1 === void 0) {\n        throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n    }\n    return self1;\n}\nfunction _possibleConstructorReturn(self1, call) {\n    if (call && (typeof call === \"object\" || typeof call === \"function\")) {\n        return call;\n    }\n    return _assertThisInitialized(self1);\n}\nfunction _createSuper(Derived) {\n    var hasNativeReflectConstruct = _isNativeReflectConstruct();\n    return function _createSuperInternal() {\n        var Super = _getPrototypeOf(Derived), result;\n        if (hasNativeReflectConstruct) {\n            var NewTarget = _getPrototypeOf(this).constructor;\n            result = Reflect.construct(Super, arguments, NewTarget);\n        } else {\n            result = Super.apply(this, arguments);\n        }\n        return _possibleConstructorReturn(this, result);\n    };\n}\nfunction _superPropBase(object, property) {\n    while(!Object.prototype.hasOwnProperty.call(object, property)){\n        object = _getPrototypeOf(object);\n        if (object === null) break;\n    }\n    return object;\n}\nfunction _get(target, property, receiver) {\n    if (typeof Reflect !== \"undefined\" && Reflect.get) {\n        _get = Reflect.get;\n    } else {\n        _get = function _get(target, property, receiver) {\n            var base = _superPropBase(target, property);\n            if (!base) return;\n            var desc = Object.getOwnPropertyDescriptor(base, property);\n            if (desc.get) {\n                return desc.get.call(receiver);\n            }\n            return desc.value;\n        };\n    }\n    return _get(target, property, receiver || target);\n}\nfunction _slicedToArray(arr, i) {\n    return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();\n}\nfunction _toConsumableArray(arr) {\n    return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();\n}\nfunction _arrayWithoutHoles(arr) {\n    if (Array.isArray(arr)) return _arrayLikeToArray(arr);\n}\nfunction _arrayWithHoles(arr) {\n    if (Array.isArray(arr)) return arr;\n}\nfunction _iterableToArray(iter) {\n    if (typeof Symbol !== \"undefined\" && Symbol.iterator in Object(iter)) return Array.from(iter);\n}\nfunction _iterableToArrayLimit(arr, i) {\n    if (typeof Symbol === \"undefined\" || !(Symbol.iterator in Object(arr))) return;\n    var _arr = [];\n    var _n = true;\n    var _d = false;\n    var _e = undefined;\n    try {\n        for(var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true){\n            _arr.push(_s.value);\n            if (i && _arr.length === i) break;\n        }\n    } catch (err) {\n        _d = true;\n        _e = err;\n    } finally{\n        try {\n            if (!_n && _i[\"return\"] != null) _i[\"return\"]();\n        } finally{\n            if (_d) throw _e;\n        }\n    }\n    return _arr;\n}\nfunction _unsupportedIterableToArray(o, minLen) {\n    if (!o) return;\n    if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n    var n = Object.prototype.toString.call(o).slice(8, -1);\n    if (n === \"Object\" && o.constructor) n = o.constructor.name;\n    if (n === \"Map\" || n === \"Set\") return Array.from(o);\n    if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\nfunction _arrayLikeToArray(arr, len) {\n    if (len == null || len > arr.length) len = arr.length;\n    for(var i = 0, arr2 = new Array(len); i < len; i++)arr2[i] = arr[i];\n    return arr2;\n}\nfunction _nonIterableSpread() {\n    throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\nfunction _nonIterableRest() {\n    throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\nvar defaults = {\n    el: document,\n    name: \"scroll\",\n    offset: [\n        0,\n        0\n    ],\n    repeat: false,\n    smooth: false,\n    initPosition: {\n        x: 0,\n        y: 0\n    },\n    direction: \"vertical\",\n    gestureDirection: \"vertical\",\n    reloadOnContextChange: false,\n    lerp: 0.1,\n    \"class\": \"is-inview\",\n    scrollbarContainer: false,\n    scrollbarClass: \"c-scrollbar\",\n    scrollingClass: \"has-scroll-scrolling\",\n    draggingClass: \"has-scroll-dragging\",\n    smoothClass: \"has-scroll-smooth\",\n    initClass: \"has-scroll-init\",\n    getSpeed: false,\n    getDirection: false,\n    scrollFromAnywhere: false,\n    multiplier: 1,\n    firefoxMultiplier: 50,\n    touchMultiplier: 2,\n    resetNativeScroll: true,\n    tablet: {\n        smooth: false,\n        direction: \"vertical\",\n        gestureDirection: \"vertical\",\n        breakpoint: 1024\n    },\n    smartphone: {\n        smooth: false,\n        direction: \"vertical\",\n        gestureDirection: \"vertical\"\n    }\n};\nvar _default = /*#__PURE__*/ function() {\n    function _default() {\n        var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n        _classCallCheck(this, _default);\n        Object.assign(this, defaults, options);\n        this.smartphone = defaults.smartphone;\n        if (options.smartphone) Object.assign(this.smartphone, options.smartphone);\n        this.tablet = defaults.tablet;\n        if (options.tablet) Object.assign(this.tablet, options.tablet);\n        this.namespace = \"locomotive\";\n        this.html = document.documentElement;\n        this.windowHeight = window.innerHeight;\n        this.windowWidth = window.innerWidth;\n        this.windowMiddle = {\n            x: this.windowWidth / 2,\n            y: this.windowHeight / 2\n        };\n        this.els = {};\n        this.currentElements = {};\n        this.listeners = {};\n        this.hasScrollTicking = false;\n        this.hasCallEventSet = false;\n        this.checkScroll = this.checkScroll.bind(this);\n        this.checkResize = this.checkResize.bind(this);\n        this.checkEvent = this.checkEvent.bind(this);\n        this.instance = {\n            scroll: {\n                x: 0,\n                y: 0\n            },\n            limit: {\n                x: this.html.offsetWidth,\n                y: this.html.offsetHeight\n            },\n            currentElements: this.currentElements\n        };\n        if (this.isMobile) {\n            if (this.isTablet) {\n                this.context = \"tablet\";\n            } else {\n                this.context = \"smartphone\";\n            }\n        } else {\n            this.context = \"desktop\";\n        }\n        if (this.isMobile) this.direction = this[this.context].direction;\n        if (this.direction === \"horizontal\") {\n            this.directionAxis = \"x\";\n        } else {\n            this.directionAxis = \"y\";\n        }\n        if (this.getDirection) {\n            this.instance.direction = null;\n        }\n        if (this.getDirection) {\n            this.instance.speed = 0;\n        }\n        this.html.classList.add(this.initClass);\n        window.addEventListener(\"resize\", this.checkResize, false);\n    }\n    _createClass(_default, [\n        {\n            key: \"init\",\n            value: function init() {\n                this.initEvents();\n            }\n        },\n        {\n            key: \"checkScroll\",\n            value: function checkScroll() {\n                this.dispatchScroll();\n            }\n        },\n        {\n            key: \"checkResize\",\n            value: function checkResize() {\n                var _this = this;\n                if (!this.resizeTick) {\n                    this.resizeTick = true;\n                    requestAnimationFrame(function() {\n                        _this.resize();\n                        _this.resizeTick = false;\n                    });\n                }\n            }\n        },\n        {\n            key: \"resize\",\n            value: function resize() {}\n        },\n        {\n            key: \"checkContext\",\n            value: function checkContext() {\n                if (!this.reloadOnContextChange) return;\n                this.isMobile = /Android|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) || navigator.platform === \"MacIntel\" && navigator.maxTouchPoints > 1 || this.windowWidth < this.tablet.breakpoint;\n                this.isTablet = this.isMobile && this.windowWidth >= this.tablet.breakpoint;\n                var oldContext = this.context;\n                if (this.isMobile) {\n                    if (this.isTablet) {\n                        this.context = \"tablet\";\n                    } else {\n                        this.context = \"smartphone\";\n                    }\n                } else {\n                    this.context = \"desktop\";\n                }\n                if (oldContext != this.context) {\n                    var oldSmooth = oldContext == \"desktop\" ? this.smooth : this[oldContext].smooth;\n                    var newSmooth = this.context == \"desktop\" ? this.smooth : this[this.context].smooth;\n                    if (oldSmooth != newSmooth) window.location.reload();\n                }\n            }\n        },\n        {\n            key: \"initEvents\",\n            value: function initEvents() {\n                var _this2 = this;\n                this.scrollToEls = this.el.querySelectorAll(\"[data-\".concat(this.name, \"-to]\"));\n                this.setScrollTo = this.setScrollTo.bind(this);\n                this.scrollToEls.forEach(function(el) {\n                    el.addEventListener(\"click\", _this2.setScrollTo, false);\n                });\n            }\n        },\n        {\n            key: \"setScrollTo\",\n            value: function setScrollTo(event) {\n                event.preventDefault();\n                this.scrollTo(event.currentTarget.getAttribute(\"data-\".concat(this.name, \"-href\")) || event.currentTarget.getAttribute(\"href\"), {\n                    offset: event.currentTarget.getAttribute(\"data-\".concat(this.name, \"-offset\"))\n                });\n            }\n        },\n        {\n            key: \"addElements\",\n            value: function addElements() {}\n        },\n        {\n            key: \"detectElements\",\n            value: function detectElements(hasCallEventSet) {\n                var _this3 = this;\n                var scrollTop = this.instance.scroll.y;\n                var scrollBottom = scrollTop + this.windowHeight;\n                var scrollLeft = this.instance.scroll.x;\n                var scrollRight = scrollLeft + this.windowWidth;\n                Object.entries(this.els).forEach(function(_ref) {\n                    var _ref2 = _slicedToArray(_ref, 2), i = _ref2[0], el = _ref2[1];\n                    if (el && (!el.inView || hasCallEventSet)) {\n                        if (_this3.direction === \"horizontal\") {\n                            if (scrollRight >= el.left && scrollLeft < el.right) {\n                                _this3.setInView(el, i);\n                            }\n                        } else {\n                            if (scrollBottom >= el.top && scrollTop < el.bottom) {\n                                _this3.setInView(el, i);\n                            }\n                        }\n                    }\n                    if (el && el.inView) {\n                        if (_this3.direction === \"horizontal\") {\n                            var width = el.right - el.left;\n                            el.progress = (_this3.instance.scroll.x - (el.left - _this3.windowWidth)) / (width + _this3.windowWidth);\n                            if (scrollRight < el.left || scrollLeft > el.right) {\n                                _this3.setOutOfView(el, i);\n                            }\n                        } else {\n                            var height = el.bottom - el.top;\n                            el.progress = (_this3.instance.scroll.y - (el.top - _this3.windowHeight)) / (height + _this3.windowHeight);\n                            if (scrollBottom < el.top || scrollTop > el.bottom) {\n                                _this3.setOutOfView(el, i);\n                            }\n                        }\n                    }\n                }); // this.els = this.els.filter((current, i) => {\n                //     return current !== null;\n                // });\n                this.hasScrollTicking = false;\n            }\n        },\n        {\n            key: \"setInView\",\n            value: function setInView(current, i) {\n                this.els[i].inView = true;\n                current.el.classList.add(current[\"class\"]);\n                this.currentElements[i] = current;\n                if (current.call && this.hasCallEventSet) {\n                    this.dispatchCall(current, \"enter\");\n                    if (!current.repeat) {\n                        this.els[i].call = false;\n                    }\n                } // if (!current.repeat && !current.speed && !current.sticky) {\n            //     if (!current.call || current.call && this.hasCallEventSet) {\n            //        this.els[i] = null\n            //     }\n            // }\n            }\n        },\n        {\n            key: \"setOutOfView\",\n            value: function setOutOfView(current, i) {\n                var _this4 = this;\n                // if (current.repeat || current.speed !== undefined) {\n                this.els[i].inView = false; // }\n                Object.keys(this.currentElements).forEach(function(el) {\n                    el === i && delete _this4.currentElements[el];\n                });\n                if (current.call && this.hasCallEventSet) {\n                    this.dispatchCall(current, \"exit\");\n                }\n                if (current.repeat) {\n                    current.el.classList.remove(current[\"class\"]);\n                }\n            }\n        },\n        {\n            key: \"dispatchCall\",\n            value: function dispatchCall(current, way) {\n                this.callWay = way;\n                this.callValue = current.call.split(\",\").map(function(item) {\n                    return item.trim();\n                });\n                this.callObj = current;\n                if (this.callValue.length == 1) this.callValue = this.callValue[0];\n                var callEvent = new Event(this.namespace + \"call\");\n                this.el.dispatchEvent(callEvent);\n            }\n        },\n        {\n            key: \"dispatchScroll\",\n            value: function dispatchScroll() {\n                var scrollEvent = new Event(this.namespace + \"scroll\");\n                this.el.dispatchEvent(scrollEvent);\n            }\n        },\n        {\n            key: \"setEvents\",\n            value: function setEvents(event, func) {\n                if (!this.listeners[event]) {\n                    this.listeners[event] = [];\n                }\n                var list = this.listeners[event];\n                list.push(func);\n                if (list.length === 1) {\n                    this.el.addEventListener(this.namespace + event, this.checkEvent, false);\n                }\n                if (event === \"call\") {\n                    this.hasCallEventSet = true;\n                    this.detectElements(true);\n                }\n            }\n        },\n        {\n            key: \"unsetEvents\",\n            value: function unsetEvents(event, func) {\n                if (!this.listeners[event]) return;\n                var list = this.listeners[event];\n                var index = list.indexOf(func);\n                if (index < 0) return;\n                list.splice(index, 1);\n                if (list.index === 0) {\n                    this.el.removeEventListener(this.namespace + event, this.checkEvent, false);\n                }\n            }\n        },\n        {\n            key: \"checkEvent\",\n            value: function checkEvent(event) {\n                var _this5 = this;\n                var name = event.type.replace(this.namespace, \"\");\n                var list = this.listeners[name];\n                if (!list || list.length === 0) return;\n                list.forEach(function(func) {\n                    switch(name){\n                        case \"scroll\":\n                            return func(_this5.instance);\n                        case \"call\":\n                            return func(_this5.callValue, _this5.callWay, _this5.callObj);\n                        default:\n                            return func();\n                    }\n                });\n            }\n        },\n        {\n            key: \"startScroll\",\n            value: function startScroll() {}\n        },\n        {\n            key: \"stopScroll\",\n            value: function stopScroll() {}\n        },\n        {\n            key: \"setScroll\",\n            value: function setScroll(x, y) {\n                this.instance.scroll = {\n                    x: 0,\n                    y: 0\n                };\n            }\n        },\n        {\n            key: \"destroy\",\n            value: function destroy() {\n                var _this6 = this;\n                window.removeEventListener(\"resize\", this.checkResize, false);\n                Object.keys(this.listeners).forEach(function(event) {\n                    _this6.el.removeEventListener(_this6.namespace + event, _this6.checkEvent, false);\n                });\n                this.listeners = {};\n                this.scrollToEls.forEach(function(el) {\n                    el.removeEventListener(\"click\", _this6.setScrollTo, false);\n                });\n                this.html.classList.remove(this.initClass);\n            }\n        }\n    ]);\n    return _default;\n}();\nvar commonjsGlobal = typeof globalThis !== \"undefined\" ? globalThis :  true ? window : 0;\nfunction createCommonjsModule(fn, module) {\n    return module = {\n        exports: {}\n    }, fn(module, module.exports), module.exports;\n}\nvar smoothscroll = createCommonjsModule(function(module, exports) {\n    /* smoothscroll v0.4.4 - 2019 - Dustan Kasten, Jeremias Menichelli - MIT License */ (function() {\n        // polyfill\n        function polyfill() {\n            // aliases\n            var w = window;\n            var d = document;\n            // return if scroll behavior is supported and polyfill is not forced\n            if (\"scrollBehavior\" in d.documentElement.style && w.__forceSmoothScrollPolyfill__ !== true) {\n                return;\n            }\n            // globals\n            var Element = w.HTMLElement || w.Element;\n            var SCROLL_TIME = 468;\n            // object gathering original scroll methods\n            var original = {\n                scroll: w.scroll || w.scrollTo,\n                scrollBy: w.scrollBy,\n                elementScroll: Element.prototype.scroll || scrollElement,\n                scrollIntoView: Element.prototype.scrollIntoView\n            };\n            // define timing method\n            var now = w.performance && w.performance.now ? w.performance.now.bind(w.performance) : Date.now;\n            /**\n     * indicates if a the current browser is made by Microsoft\n     * @method isMicrosoftBrowser\n     * @param {String} userAgent\n     * @returns {Boolean}\n     */ function isMicrosoftBrowser(userAgent) {\n                var userAgentPatterns = [\n                    \"MSIE \",\n                    \"Trident/\",\n                    \"Edge/\"\n                ];\n                return new RegExp(userAgentPatterns.join(\"|\")).test(userAgent);\n            }\n            /*\n     * IE has rounding bug rounding down clientHeight and clientWidth and\n     * rounding up scrollHeight and scrollWidth causing false positives\n     * on hasScrollableSpace\n     */ var ROUNDING_TOLERANCE = isMicrosoftBrowser(w.navigator.userAgent) ? 1 : 0;\n            /**\n     * changes scroll position inside an element\n     * @method scrollElement\n     * @param {Number} x\n     * @param {Number} y\n     * @returns {undefined}\n     */ function scrollElement(x, y) {\n                this.scrollLeft = x;\n                this.scrollTop = y;\n            }\n            /**\n     * returns result of applying ease math function to a number\n     * @method ease\n     * @param {Number} k\n     * @returns {Number}\n     */ function ease(k) {\n                return 0.5 * (1 - Math.cos(Math.PI * k));\n            }\n            /**\n     * indicates if a smooth behavior should be applied\n     * @method shouldBailOut\n     * @param {Number|Object} firstArg\n     * @returns {Boolean}\n     */ function shouldBailOut(firstArg) {\n                if (firstArg === null || typeof firstArg !== \"object\" || firstArg.behavior === undefined || firstArg.behavior === \"auto\" || firstArg.behavior === \"instant\") {\n                    // first argument is not an object/null\n                    // or behavior is auto, instant or undefined\n                    return true;\n                }\n                if (typeof firstArg === \"object\" && firstArg.behavior === \"smooth\") {\n                    // first argument is an object and behavior is smooth\n                    return false;\n                }\n                // throw error when behavior is not supported\n                throw new TypeError(\"behavior member of ScrollOptions \" + firstArg.behavior + \" is not a valid value for enumeration ScrollBehavior.\");\n            }\n            /**\n     * indicates if an element has scrollable space in the provided axis\n     * @method hasScrollableSpace\n     * @param {Node} el\n     * @param {String} axis\n     * @returns {Boolean}\n     */ function hasScrollableSpace(el, axis) {\n                if (axis === \"Y\") {\n                    return el.clientHeight + ROUNDING_TOLERANCE < el.scrollHeight;\n                }\n                if (axis === \"X\") {\n                    return el.clientWidth + ROUNDING_TOLERANCE < el.scrollWidth;\n                }\n            }\n            /**\n     * indicates if an element has a scrollable overflow property in the axis\n     * @method canOverflow\n     * @param {Node} el\n     * @param {String} axis\n     * @returns {Boolean}\n     */ function canOverflow(el, axis) {\n                var overflowValue = w.getComputedStyle(el, null)[\"overflow\" + axis];\n                return overflowValue === \"auto\" || overflowValue === \"scroll\";\n            }\n            /**\n     * indicates if an element can be scrolled in either axis\n     * @method isScrollable\n     * @param {Node} el\n     * @param {String} axis\n     * @returns {Boolean}\n     */ function isScrollable(el) {\n                var isScrollableY = hasScrollableSpace(el, \"Y\") && canOverflow(el, \"Y\");\n                var isScrollableX = hasScrollableSpace(el, \"X\") && canOverflow(el, \"X\");\n                return isScrollableY || isScrollableX;\n            }\n            /**\n     * finds scrollable parent of an element\n     * @method findScrollableParent\n     * @param {Node} el\n     * @returns {Node} el\n     */ function findScrollableParent(el) {\n                while(el !== d.body && isScrollable(el) === false){\n                    el = el.parentNode || el.host;\n                }\n                return el;\n            }\n            /**\n     * self invoked function that, given a context, steps through scrolling\n     * @method step\n     * @param {Object} context\n     * @returns {undefined}\n     */ function step(context) {\n                var time = now();\n                var value;\n                var currentX;\n                var currentY;\n                var elapsed = (time - context.startTime) / SCROLL_TIME;\n                // avoid elapsed times higher than one\n                elapsed = elapsed > 1 ? 1 : elapsed;\n                // apply easing to elapsed time\n                value = ease(elapsed);\n                currentX = context.startX + (context.x - context.startX) * value;\n                currentY = context.startY + (context.y - context.startY) * value;\n                context.method.call(context.scrollable, currentX, currentY);\n                // scroll more if we have not reached our destination\n                if (currentX !== context.x || currentY !== context.y) {\n                    w.requestAnimationFrame(step.bind(w, context));\n                }\n            }\n            /**\n     * scrolls window or element with a smooth behavior\n     * @method smoothScroll\n     * @param {Object|Node} el\n     * @param {Number} x\n     * @param {Number} y\n     * @returns {undefined}\n     */ function smoothScroll(el, x, y) {\n                var scrollable;\n                var startX;\n                var startY;\n                var method;\n                var startTime = now();\n                // define scroll context\n                if (el === d.body) {\n                    scrollable = w;\n                    startX = w.scrollX || w.pageXOffset;\n                    startY = w.scrollY || w.pageYOffset;\n                    method = original.scroll;\n                } else {\n                    scrollable = el;\n                    startX = el.scrollLeft;\n                    startY = el.scrollTop;\n                    method = scrollElement;\n                }\n                // scroll looping over a frame\n                step({\n                    scrollable: scrollable,\n                    method: method,\n                    startTime: startTime,\n                    startX: startX,\n                    startY: startY,\n                    x: x,\n                    y: y\n                });\n            }\n            // ORIGINAL METHODS OVERRIDES\n            // w.scroll and w.scrollTo\n            w.scroll = w.scrollTo = function() {\n                // avoid action when no arguments are passed\n                if (arguments[0] === undefined) {\n                    return;\n                }\n                // avoid smooth behavior if not required\n                if (shouldBailOut(arguments[0]) === true) {\n                    original.scroll.call(w, arguments[0].left !== undefined ? arguments[0].left : typeof arguments[0] !== \"object\" ? arguments[0] : w.scrollX || w.pageXOffset, // use top prop, second argument if present or fallback to scrollY\n                    arguments[0].top !== undefined ? arguments[0].top : arguments[1] !== undefined ? arguments[1] : w.scrollY || w.pageYOffset);\n                    return;\n                }\n                // LET THE SMOOTHNESS BEGIN!\n                smoothScroll.call(w, d.body, arguments[0].left !== undefined ? ~~arguments[0].left : w.scrollX || w.pageXOffset, arguments[0].top !== undefined ? ~~arguments[0].top : w.scrollY || w.pageYOffset);\n            };\n            // w.scrollBy\n            w.scrollBy = function() {\n                // avoid action when no arguments are passed\n                if (arguments[0] === undefined) {\n                    return;\n                }\n                // avoid smooth behavior if not required\n                if (shouldBailOut(arguments[0])) {\n                    original.scrollBy.call(w, arguments[0].left !== undefined ? arguments[0].left : typeof arguments[0] !== \"object\" ? arguments[0] : 0, arguments[0].top !== undefined ? arguments[0].top : arguments[1] !== undefined ? arguments[1] : 0);\n                    return;\n                }\n                // LET THE SMOOTHNESS BEGIN!\n                smoothScroll.call(w, d.body, ~~arguments[0].left + (w.scrollX || w.pageXOffset), ~~arguments[0].top + (w.scrollY || w.pageYOffset));\n            };\n            // Element.prototype.scroll and Element.prototype.scrollTo\n            Element.prototype.scroll = Element.prototype.scrollTo = function() {\n                // avoid action when no arguments are passed\n                if (arguments[0] === undefined) {\n                    return;\n                }\n                // avoid smooth behavior if not required\n                if (shouldBailOut(arguments[0]) === true) {\n                    // if one number is passed, throw error to match Firefox implementation\n                    if (typeof arguments[0] === \"number\" && arguments[1] === undefined) {\n                        throw new SyntaxError(\"Value could not be converted\");\n                    }\n                    original.elementScroll.call(this, // use left prop, first number argument or fallback to scrollLeft\n                    arguments[0].left !== undefined ? ~~arguments[0].left : typeof arguments[0] !== \"object\" ? ~~arguments[0] : this.scrollLeft, // use top prop, second argument or fallback to scrollTop\n                    arguments[0].top !== undefined ? ~~arguments[0].top : arguments[1] !== undefined ? ~~arguments[1] : this.scrollTop);\n                    return;\n                }\n                var left = arguments[0].left;\n                var top = arguments[0].top;\n                // LET THE SMOOTHNESS BEGIN!\n                smoothScroll.call(this, this, typeof left === \"undefined\" ? this.scrollLeft : ~~left, typeof top === \"undefined\" ? this.scrollTop : ~~top);\n            };\n            // Element.prototype.scrollBy\n            Element.prototype.scrollBy = function() {\n                // avoid action when no arguments are passed\n                if (arguments[0] === undefined) {\n                    return;\n                }\n                // avoid smooth behavior if not required\n                if (shouldBailOut(arguments[0]) === true) {\n                    original.elementScroll.call(this, arguments[0].left !== undefined ? ~~arguments[0].left + this.scrollLeft : ~~arguments[0] + this.scrollLeft, arguments[0].top !== undefined ? ~~arguments[0].top + this.scrollTop : ~~arguments[1] + this.scrollTop);\n                    return;\n                }\n                this.scroll({\n                    left: ~~arguments[0].left + this.scrollLeft,\n                    top: ~~arguments[0].top + this.scrollTop,\n                    behavior: arguments[0].behavior\n                });\n            };\n            // Element.prototype.scrollIntoView\n            Element.prototype.scrollIntoView = function() {\n                // avoid smooth behavior if not required\n                if (shouldBailOut(arguments[0]) === true) {\n                    original.scrollIntoView.call(this, arguments[0] === undefined ? true : arguments[0]);\n                    return;\n                }\n                // LET THE SMOOTHNESS BEGIN!\n                var scrollableParent = findScrollableParent(this);\n                var parentRects = scrollableParent.getBoundingClientRect();\n                var clientRects = this.getBoundingClientRect();\n                if (scrollableParent !== d.body) {\n                    // reveal element inside parent\n                    smoothScroll.call(this, scrollableParent, scrollableParent.scrollLeft + clientRects.left - parentRects.left, scrollableParent.scrollTop + clientRects.top - parentRects.top);\n                    // reveal parent in viewport unless is fixed\n                    if (w.getComputedStyle(scrollableParent).position !== \"fixed\") {\n                        w.scrollBy({\n                            left: parentRects.left,\n                            top: parentRects.top,\n                            behavior: \"smooth\"\n                        });\n                    }\n                } else {\n                    // reveal element in viewport\n                    w.scrollBy({\n                        left: clientRects.left,\n                        top: clientRects.top,\n                        behavior: \"smooth\"\n                    });\n                }\n            };\n        }\n        {\n            // commonjs\n            module.exports = {\n                polyfill: polyfill\n            };\n        }\n    })();\n});\nvar smoothscroll_1 = smoothscroll.polyfill;\nvar _default$1 = /*#__PURE__*/ function(_Core) {\n    _inherits(_default, _Core);\n    var _super = _createSuper(_default);\n    function _default() {\n        var _this;\n        var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n        _classCallCheck(this, _default);\n        _this = _super.call(this, options);\n        if (_this.resetNativeScroll) {\n            if (history.scrollRestoration) {\n                history.scrollRestoration = \"manual\";\n            }\n            window.scrollTo(0, 0);\n        }\n        window.addEventListener(\"scroll\", _this.checkScroll, false);\n        if (window.smoothscrollPolyfill === undefined) {\n            window.smoothscrollPolyfill = smoothscroll;\n            window.smoothscrollPolyfill.polyfill();\n        }\n        return _this;\n    }\n    _createClass(_default, [\n        {\n            key: \"init\",\n            value: function init() {\n                this.instance.scroll.y = window.pageYOffset;\n                this.addElements();\n                this.detectElements();\n                _get(_getPrototypeOf(_default.prototype), \"init\", this).call(this);\n            }\n        },\n        {\n            key: \"checkScroll\",\n            value: function checkScroll() {\n                var _this2 = this;\n                _get(_getPrototypeOf(_default.prototype), \"checkScroll\", this).call(this);\n                if (this.getDirection) {\n                    this.addDirection();\n                }\n                if (this.getSpeed) {\n                    this.addSpeed();\n                    this.speedTs = Date.now();\n                }\n                this.instance.scroll.y = window.pageYOffset;\n                if (Object.entries(this.els).length) {\n                    if (!this.hasScrollTicking) {\n                        requestAnimationFrame(function() {\n                            _this2.detectElements();\n                        });\n                        this.hasScrollTicking = true;\n                    }\n                }\n            }\n        },\n        {\n            key: \"addDirection\",\n            value: function addDirection() {\n                if (window.pageYOffset > this.instance.scroll.y) {\n                    if (this.instance.direction !== \"down\") {\n                        this.instance.direction = \"down\";\n                    }\n                } else if (window.pageYOffset < this.instance.scroll.y) {\n                    if (this.instance.direction !== \"up\") {\n                        this.instance.direction = \"up\";\n                    }\n                }\n            }\n        },\n        {\n            key: \"addSpeed\",\n            value: function addSpeed() {\n                if (window.pageYOffset != this.instance.scroll.y) {\n                    this.instance.speed = (window.pageYOffset - this.instance.scroll.y) / Math.max(1, Date.now() - this.speedTs);\n                } else {\n                    this.instance.speed = 0;\n                }\n            }\n        },\n        {\n            key: \"resize\",\n            value: function resize() {\n                if (Object.entries(this.els).length) {\n                    this.windowHeight = window.innerHeight;\n                    this.updateElements();\n                }\n            }\n        },\n        {\n            key: \"addElements\",\n            value: function addElements() {\n                var _this3 = this;\n                this.els = {};\n                var els = this.el.querySelectorAll(\"[data-\" + this.name + \"]\");\n                els.forEach(function(el, index) {\n                    var BCR = el.getBoundingClientRect();\n                    var cl = el.dataset[_this3.name + \"Class\"] || _this3[\"class\"];\n                    var id = typeof el.dataset[_this3.name + \"Id\"] === \"string\" ? el.dataset[_this3.name + \"Id\"] : index;\n                    var top;\n                    var left;\n                    var offset = typeof el.dataset[_this3.name + \"Offset\"] === \"string\" ? el.dataset[_this3.name + \"Offset\"].split(\",\") : _this3.offset;\n                    var repeat = el.dataset[_this3.name + \"Repeat\"];\n                    var call = el.dataset[_this3.name + \"Call\"];\n                    var target = el.dataset[_this3.name + \"Target\"];\n                    var targetEl;\n                    if (target !== undefined) {\n                        targetEl = document.querySelector(\"\".concat(target));\n                    } else {\n                        targetEl = el;\n                    }\n                    var targetElBCR = targetEl.getBoundingClientRect();\n                    top = targetElBCR.top + _this3.instance.scroll.y;\n                    left = targetElBCR.left + _this3.instance.scroll.x;\n                    var bottom = top + targetEl.offsetHeight;\n                    var right = left + targetEl.offsetWidth;\n                    if (repeat == \"false\") {\n                        repeat = false;\n                    } else if (repeat != undefined) {\n                        repeat = true;\n                    } else {\n                        repeat = _this3.repeat;\n                    }\n                    var relativeOffset = _this3.getRelativeOffset(offset);\n                    top = top + relativeOffset[0];\n                    bottom = bottom - relativeOffset[1];\n                    var mappedEl = {\n                        el: el,\n                        targetEl: targetEl,\n                        id: id,\n                        \"class\": cl,\n                        top: top,\n                        bottom: bottom,\n                        left: left,\n                        right: right,\n                        offset: offset,\n                        progress: 0,\n                        repeat: repeat,\n                        inView: false,\n                        call: call\n                    };\n                    _this3.els[id] = mappedEl;\n                    if (el.classList.contains(cl)) {\n                        _this3.setInView(_this3.els[id], id);\n                    }\n                });\n            }\n        },\n        {\n            key: \"updateElements\",\n            value: function updateElements() {\n                var _this4 = this;\n                Object.entries(this.els).forEach(function(_ref) {\n                    var _ref2 = _slicedToArray(_ref, 2), i = _ref2[0], el = _ref2[1];\n                    var top = el.targetEl.getBoundingClientRect().top + _this4.instance.scroll.y;\n                    var bottom = top + el.targetEl.offsetHeight;\n                    var relativeOffset = _this4.getRelativeOffset(el.offset);\n                    _this4.els[i].top = top + relativeOffset[0];\n                    _this4.els[i].bottom = bottom - relativeOffset[1];\n                });\n                this.hasScrollTicking = false;\n            }\n        },\n        {\n            key: \"getRelativeOffset\",\n            value: function getRelativeOffset(offset) {\n                var relativeOffset = [\n                    0,\n                    0\n                ];\n                if (offset) {\n                    for(var i = 0; i < offset.length; i++){\n                        if (typeof offset[i] == \"string\") {\n                            if (offset[i].includes(\"%\")) {\n                                relativeOffset[i] = parseInt(offset[i].replace(\"%\", \"\") * this.windowHeight / 100);\n                            } else {\n                                relativeOffset[i] = parseInt(offset[i]);\n                            }\n                        } else {\n                            relativeOffset[i] = offset[i];\n                        }\n                    }\n                }\n                return relativeOffset;\n            }\n        },\n        {\n            key: \"scrollTo\",\n            value: function scrollTo(target) {\n                var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n                // Parse options\n                var offset = parseInt(options.offset) || 0; // An offset to apply on top of given `target` or `sourceElem`'s target\n                var callback = options.callback ? options.callback : false; // function called when scrollTo completes (note that it won't wait for lerp to stabilize)\n                if (typeof target === \"string\") {\n                    // Selector or boundaries\n                    if (target === \"top\") {\n                        target = this.html;\n                    } else if (target === \"bottom\") {\n                        target = this.html.offsetHeight - window.innerHeight;\n                    } else {\n                        target = document.querySelector(target); // If the query fails, abort\n                        if (!target) {\n                            return;\n                        }\n                    }\n                } else if (typeof target === \"number\") {\n                    // Absolute coordinate\n                    target = parseInt(target);\n                } else if (target && target.tagName) ;\n                else {\n                    console.warn(\"`target` parameter is not valid\");\n                    return;\n                } // We have a target that is not a coordinate yet, get it\n                if (typeof target !== \"number\") {\n                    offset = target.getBoundingClientRect().top + offset + this.instance.scroll.y;\n                } else {\n                    offset = target + offset;\n                }\n                var isTargetReached = function isTargetReached() {\n                    return parseInt(window.pageYOffset) === parseInt(offset);\n                };\n                if (callback) {\n                    if (isTargetReached()) {\n                        callback();\n                        return;\n                    } else {\n                        var onScroll = function onScroll() {\n                            if (isTargetReached()) {\n                                window.removeEventListener(\"scroll\", onScroll);\n                                callback();\n                            }\n                        };\n                        window.addEventListener(\"scroll\", onScroll);\n                    }\n                }\n                window.scrollTo({\n                    top: offset,\n                    behavior: options.duration === 0 ? \"auto\" : \"smooth\"\n                });\n            }\n        },\n        {\n            key: \"update\",\n            value: function update() {\n                this.addElements();\n                this.detectElements();\n            }\n        },\n        {\n            key: \"destroy\",\n            value: function destroy() {\n                _get(_getPrototypeOf(_default.prototype), \"destroy\", this).call(this);\n                window.removeEventListener(\"scroll\", this.checkScroll, false);\n            }\n        }\n    ]);\n    return _default;\n}(_default);\n/*\nobject-assign\n(c) Sindre Sorhus\n@license MIT\n*/ /* eslint-disable no-unused-vars */ var getOwnPropertySymbols = Object.getOwnPropertySymbols;\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\nvar propIsEnumerable = Object.prototype.propertyIsEnumerable;\nfunction toObject(val) {\n    if (val === null || val === undefined) {\n        throw new TypeError(\"Object.assign cannot be called with null or undefined\");\n    }\n    return Object(val);\n}\nfunction shouldUseNative() {\n    try {\n        if (!Object.assign) {\n            return false;\n        }\n        // Detect buggy property enumeration order in older V8 versions.\n        // https://bugs.chromium.org/p/v8/issues/detail?id=4118\n        var test1 = new String(\"abc\"); // eslint-disable-line no-new-wrappers\n        test1[5] = \"de\";\n        if (Object.getOwnPropertyNames(test1)[0] === \"5\") {\n            return false;\n        }\n        // https://bugs.chromium.org/p/v8/issues/detail?id=3056\n        var test2 = {};\n        for(var i = 0; i < 10; i++){\n            test2[\"_\" + String.fromCharCode(i)] = i;\n        }\n        var order2 = Object.getOwnPropertyNames(test2).map(function(n) {\n            return test2[n];\n        });\n        if (order2.join(\"\") !== \"0123456789\") {\n            return false;\n        }\n        // https://bugs.chromium.org/p/v8/issues/detail?id=3056\n        var test3 = {};\n        \"abcdefghijklmnopqrst\".split(\"\").forEach(function(letter) {\n            test3[letter] = letter;\n        });\n        if (Object.keys(Object.assign({}, test3)).join(\"\") !== \"abcdefghijklmnopqrst\") {\n            return false;\n        }\n        return true;\n    } catch (err) {\n        // We don't expect any of the above to throw, but better to be safe.\n        return false;\n    }\n}\nvar objectAssign = shouldUseNative() ? Object.assign : function(target, source) {\n    var from;\n    var to = toObject(target);\n    var symbols;\n    for(var s = 1; s < arguments.length; s++){\n        from = Object(arguments[s]);\n        for(var key in from){\n            if (hasOwnProperty.call(from, key)) {\n                to[key] = from[key];\n            }\n        }\n        if (getOwnPropertySymbols) {\n            symbols = getOwnPropertySymbols(from);\n            for(var i = 0; i < symbols.length; i++){\n                if (propIsEnumerable.call(from, symbols[i])) {\n                    to[symbols[i]] = from[symbols[i]];\n                }\n            }\n        }\n    }\n    return to;\n};\nfunction E() {\n// Keep this empty so it's easier to inherit from\n// (via https://github.com/lipsmack from https://github.com/scottcorgan/tiny-emitter/issues/3)\n}\n_c = E;\nE.prototype = {\n    on: function(name, callback, ctx) {\n        var e = this.e || (this.e = {});\n        (e[name] || (e[name] = [])).push({\n            fn: callback,\n            ctx: ctx\n        });\n        return this;\n    },\n    once: function(name, callback, ctx) {\n        var self1 = this;\n        function listener() {\n            self1.off(name, listener);\n            callback.apply(ctx, arguments);\n        }\n        listener._ = callback;\n        return this.on(name, listener, ctx);\n    },\n    emit: function(name) {\n        var data = [].slice.call(arguments, 1);\n        var evtArr = ((this.e || (this.e = {}))[name] || []).slice();\n        var i = 0;\n        var len = evtArr.length;\n        for(i; i < len; i++){\n            evtArr[i].fn.apply(evtArr[i].ctx, data);\n        }\n        return this;\n    },\n    off: function(name, callback) {\n        var e = this.e || (this.e = {});\n        var evts = e[name];\n        var liveEvents = [];\n        if (evts && callback) {\n            for(var i = 0, len = evts.length; i < len; i++){\n                if (evts[i].fn !== callback && evts[i].fn._ !== callback) liveEvents.push(evts[i]);\n            }\n        }\n        // Remove event from queue to prevent memory leak\n        // Suggested by https://github.com/lazd\n        // Ref: https://github.com/scottcorgan/tiny-emitter/commit/c6ebfaa9bc973b33d110a84a307742b7cf94c953#commitcomment-5024910\n        liveEvents.length ? e[name] = liveEvents : delete e[name];\n        return this;\n    }\n};\nvar tinyEmitter = E;\nvar lethargy = createCommonjsModule(function(module, exports) {\n    // Generated by CoffeeScript 1.9.2\n    (function() {\n        var root;\n        root = exports !== null ? exports : this;\n        root.Lethargy = function() {\n            function Lethargy(stability, sensitivity, tolerance, delay) {\n                this.stability = stability != null ? Math.abs(stability) : 8;\n                this.sensitivity = sensitivity != null ? 1 + Math.abs(sensitivity) : 100;\n                this.tolerance = tolerance != null ? 1 + Math.abs(tolerance) : 1.1;\n                this.delay = delay != null ? delay : 150;\n                this.lastUpDeltas = (function() {\n                    var i, ref, results;\n                    results = [];\n                    for(i = 1, ref = this.stability * 2; 1 <= ref ? i <= ref : i >= ref; 1 <= ref ? i++ : i--){\n                        results.push(null);\n                    }\n                    return results;\n                }).call(this);\n                this.lastDownDeltas = (function() {\n                    var i, ref, results;\n                    results = [];\n                    for(i = 1, ref = this.stability * 2; 1 <= ref ? i <= ref : i >= ref; 1 <= ref ? i++ : i--){\n                        results.push(null);\n                    }\n                    return results;\n                }).call(this);\n                this.deltasTimestamp = (function() {\n                    var i, ref, results;\n                    results = [];\n                    for(i = 1, ref = this.stability * 2; 1 <= ref ? i <= ref : i >= ref; 1 <= ref ? i++ : i--){\n                        results.push(null);\n                    }\n                    return results;\n                }).call(this);\n            }\n            Lethargy.prototype.check = function(e) {\n                var lastDelta;\n                e = e.originalEvent || e;\n                if (e.wheelDelta != null) {\n                    lastDelta = e.wheelDelta;\n                } else if (e.deltaY != null) {\n                    lastDelta = e.deltaY * -40;\n                } else if (e.detail != null || e.detail === 0) {\n                    lastDelta = e.detail * -40;\n                }\n                this.deltasTimestamp.push(Date.now());\n                this.deltasTimestamp.shift();\n                if (lastDelta > 0) {\n                    this.lastUpDeltas.push(lastDelta);\n                    this.lastUpDeltas.shift();\n                    return this.isInertia(1);\n                } else {\n                    this.lastDownDeltas.push(lastDelta);\n                    this.lastDownDeltas.shift();\n                    return this.isInertia(-1);\n                }\n            };\n            Lethargy.prototype.isInertia = function(direction) {\n                var lastDeltas, lastDeltasNew, lastDeltasOld, newAverage, newSum, oldAverage, oldSum;\n                lastDeltas = direction === -1 ? this.lastDownDeltas : this.lastUpDeltas;\n                if (lastDeltas[0] === null) {\n                    return direction;\n                }\n                if (this.deltasTimestamp[this.stability * 2 - 2] + this.delay > Date.now() && lastDeltas[0] === lastDeltas[this.stability * 2 - 1]) {\n                    return false;\n                }\n                lastDeltasOld = lastDeltas.slice(0, this.stability);\n                lastDeltasNew = lastDeltas.slice(this.stability, this.stability * 2);\n                oldSum = lastDeltasOld.reduce(function(t, s) {\n                    return t + s;\n                });\n                newSum = lastDeltasNew.reduce(function(t, s) {\n                    return t + s;\n                });\n                oldAverage = oldSum / lastDeltasOld.length;\n                newAverage = newSum / lastDeltasNew.length;\n                if (Math.abs(oldAverage) < Math.abs(newAverage * this.tolerance) && this.sensitivity < Math.abs(newAverage)) {\n                    return direction;\n                } else {\n                    return false;\n                }\n            };\n            Lethargy.prototype.showLastUpDeltas = function() {\n                return this.lastUpDeltas;\n            };\n            Lethargy.prototype.showLastDownDeltas = function() {\n                return this.lastDownDeltas;\n            };\n            return Lethargy;\n        }();\n    }).call(commonjsGlobal);\n});\nvar support = function getSupport() {\n    return {\n        hasWheelEvent: \"onwheel\" in document,\n        hasMouseWheelEvent: \"onmousewheel\" in document,\n        hasTouch: \"ontouchstart\" in window || window.TouchEvent || window.DocumentTouch && document instanceof DocumentTouch,\n        hasTouchWin: navigator.msMaxTouchPoints && navigator.msMaxTouchPoints > 1,\n        hasPointer: !!window.navigator.msPointerEnabled,\n        hasKeyDown: \"onkeydown\" in document,\n        isFirefox: navigator.userAgent.indexOf(\"Firefox\") > -1\n    };\n}();\nvar toString = Object.prototype.toString, hasOwnProperty$1 = Object.prototype.hasOwnProperty;\nvar bindallStandalone = function(object) {\n    if (!object) return console.warn(\"bindAll requires at least one argument.\");\n    var functions = Array.prototype.slice.call(arguments, 1);\n    if (functions.length === 0) {\n        for(var method in object){\n            if (hasOwnProperty$1.call(object, method)) {\n                if (typeof object[method] == \"function\" && toString.call(object[method]) == \"[object Function]\") {\n                    functions.push(method);\n                }\n            }\n        }\n    }\n    for(var i = 0; i < functions.length; i++){\n        var f = functions[i];\n        object[f] = bind(object[f], object);\n    }\n};\n/*\n    Faster bind without specific-case checking. (see https://coderwall.com/p/oi3j3w).\n    bindAll is only needed for events binding so no need to make slow fixes for constructor\n    or partial application.\n*/ function bind(func, context) {\n    return function() {\n        return func.apply(context, arguments);\n    };\n}\nvar Lethargy = lethargy.Lethargy;\nvar EVT_ID = \"virtualscroll\";\nvar src = VirtualScroll;\nvar keyCodes = {\n    LEFT: 37,\n    UP: 38,\n    RIGHT: 39,\n    DOWN: 40,\n    SPACE: 32\n};\nfunction VirtualScroll(options) {\n    bindallStandalone(this, \"_onWheel\", \"_onMouseWheel\", \"_onTouchStart\", \"_onTouchMove\", \"_onKeyDown\");\n    this.el = window;\n    if (options && options.el) {\n        this.el = options.el;\n        delete options.el;\n    }\n    this.options = objectAssign({\n        mouseMultiplier: 1,\n        touchMultiplier: 2,\n        firefoxMultiplier: 15,\n        keyStep: 120,\n        preventTouch: false,\n        unpreventTouchClass: \"vs-touchmove-allowed\",\n        limitInertia: false,\n        useKeyboard: true,\n        useTouch: true\n    }, options);\n    if (this.options.limitInertia) this._lethargy = new Lethargy();\n    this._emitter = new tinyEmitter();\n    this._event = {\n        y: 0,\n        x: 0,\n        deltaX: 0,\n        deltaY: 0\n    };\n    this.touchStartX = null;\n    this.touchStartY = null;\n    this.bodyTouchAction = null;\n    if (this.options.passive !== undefined) {\n        this.listenerOptions = {\n            passive: this.options.passive\n        };\n    }\n}\n_c1 = VirtualScroll;\nVirtualScroll.prototype._notify = function(e) {\n    var evt = this._event;\n    evt.x += evt.deltaX;\n    evt.y += evt.deltaY;\n    this._emitter.emit(EVT_ID, {\n        x: evt.x,\n        y: evt.y,\n        deltaX: evt.deltaX,\n        deltaY: evt.deltaY,\n        originalEvent: e\n    });\n};\nVirtualScroll.prototype._onWheel = function(e) {\n    var options = this.options;\n    if (this._lethargy && this._lethargy.check(e) === false) return;\n    var evt = this._event;\n    // In Chrome and in Firefox (at least the new one)\n    evt.deltaX = e.wheelDeltaX || e.deltaX * -1;\n    evt.deltaY = e.wheelDeltaY || e.deltaY * -1;\n    // for our purpose deltamode = 1 means user is on a wheel mouse, not touch pad\n    // real meaning: https://developer.mozilla.org/en-US/docs/Web/API/WheelEvent#Delta_modes\n    if (support.isFirefox && e.deltaMode == 1) {\n        evt.deltaX *= options.firefoxMultiplier;\n        evt.deltaY *= options.firefoxMultiplier;\n    }\n    evt.deltaX *= options.mouseMultiplier;\n    evt.deltaY *= options.mouseMultiplier;\n    this._notify(e);\n};\nVirtualScroll.prototype._onMouseWheel = function(e) {\n    if (this.options.limitInertia && this._lethargy.check(e) === false) return;\n    var evt = this._event;\n    // In Safari, IE and in Chrome if 'wheel' isn't defined\n    evt.deltaX = e.wheelDeltaX ? e.wheelDeltaX : 0;\n    evt.deltaY = e.wheelDeltaY ? e.wheelDeltaY : e.wheelDelta;\n    this._notify(e);\n};\nVirtualScroll.prototype._onTouchStart = function(e) {\n    var t = e.targetTouches ? e.targetTouches[0] : e;\n    this.touchStartX = t.pageX;\n    this.touchStartY = t.pageY;\n};\nVirtualScroll.prototype._onTouchMove = function(e) {\n    var options = this.options;\n    if (options.preventTouch && !e.target.classList.contains(options.unpreventTouchClass)) {\n        e.preventDefault();\n    }\n    var evt = this._event;\n    var t = e.targetTouches ? e.targetTouches[0] : e;\n    evt.deltaX = (t.pageX - this.touchStartX) * options.touchMultiplier;\n    evt.deltaY = (t.pageY - this.touchStartY) * options.touchMultiplier;\n    this.touchStartX = t.pageX;\n    this.touchStartY = t.pageY;\n    this._notify(e);\n};\nVirtualScroll.prototype._onKeyDown = function(e) {\n    var evt = this._event;\n    evt.deltaX = evt.deltaY = 0;\n    var windowHeight = window.innerHeight - 40;\n    switch(e.keyCode){\n        case keyCodes.LEFT:\n        case keyCodes.UP:\n            evt.deltaY = this.options.keyStep;\n            break;\n        case keyCodes.RIGHT:\n        case keyCodes.DOWN:\n            evt.deltaY = -this.options.keyStep;\n            break;\n        case e.shiftKey:\n            evt.deltaY = windowHeight;\n            break;\n        case keyCodes.SPACE:\n            evt.deltaY = -windowHeight;\n            break;\n        default:\n            return;\n    }\n    this._notify(e);\n};\nVirtualScroll.prototype._bind = function() {\n    if (support.hasWheelEvent) this.el.addEventListener(\"wheel\", this._onWheel, this.listenerOptions);\n    if (support.hasMouseWheelEvent) this.el.addEventListener(\"mousewheel\", this._onMouseWheel, this.listenerOptions);\n    if (support.hasTouch && this.options.useTouch) {\n        this.el.addEventListener(\"touchstart\", this._onTouchStart, this.listenerOptions);\n        this.el.addEventListener(\"touchmove\", this._onTouchMove, this.listenerOptions);\n    }\n    if (support.hasPointer && support.hasTouchWin) {\n        this.bodyTouchAction = document.body.style.msTouchAction;\n        document.body.style.msTouchAction = \"none\";\n        this.el.addEventListener(\"MSPointerDown\", this._onTouchStart, true);\n        this.el.addEventListener(\"MSPointerMove\", this._onTouchMove, true);\n    }\n    if (support.hasKeyDown && this.options.useKeyboard) document.addEventListener(\"keydown\", this._onKeyDown);\n};\nVirtualScroll.prototype._unbind = function() {\n    if (support.hasWheelEvent) this.el.removeEventListener(\"wheel\", this._onWheel);\n    if (support.hasMouseWheelEvent) this.el.removeEventListener(\"mousewheel\", this._onMouseWheel);\n    if (support.hasTouch) {\n        this.el.removeEventListener(\"touchstart\", this._onTouchStart);\n        this.el.removeEventListener(\"touchmove\", this._onTouchMove);\n    }\n    if (support.hasPointer && support.hasTouchWin) {\n        document.body.style.msTouchAction = this.bodyTouchAction;\n        this.el.removeEventListener(\"MSPointerDown\", this._onTouchStart, true);\n        this.el.removeEventListener(\"MSPointerMove\", this._onTouchMove, true);\n    }\n    if (support.hasKeyDown && this.options.useKeyboard) document.removeEventListener(\"keydown\", this._onKeyDown);\n};\nVirtualScroll.prototype.on = function(cb, ctx) {\n    this._emitter.on(EVT_ID, cb, ctx);\n    var events = this._emitter.e;\n    if (events && events[EVT_ID] && events[EVT_ID].length === 1) this._bind();\n};\nVirtualScroll.prototype.off = function(cb, ctx) {\n    this._emitter.off(EVT_ID, cb, ctx);\n    var events = this._emitter.e;\n    if (!events[EVT_ID] || events[EVT_ID].length <= 0) this._unbind();\n};\nVirtualScroll.prototype.reset = function() {\n    var evt = this._event;\n    evt.x = 0;\n    evt.y = 0;\n};\nVirtualScroll.prototype.destroy = function() {\n    this._emitter.off();\n    this._unbind();\n};\nfunction lerp(start, end, amt) {\n    return (1 - amt) * start + amt * end;\n}\nfunction getTranslate(el) {\n    var translate = {};\n    if (!window.getComputedStyle) return;\n    var style = getComputedStyle(el);\n    var transform = style.transform || style.webkitTransform || style.mozTransform;\n    var mat = transform.match(/^matrix3d\\((.+)\\)$/);\n    if (mat) {\n        translate.x = mat ? parseFloat(mat[1].split(\", \")[12]) : 0;\n        translate.y = mat ? parseFloat(mat[1].split(\", \")[13]) : 0;\n    } else {\n        mat = transform.match(/^matrix\\((.+)\\)$/);\n        translate.x = mat ? parseFloat(mat[1].split(\", \")[4]) : 0;\n        translate.y = mat ? parseFloat(mat[1].split(\", \")[5]) : 0;\n    }\n    return translate;\n}\n/**\n * Returns an array containing all the parent nodes of the given node\n * @param  {object} node\n * @return {array} parent nodes\n */ function getParents(elem) {\n    // Set up a parent array\n    var parents = []; // Push each parent element to the array\n    for(; elem && elem !== document; elem = elem.parentNode){\n        parents.push(elem);\n    } // Return our parent array\n    return parents;\n} // https://gomakethings.com/how-to-get-the-closest-parent-element-with-a-matching-selector-using-vanilla-javascript/\n/**\n * https://github.com/gre/bezier-easing\n * BezierEasing - use bezier curve for transition easing function\n * by Gaëtan Renaudeau 2014 - 2015 – MIT License\n */ // These values are established by empiricism with tests (tradeoff: performance VS precision)\nvar NEWTON_ITERATIONS = 4;\nvar NEWTON_MIN_SLOPE = 0.001;\nvar SUBDIVISION_PRECISION = 0.0000001;\nvar SUBDIVISION_MAX_ITERATIONS = 10;\nvar kSplineTableSize = 11;\nvar kSampleStepSize = 1.0 / (kSplineTableSize - 1.0);\nvar float32ArraySupported = typeof Float32Array === \"function\";\nfunction A(aA1, aA2) {\n    return 1.0 - 3.0 * aA2 + 3.0 * aA1;\n}\n_c2 = A;\nfunction B(aA1, aA2) {\n    return 3.0 * aA2 - 6.0 * aA1;\n}\n_c3 = B;\nfunction C(aA1) {\n    return 3.0 * aA1;\n}\n_c4 = C;\n// Returns x(t) given t, x1, and x2, or y(t) given t, y1, and y2.\nfunction calcBezier(aT, aA1, aA2) {\n    return ((A(aA1, aA2) * aT + B(aA1, aA2)) * aT + C(aA1)) * aT;\n}\n// Returns dx/dt given t, x1, and x2, or dy/dt given t, y1, and y2.\nfunction getSlope(aT, aA1, aA2) {\n    return 3.0 * A(aA1, aA2) * aT * aT + 2.0 * B(aA1, aA2) * aT + C(aA1);\n}\nfunction binarySubdivide(aX, aA, aB, mX1, mX2) {\n    var currentX, currentT, i = 0;\n    do {\n        currentT = aA + (aB - aA) / 2.0;\n        currentX = calcBezier(currentT, mX1, mX2) - aX;\n        if (currentX > 0.0) {\n            aB = currentT;\n        } else {\n            aA = currentT;\n        }\n    }while (Math.abs(currentX) > SUBDIVISION_PRECISION && ++i < SUBDIVISION_MAX_ITERATIONS);\n    return currentT;\n}\nfunction newtonRaphsonIterate(aX, aGuessT, mX1, mX2) {\n    for(var i = 0; i < NEWTON_ITERATIONS; ++i){\n        var currentSlope = getSlope(aGuessT, mX1, mX2);\n        if (currentSlope === 0.0) {\n            return aGuessT;\n        }\n        var currentX = calcBezier(aGuessT, mX1, mX2) - aX;\n        aGuessT -= currentX / currentSlope;\n    }\n    return aGuessT;\n}\nfunction LinearEasing(x) {\n    return x;\n}\n_c5 = LinearEasing;\nvar src$1 = function bezier(mX1, mY1, mX2, mY2) {\n    if (!(0 <= mX1 && mX1 <= 1 && 0 <= mX2 && mX2 <= 1)) {\n        throw new Error(\"bezier x values must be in [0, 1] range\");\n    }\n    if (mX1 === mY1 && mX2 === mY2) {\n        return LinearEasing;\n    }\n    // Precompute samples table\n    var sampleValues = float32ArraySupported ? new Float32Array(kSplineTableSize) : new Array(kSplineTableSize);\n    for(var i = 0; i < kSplineTableSize; ++i){\n        sampleValues[i] = calcBezier(i * kSampleStepSize, mX1, mX2);\n    }\n    function getTForX(aX) {\n        var intervalStart = 0.0;\n        var currentSample = 1;\n        var lastSample = kSplineTableSize - 1;\n        for(; currentSample !== lastSample && sampleValues[currentSample] <= aX; ++currentSample){\n            intervalStart += kSampleStepSize;\n        }\n        --currentSample;\n        // Interpolate to provide an initial guess for t\n        var dist = (aX - sampleValues[currentSample]) / (sampleValues[currentSample + 1] - sampleValues[currentSample]);\n        var guessForT = intervalStart + dist * kSampleStepSize;\n        var initialSlope = getSlope(guessForT, mX1, mX2);\n        if (initialSlope >= NEWTON_MIN_SLOPE) {\n            return newtonRaphsonIterate(aX, guessForT, mX1, mX2);\n        } else if (initialSlope === 0.0) {\n            return guessForT;\n        } else {\n            return binarySubdivide(aX, intervalStart, intervalStart + kSampleStepSize, mX1, mX2);\n        }\n    }\n    return function BezierEasing(x) {\n        // Because JavaScript number are imprecise, we should guarantee the extremes are right.\n        if (x === 0) {\n            return 0;\n        }\n        if (x === 1) {\n            return 1;\n        }\n        return calcBezier(getTForX(x), mY1, mY2);\n    };\n};\nvar keyCodes$1 = {\n    LEFT: 37,\n    UP: 38,\n    RIGHT: 39,\n    DOWN: 40,\n    SPACE: 32,\n    TAB: 9,\n    PAGEUP: 33,\n    PAGEDOWN: 34,\n    HOME: 36,\n    END: 35\n};\nvar _default$2 = /*#__PURE__*/ function(_Core) {\n    _inherits(_default, _Core);\n    var _super = _createSuper(_default);\n    function _default() {\n        var _this;\n        var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n        _classCallCheck(this, _default);\n        if (history.scrollRestoration) {\n            history.scrollRestoration = \"manual\";\n        }\n        window.scrollTo(0, 0);\n        _this = _super.call(this, options);\n        if (_this.inertia) _this.lerp = _this.inertia * 0.1;\n        _this.isScrolling = false;\n        _this.isDraggingScrollbar = false;\n        _this.isTicking = false;\n        _this.hasScrollTicking = false;\n        _this.parallaxElements = {};\n        _this.stop = false;\n        _this.scrollbarContainer = options.scrollbarContainer;\n        _this.checkKey = _this.checkKey.bind(_assertThisInitialized(_this));\n        window.addEventListener(\"keydown\", _this.checkKey, false);\n        return _this;\n    }\n    _createClass(_default, [\n        {\n            key: \"init\",\n            value: function init() {\n                var _this2 = this;\n                this.html.classList.add(this.smoothClass);\n                this.html.setAttribute(\"data-\".concat(this.name, \"-direction\"), this.direction);\n                this.instance = _objectSpread2({\n                    delta: {\n                        x: this.initPosition.x,\n                        y: this.initPosition.y\n                    },\n                    scroll: {\n                        x: this.initPosition.x,\n                        y: this.initPosition.y\n                    }\n                }, this.instance);\n                this.vs = new src({\n                    el: this.scrollFromAnywhere ? document : this.el,\n                    mouseMultiplier: navigator.platform.indexOf(\"Win\") > -1 ? 1 : 0.4,\n                    firefoxMultiplier: this.firefoxMultiplier,\n                    touchMultiplier: this.touchMultiplier,\n                    useKeyboard: false,\n                    passive: true\n                });\n                this.vs.on(function(e) {\n                    if (_this2.stop) {\n                        return;\n                    }\n                    if (!_this2.isDraggingScrollbar) {\n                        requestAnimationFrame(function() {\n                            _this2.updateDelta(e);\n                            if (!_this2.isScrolling) _this2.startScrolling();\n                        });\n                    }\n                });\n                this.setScrollLimit();\n                this.initScrollBar();\n                this.addSections();\n                this.addElements();\n                this.checkScroll(true);\n                this.transformElements(true, true);\n                _get(_getPrototypeOf(_default.prototype), \"init\", this).call(this);\n            }\n        },\n        {\n            key: \"setScrollLimit\",\n            value: function setScrollLimit() {\n                this.instance.limit.y = this.el.offsetHeight - this.windowHeight;\n                if (this.direction === \"horizontal\") {\n                    var totalWidth = 0;\n                    var nodes = this.el.children;\n                    for(var i = 0; i < nodes.length; i++){\n                        totalWidth += nodes[i].offsetWidth;\n                    }\n                    this.instance.limit.x = totalWidth - this.windowWidth;\n                }\n            }\n        },\n        {\n            key: \"startScrolling\",\n            value: function startScrolling() {\n                this.startScrollTs = Date.now(); // Record timestamp\n                this.isScrolling = true;\n                this.checkScroll();\n                this.html.classList.add(this.scrollingClass);\n            }\n        },\n        {\n            key: \"stopScrolling\",\n            value: function stopScrolling() {\n                cancelAnimationFrame(this.checkScrollRaf); // Prevent checkScroll to continue looping\n                //Pevent scrollbar glitch/locking\n                this.startScrollTs = undefined;\n                if (this.scrollToRaf) {\n                    cancelAnimationFrame(this.scrollToRaf);\n                    this.scrollToRaf = null;\n                }\n                this.isScrolling = false;\n                this.instance.scroll.y = Math.round(this.instance.scroll.y);\n                this.html.classList.remove(this.scrollingClass);\n            }\n        },\n        {\n            key: \"checkKey\",\n            value: function checkKey(e) {\n                var _this3 = this;\n                if (this.stop) {\n                    // If we are stopped, we don't want any scroll to occur because of a keypress\n                    // Prevent tab to scroll to activeElement\n                    if (e.keyCode == keyCodes$1.TAB) {\n                        requestAnimationFrame(function() {\n                            // Make sure native scroll is always at top of page\n                            _this3.html.scrollTop = 0;\n                            document.body.scrollTop = 0;\n                            _this3.html.scrollLeft = 0;\n                            document.body.scrollLeft = 0;\n                        });\n                    }\n                    return;\n                }\n                switch(e.keyCode){\n                    case keyCodes$1.TAB:\n                        // Do not remove the RAF\n                        // It allows to override the browser's native scrollTo, which is essential\n                        requestAnimationFrame(function() {\n                            // Make sure native scroll is always at top of page\n                            _this3.html.scrollTop = 0;\n                            document.body.scrollTop = 0;\n                            _this3.html.scrollLeft = 0;\n                            document.body.scrollLeft = 0; // Request scrollTo on the focusedElement, putting it at the center of the screen\n                            _this3.scrollTo(document.activeElement, {\n                                offset: -window.innerHeight / 2\n                            });\n                        });\n                        break;\n                    case keyCodes$1.UP:\n                        if (this.isActiveElementScrollSensitive()) {\n                            this.instance.delta[this.directionAxis] -= 240;\n                        }\n                        break;\n                    case keyCodes$1.DOWN:\n                        if (this.isActiveElementScrollSensitive()) {\n                            this.instance.delta[this.directionAxis] += 240;\n                        }\n                        break;\n                    case keyCodes$1.PAGEUP:\n                        this.instance.delta[this.directionAxis] -= window.innerHeight;\n                        break;\n                    case keyCodes$1.PAGEDOWN:\n                        this.instance.delta[this.directionAxis] += window.innerHeight;\n                        break;\n                    case keyCodes$1.HOME:\n                        this.instance.delta[this.directionAxis] -= this.instance.limit[this.directionAxis];\n                        break;\n                    case keyCodes$1.END:\n                        this.instance.delta[this.directionAxis] += this.instance.limit[this.directionAxis];\n                        break;\n                    case keyCodes$1.SPACE:\n                        if (this.isActiveElementScrollSensitive()) {\n                            if (e.shiftKey) {\n                                this.instance.delta[this.directionAxis] -= window.innerHeight;\n                            } else {\n                                this.instance.delta[this.directionAxis] += window.innerHeight;\n                            }\n                        }\n                        break;\n                    default:\n                        return;\n                }\n                if (this.instance.delta[this.directionAxis] < 0) this.instance.delta[this.directionAxis] = 0;\n                if (this.instance.delta[this.directionAxis] > this.instance.limit[this.directionAxis]) this.instance.delta[this.directionAxis] = this.instance.limit[this.directionAxis];\n                this.stopScrolling(); // Stop any movement, allows to kill any other `scrollTo` still happening\n                this.isScrolling = true;\n                this.checkScroll();\n                this.html.classList.add(this.scrollingClass);\n            }\n        },\n        {\n            key: \"isActiveElementScrollSensitive\",\n            value: function isActiveElementScrollSensitive() {\n                return !(document.activeElement instanceof HTMLInputElement) && !(document.activeElement instanceof HTMLTextAreaElement) && !(document.activeElement instanceof HTMLButtonElement) && !(document.activeElement instanceof HTMLSelectElement);\n            }\n        },\n        {\n            key: \"checkScroll\",\n            value: function checkScroll() {\n                var _this4 = this;\n                var forced = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n                if (forced || this.isScrolling || this.isDraggingScrollbar) {\n                    if (!this.hasScrollTicking) {\n                        this.checkScrollRaf = requestAnimationFrame(function() {\n                            return _this4.checkScroll();\n                        });\n                        this.hasScrollTicking = true;\n                    }\n                    this.updateScroll();\n                    var distance = Math.abs(this.instance.delta[this.directionAxis] - this.instance.scroll[this.directionAxis]);\n                    var timeSinceStart = Date.now() - this.startScrollTs; // Get the time since the scroll was started: the scroll can be stopped again only past 100ms\n                    if (!this.animatingScroll && timeSinceStart > 100 && (distance < 0.5 && this.instance.delta[this.directionAxis] != 0 || distance < 0.5 && this.instance.delta[this.directionAxis] == 0)) {\n                        this.stopScrolling();\n                    }\n                    Object.entries(this.sections).forEach(function(_ref) {\n                        var _ref2 = _slicedToArray(_ref, 2), i = _ref2[0], section = _ref2[1];\n                        if (section.persistent || _this4.instance.scroll[_this4.directionAxis] > section.offset[_this4.directionAxis] && _this4.instance.scroll[_this4.directionAxis] < section.limit[_this4.directionAxis]) {\n                            if (_this4.direction === \"horizontal\") {\n                                _this4.transform(section.el, -_this4.instance.scroll[_this4.directionAxis], 0);\n                            } else {\n                                _this4.transform(section.el, 0, -_this4.instance.scroll[_this4.directionAxis]);\n                            }\n                            if (!section.inView) {\n                                section.inView = true;\n                                section.el.style.opacity = 1;\n                                section.el.style.pointerEvents = \"all\";\n                                section.el.setAttribute(\"data-\".concat(_this4.name, \"-section-inview\"), \"\");\n                            }\n                        } else {\n                            if (section.inView || forced) {\n                                section.inView = false;\n                                section.el.style.opacity = 0;\n                                section.el.style.pointerEvents = \"none\";\n                                section.el.removeAttribute(\"data-\".concat(_this4.name, \"-section-inview\"));\n                            }\n                            _this4.transform(section.el, 0, 0);\n                        }\n                    });\n                    if (this.getDirection) {\n                        this.addDirection();\n                    }\n                    if (this.getSpeed) {\n                        this.addSpeed();\n                        this.speedTs = Date.now();\n                    }\n                    this.detectElements();\n                    this.transformElements();\n                    if (this.hasScrollbar) {\n                        var scrollBarTranslation = this.instance.scroll[this.directionAxis] / this.instance.limit[this.directionAxis] * this.scrollBarLimit[this.directionAxis];\n                        if (this.direction === \"horizontal\") {\n                            this.transform(this.scrollbarThumb, scrollBarTranslation, 0);\n                        } else {\n                            this.transform(this.scrollbarThumb, 0, scrollBarTranslation);\n                        }\n                    }\n                    _get(_getPrototypeOf(_default.prototype), \"checkScroll\", this).call(this);\n                    this.hasScrollTicking = false;\n                }\n            }\n        },\n        {\n            key: \"resize\",\n            value: function resize() {\n                this.windowHeight = window.innerHeight;\n                this.windowWidth = window.innerWidth;\n                this.checkContext();\n                this.windowMiddle = {\n                    x: this.windowWidth / 2,\n                    y: this.windowHeight / 2\n                };\n                this.update();\n            }\n        },\n        {\n            key: \"updateDelta\",\n            value: function updateDelta(e) {\n                var delta;\n                var gestureDirection = this[this.context] && this[this.context].gestureDirection ? this[this.context].gestureDirection : this.gestureDirection;\n                if (gestureDirection === \"both\") {\n                    delta = e.deltaX + e.deltaY;\n                } else if (gestureDirection === \"vertical\") {\n                    delta = e.deltaY;\n                } else if (gestureDirection === \"horizontal\") {\n                    delta = e.deltaX;\n                } else {\n                    delta = e.deltaY;\n                }\n                this.instance.delta[this.directionAxis] -= delta * this.multiplier;\n                if (this.instance.delta[this.directionAxis] < 0) this.instance.delta[this.directionAxis] = 0;\n                if (this.instance.delta[this.directionAxis] > this.instance.limit[this.directionAxis]) this.instance.delta[this.directionAxis] = this.instance.limit[this.directionAxis];\n            }\n        },\n        {\n            key: \"updateScroll\",\n            value: function updateScroll(e) {\n                if (this.isScrolling || this.isDraggingScrollbar) {\n                    this.instance.scroll[this.directionAxis] = lerp(this.instance.scroll[this.directionAxis], this.instance.delta[this.directionAxis], this.lerp);\n                } else {\n                    if (this.instance.scroll[this.directionAxis] > this.instance.limit[this.directionAxis]) {\n                        this.setScroll(this.instance.scroll[this.directionAxis], this.instance.limit[this.directionAxis]);\n                    } else if (this.instance.scroll.y < 0) {\n                        this.setScroll(this.instance.scroll[this.directionAxis], 0);\n                    } else {\n                        this.setScroll(this.instance.scroll[this.directionAxis], this.instance.delta[this.directionAxis]);\n                    }\n                }\n            }\n        },\n        {\n            key: \"addDirection\",\n            value: function addDirection() {\n                if (this.instance.delta.y > this.instance.scroll.y) {\n                    if (this.instance.direction !== \"down\") {\n                        this.instance.direction = \"down\";\n                    }\n                } else if (this.instance.delta.y < this.instance.scroll.y) {\n                    if (this.instance.direction !== \"up\") {\n                        this.instance.direction = \"up\";\n                    }\n                }\n                if (this.instance.delta.x > this.instance.scroll.x) {\n                    if (this.instance.direction !== \"right\") {\n                        this.instance.direction = \"right\";\n                    }\n                } else if (this.instance.delta.x < this.instance.scroll.x) {\n                    if (this.instance.direction !== \"left\") {\n                        this.instance.direction = \"left\";\n                    }\n                }\n            }\n        },\n        {\n            key: \"addSpeed\",\n            value: function addSpeed() {\n                if (this.instance.delta[this.directionAxis] != this.instance.scroll[this.directionAxis]) {\n                    this.instance.speed = (this.instance.delta[this.directionAxis] - this.instance.scroll[this.directionAxis]) / Math.max(1, Date.now() - this.speedTs);\n                } else {\n                    this.instance.speed = 0;\n                }\n            }\n        },\n        {\n            key: \"initScrollBar\",\n            value: function initScrollBar() {\n                this.scrollbar = document.createElement(\"span\");\n                this.scrollbarThumb = document.createElement(\"span\");\n                this.scrollbar.classList.add(\"\".concat(this.scrollbarClass));\n                this.scrollbarThumb.classList.add(\"\".concat(this.scrollbarClass, \"_thumb\"));\n                this.scrollbar.append(this.scrollbarThumb);\n                if (this.scrollbarContainer) {\n                    this.scrollbarContainer.append(this.scrollbar);\n                } else {\n                    document.body.append(this.scrollbar);\n                } // Scrollbar Events\n                this.getScrollBar = this.getScrollBar.bind(this);\n                this.releaseScrollBar = this.releaseScrollBar.bind(this);\n                this.moveScrollBar = this.moveScrollBar.bind(this);\n                this.scrollbarThumb.addEventListener(\"mousedown\", this.getScrollBar);\n                window.addEventListener(\"mouseup\", this.releaseScrollBar);\n                window.addEventListener(\"mousemove\", this.moveScrollBar); // Set scrollbar values\n                this.hasScrollbar = false;\n                if (this.direction == \"horizontal\") {\n                    if (this.instance.limit.x + this.windowWidth <= this.windowWidth) {\n                        return;\n                    }\n                } else {\n                    if (this.instance.limit.y + this.windowHeight <= this.windowHeight) {\n                        return;\n                    }\n                }\n                this.hasScrollbar = true;\n                this.scrollbarBCR = this.scrollbar.getBoundingClientRect();\n                this.scrollbarHeight = this.scrollbarBCR.height;\n                this.scrollbarWidth = this.scrollbarBCR.width;\n                if (this.direction === \"horizontal\") {\n                    this.scrollbarThumb.style.width = \"\".concat(this.scrollbarWidth * this.scrollbarWidth / (this.instance.limit.x + this.scrollbarWidth), \"px\");\n                } else {\n                    this.scrollbarThumb.style.height = \"\".concat(this.scrollbarHeight * this.scrollbarHeight / (this.instance.limit.y + this.scrollbarHeight), \"px\");\n                }\n                this.scrollbarThumbBCR = this.scrollbarThumb.getBoundingClientRect();\n                this.scrollBarLimit = {\n                    x: this.scrollbarWidth - this.scrollbarThumbBCR.width,\n                    y: this.scrollbarHeight - this.scrollbarThumbBCR.height\n                };\n            }\n        },\n        {\n            key: \"reinitScrollBar\",\n            value: function reinitScrollBar() {\n                this.hasScrollbar = false;\n                if (this.direction == \"horizontal\") {\n                    if (this.instance.limit.x + this.windowWidth <= this.windowWidth) {\n                        return;\n                    }\n                } else {\n                    if (this.instance.limit.y + this.windowHeight <= this.windowHeight) {\n                        return;\n                    }\n                }\n                this.hasScrollbar = true;\n                this.scrollbarBCR = this.scrollbar.getBoundingClientRect();\n                this.scrollbarHeight = this.scrollbarBCR.height;\n                this.scrollbarWidth = this.scrollbarBCR.width;\n                if (this.direction === \"horizontal\") {\n                    this.scrollbarThumb.style.width = \"\".concat(this.scrollbarWidth * this.scrollbarWidth / (this.instance.limit.x + this.scrollbarWidth), \"px\");\n                } else {\n                    this.scrollbarThumb.style.height = \"\".concat(this.scrollbarHeight * this.scrollbarHeight / (this.instance.limit.y + this.scrollbarHeight), \"px\");\n                }\n                this.scrollbarThumbBCR = this.scrollbarThumb.getBoundingClientRect();\n                this.scrollBarLimit = {\n                    x: this.scrollbarWidth - this.scrollbarThumbBCR.width,\n                    y: this.scrollbarHeight - this.scrollbarThumbBCR.height\n                };\n            }\n        },\n        {\n            key: \"destroyScrollBar\",\n            value: function destroyScrollBar() {\n                this.scrollbarThumb.removeEventListener(\"mousedown\", this.getScrollBar);\n                window.removeEventListener(\"mouseup\", this.releaseScrollBar);\n                window.removeEventListener(\"mousemove\", this.moveScrollBar);\n                this.scrollbar.remove();\n            }\n        },\n        {\n            key: \"getScrollBar\",\n            value: function getScrollBar(e) {\n                this.isDraggingScrollbar = true;\n                this.checkScroll();\n                this.html.classList.remove(this.scrollingClass);\n                this.html.classList.add(this.draggingClass);\n            }\n        },\n        {\n            key: \"releaseScrollBar\",\n            value: function releaseScrollBar(e) {\n                this.isDraggingScrollbar = false;\n                if (this.isScrolling) {\n                    this.html.classList.add(this.scrollingClass);\n                }\n                this.html.classList.remove(this.draggingClass);\n            }\n        },\n        {\n            key: \"moveScrollBar\",\n            value: function moveScrollBar(e) {\n                var _this5 = this;\n                if (this.isDraggingScrollbar) {\n                    requestAnimationFrame(function() {\n                        var x = (e.clientX - _this5.scrollbarBCR.left) * 100 / _this5.scrollbarWidth * _this5.instance.limit.x / 100;\n                        var y = (e.clientY - _this5.scrollbarBCR.top) * 100 / _this5.scrollbarHeight * _this5.instance.limit.y / 100;\n                        if (y > 0 && y < _this5.instance.limit.y) {\n                            _this5.instance.delta.y = y;\n                        }\n                        if (x > 0 && x < _this5.instance.limit.x) {\n                            _this5.instance.delta.x = x;\n                        }\n                    });\n                }\n            }\n        },\n        {\n            key: \"addElements\",\n            value: function addElements() {\n                var _this6 = this;\n                this.els = {};\n                this.parallaxElements = {}; // this.sections.forEach((section, y) => {\n                var els = this.el.querySelectorAll(\"[data-\".concat(this.name, \"]\"));\n                els.forEach(function(el, index) {\n                    // Try and find the target's parent section\n                    var targetParents = getParents(el);\n                    var section = Object.entries(_this6.sections).map(function(_ref3) {\n                        var _ref4 = _slicedToArray(_ref3, 2), key = _ref4[0], section = _ref4[1];\n                        return section;\n                    }).find(function(section) {\n                        return targetParents.includes(section.el);\n                    });\n                    var cl = el.dataset[_this6.name + \"Class\"] || _this6[\"class\"];\n                    var id = typeof el.dataset[_this6.name + \"Id\"] === \"string\" ? el.dataset[_this6.name + \"Id\"] : \"el\" + index;\n                    var top;\n                    var left;\n                    var repeat = el.dataset[_this6.name + \"Repeat\"];\n                    var call = el.dataset[_this6.name + \"Call\"];\n                    var position = el.dataset[_this6.name + \"Position\"];\n                    var delay = el.dataset[_this6.name + \"Delay\"];\n                    var direction = el.dataset[_this6.name + \"Direction\"];\n                    var sticky = typeof el.dataset[_this6.name + \"Sticky\"] === \"string\";\n                    var speed = el.dataset[_this6.name + \"Speed\"] ? parseFloat(el.dataset[_this6.name + \"Speed\"]) / 10 : false;\n                    var offset = typeof el.dataset[_this6.name + \"Offset\"] === \"string\" ? el.dataset[_this6.name + \"Offset\"].split(\",\") : _this6.offset;\n                    var target = el.dataset[_this6.name + \"Target\"];\n                    var targetEl;\n                    if (target !== undefined) {\n                        targetEl = document.querySelector(\"\".concat(target));\n                    } else {\n                        targetEl = el;\n                    }\n                    var targetElBCR = targetEl.getBoundingClientRect();\n                    if (section === null) {\n                        top = targetElBCR.top + _this6.instance.scroll.y - getTranslate(targetEl).y;\n                        left = targetElBCR.left + _this6.instance.scroll.x - getTranslate(targetEl).x;\n                    } else {\n                        if (!section.inView) {\n                            top = targetElBCR.top - getTranslate(section.el).y - getTranslate(targetEl).y;\n                            left = targetElBCR.left - getTranslate(section.el).x - getTranslate(targetEl).x;\n                        } else {\n                            top = targetElBCR.top + _this6.instance.scroll.y - getTranslate(targetEl).y;\n                            left = targetElBCR.left + _this6.instance.scroll.x - getTranslate(targetEl).x;\n                        }\n                    }\n                    var bottom = top + targetEl.offsetHeight;\n                    var right = left + targetEl.offsetWidth;\n                    var middle = {\n                        x: (right - left) / 2 + left,\n                        y: (bottom - top) / 2 + top\n                    };\n                    if (sticky) {\n                        var elBCR = el.getBoundingClientRect();\n                        var elTop = elBCR.top;\n                        var elLeft = elBCR.left;\n                        var elDistance = {\n                            x: elLeft - left,\n                            y: elTop - top\n                        };\n                        top += window.innerHeight;\n                        left += window.innerWidth;\n                        bottom = elTop + targetEl.offsetHeight - el.offsetHeight - elDistance[_this6.directionAxis];\n                        right = elLeft + targetEl.offsetWidth - el.offsetWidth - elDistance[_this6.directionAxis];\n                        middle = {\n                            x: (right - left) / 2 + left,\n                            y: (bottom - top) / 2 + top\n                        };\n                    }\n                    if (repeat == \"false\") {\n                        repeat = false;\n                    } else if (repeat != undefined) {\n                        repeat = true;\n                    } else {\n                        repeat = _this6.repeat;\n                    }\n                    var relativeOffset = [\n                        0,\n                        0\n                    ];\n                    if (offset) {\n                        if (_this6.direction === \"horizontal\") {\n                            for(var i = 0; i < offset.length; i++){\n                                if (typeof offset[i] == \"string\") {\n                                    if (offset[i].includes(\"%\")) {\n                                        relativeOffset[i] = parseInt(offset[i].replace(\"%\", \"\") * _this6.windowWidth / 100);\n                                    } else {\n                                        relativeOffset[i] = parseInt(offset[i]);\n                                    }\n                                } else {\n                                    relativeOffset[i] = offset[i];\n                                }\n                            }\n                            left = left + relativeOffset[0];\n                            right = right - relativeOffset[1];\n                        } else {\n                            for(var i = 0; i < offset.length; i++){\n                                if (typeof offset[i] == \"string\") {\n                                    if (offset[i].includes(\"%\")) {\n                                        relativeOffset[i] = parseInt(offset[i].replace(\"%\", \"\") * _this6.windowHeight / 100);\n                                    } else {\n                                        relativeOffset[i] = parseInt(offset[i]);\n                                    }\n                                } else {\n                                    relativeOffset[i] = offset[i];\n                                }\n                            }\n                            top = top + relativeOffset[0];\n                            bottom = bottom - relativeOffset[1];\n                        }\n                    }\n                    var mappedEl = {\n                        el: el,\n                        id: id,\n                        \"class\": cl,\n                        section: section,\n                        top: top,\n                        middle: middle,\n                        bottom: bottom,\n                        left: left,\n                        right: right,\n                        offset: offset,\n                        progress: 0,\n                        repeat: repeat,\n                        inView: false,\n                        call: call,\n                        speed: speed,\n                        delay: delay,\n                        position: position,\n                        target: targetEl,\n                        direction: direction,\n                        sticky: sticky\n                    };\n                    _this6.els[id] = mappedEl;\n                    if (el.classList.contains(cl)) {\n                        _this6.setInView(_this6.els[id], id);\n                    }\n                    if (speed !== false || sticky) {\n                        _this6.parallaxElements[id] = mappedEl;\n                    }\n                }); // });\n            }\n        },\n        {\n            key: \"addSections\",\n            value: function addSections() {\n                var _this7 = this;\n                this.sections = {};\n                var sections = this.el.querySelectorAll(\"[data-\".concat(this.name, \"-section]\"));\n                if (sections.length === 0) {\n                    sections = [\n                        this.el\n                    ];\n                }\n                sections.forEach(function(section, index) {\n                    var id = typeof section.dataset[_this7.name + \"Id\"] === \"string\" ? section.dataset[_this7.name + \"Id\"] : \"section\" + index;\n                    var sectionBCR = section.getBoundingClientRect();\n                    var offset = {\n                        x: sectionBCR.left - window.innerWidth * 1.5 - getTranslate(section).x,\n                        y: sectionBCR.top - window.innerHeight * 1.5 - getTranslate(section).y\n                    };\n                    var limit = {\n                        x: offset.x + sectionBCR.width + window.innerWidth * 2,\n                        y: offset.y + sectionBCR.height + window.innerHeight * 2\n                    };\n                    var persistent = typeof section.dataset[_this7.name + \"Persistent\"] === \"string\";\n                    section.setAttribute(\"data-scroll-section-id\", id);\n                    var mappedSection = {\n                        el: section,\n                        offset: offset,\n                        limit: limit,\n                        inView: false,\n                        persistent: persistent,\n                        id: id\n                    };\n                    _this7.sections[id] = mappedSection;\n                });\n            }\n        },\n        {\n            key: \"transform\",\n            value: function transform(element, x, y, delay) {\n                var transform;\n                if (!delay) {\n                    transform = \"matrix3d(1,0,0.00,0,0.00,1,0.00,0,0,0,1,0,\".concat(x, \",\").concat(y, \",0,1)\");\n                } else {\n                    var start = getTranslate(element);\n                    var lerpX = lerp(start.x, x, delay);\n                    var lerpY = lerp(start.y, y, delay);\n                    transform = \"matrix3d(1,0,0.00,0,0.00,1,0.00,0,0,0,1,0,\".concat(lerpX, \",\").concat(lerpY, \",0,1)\");\n                }\n                element.style.webkitTransform = transform;\n                element.style.msTransform = transform;\n                element.style.transform = transform;\n            }\n        },\n        {\n            key: \"transformElements\",\n            value: function transformElements(isForced) {\n                var _this8 = this;\n                var setAllElements = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n                var scrollRight = this.instance.scroll.x + this.windowWidth;\n                var scrollBottom = this.instance.scroll.y + this.windowHeight;\n                var scrollMiddle = {\n                    x: this.instance.scroll.x + this.windowMiddle.x,\n                    y: this.instance.scroll.y + this.windowMiddle.y\n                };\n                Object.entries(this.parallaxElements).forEach(function(_ref5) {\n                    var _ref6 = _slicedToArray(_ref5, 2), i = _ref6[0], current = _ref6[1];\n                    var transformDistance = false;\n                    if (isForced) {\n                        transformDistance = 0;\n                    }\n                    if (current.inView || setAllElements) {\n                        switch(current.position){\n                            case \"top\":\n                                transformDistance = _this8.instance.scroll[_this8.directionAxis] * -current.speed;\n                                break;\n                            case \"elementTop\":\n                                transformDistance = (scrollBottom - current.top) * -current.speed;\n                                break;\n                            case \"bottom\":\n                                transformDistance = (_this8.instance.limit[_this8.directionAxis] - scrollBottom + _this8.windowHeight) * current.speed;\n                                break;\n                            case \"left\":\n                                transformDistance = _this8.instance.scroll[_this8.directionAxis] * -current.speed;\n                                break;\n                            case \"elementLeft\":\n                                transformDistance = (scrollRight - current.left) * -current.speed;\n                                break;\n                            case \"right\":\n                                transformDistance = (_this8.instance.limit[_this8.directionAxis] - scrollRight + _this8.windowHeight) * current.speed;\n                                break;\n                            default:\n                                transformDistance = (scrollMiddle[_this8.directionAxis] - current.middle[_this8.directionAxis]) * -current.speed;\n                                break;\n                        }\n                    }\n                    if (current.sticky) {\n                        if (current.inView) {\n                            if (_this8.direction === \"horizontal\") {\n                                transformDistance = _this8.instance.scroll.x - current.left + window.innerWidth;\n                            } else {\n                                transformDistance = _this8.instance.scroll.y - current.top + window.innerHeight;\n                            }\n                        } else {\n                            if (_this8.direction === \"horizontal\") {\n                                if (_this8.instance.scroll.x < current.left - window.innerWidth && _this8.instance.scroll.x < current.left - window.innerWidth / 2) {\n                                    transformDistance = 0;\n                                } else if (_this8.instance.scroll.x > current.right && _this8.instance.scroll.x > current.right + 100) {\n                                    transformDistance = current.right - current.left + window.innerWidth;\n                                } else {\n                                    transformDistance = false;\n                                }\n                            } else {\n                                if (_this8.instance.scroll.y < current.top - window.innerHeight && _this8.instance.scroll.y < current.top - window.innerHeight / 2) {\n                                    transformDistance = 0;\n                                } else if (_this8.instance.scroll.y > current.bottom && _this8.instance.scroll.y > current.bottom + 100) {\n                                    transformDistance = current.bottom - current.top + window.innerHeight;\n                                } else {\n                                    transformDistance = false;\n                                }\n                            }\n                        }\n                    }\n                    if (transformDistance !== false) {\n                        if (current.direction === \"horizontal\" || _this8.direction === \"horizontal\" && current.direction !== \"vertical\") {\n                            _this8.transform(current.el, transformDistance, 0, isForced ? false : current.delay);\n                        } else {\n                            _this8.transform(current.el, 0, transformDistance, isForced ? false : current.delay);\n                        }\n                    }\n                });\n            }\n        },\n        {\n            key: \"scrollTo\",\n            value: function scrollTo(target) {\n                var _this9 = this;\n                var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n                // Parse options\n                var offset = parseInt(options.offset) || 0; // An offset to apply on top of given `target` or `sourceElem`'s target\n                var duration = !isNaN(parseInt(options.duration)) ? parseInt(options.duration) : 1000; // Duration of the scroll animation in milliseconds\n                var easing = options.easing || [\n                    0.25,\n                    0.0,\n                    0.35,\n                    1.0\n                ]; // An array of 4 floats between 0 and 1 defining the bezier curve for the animation's easing. See http://greweb.me/bezier-easing-editor/example/\n                var disableLerp = options.disableLerp ? true : false; // Lerp effect won't be applied if set to true\n                var callback = options.callback ? options.callback : false; // function called when scrollTo completes (note that it won't wait for lerp to stabilize)\n                easing = src$1.apply(void 0, _toConsumableArray(easing));\n                if (typeof target === \"string\") {\n                    // Selector or boundaries\n                    if (target === \"top\") {\n                        target = 0;\n                    } else if (target === \"bottom\") {\n                        target = this.instance.limit.y;\n                    } else if (target === \"left\") {\n                        target = 0;\n                    } else if (target === \"right\") {\n                        target = this.instance.limit.x;\n                    } else {\n                        target = document.querySelector(target); // If the query fails, abort\n                        if (!target) {\n                            return;\n                        }\n                    }\n                } else if (typeof target === \"number\") {\n                    // Absolute coordinate\n                    target = parseInt(target);\n                } else if (target && target.tagName) ;\n                else {\n                    console.warn(\"`target` parameter is not valid\");\n                    return;\n                } // We have a target that is not a coordinate yet, get it\n                if (typeof target !== \"number\") {\n                    // Verify the given target belongs to this scroll scope\n                    var targetInScope = getParents(target).includes(this.el);\n                    if (!targetInScope) {\n                        // If the target isn't inside our main element, abort any action\n                        return;\n                    } // Get target offset from top\n                    var targetBCR = target.getBoundingClientRect();\n                    var offsetTop = targetBCR.top;\n                    var offsetLeft = targetBCR.left; // Try and find the target's parent section\n                    var targetParents = getParents(target);\n                    var parentSection = targetParents.find(function(candidate) {\n                        return Object.entries(_this9.sections) // Get sections associative array as a regular array\n                        .map(function(_ref7) {\n                            var _ref8 = _slicedToArray(_ref7, 2), key = _ref8[0], section = _ref8[1];\n                            return section;\n                        }) // map to section only (we dont need the key here)\n                        .find(function(section) {\n                            return section.el == candidate;\n                        }); // finally find the section that matches the candidate\n                    });\n                    var parentSectionOffset = 0;\n                    if (parentSection) {\n                        parentSectionOffset = getTranslate(parentSection)[this.directionAxis]; // We got a parent section, store it's current offset to remove it later\n                    } else {\n                        // if no parent section is found we need to use instance scroll directly\n                        parentSectionOffset = -this.instance.scroll[this.directionAxis];\n                    } // Final value of scroll destination : offsetTop + (optional offset given in options) - (parent's section translate)\n                    if (this.direction === \"horizontal\") {\n                        offset = offsetLeft + offset - parentSectionOffset;\n                    } else {\n                        offset = offsetTop + offset - parentSectionOffset;\n                    }\n                } else {\n                    offset = target + offset;\n                } // Actual scrollto\n                // ==========================================================================\n                // Setup\n                var scrollStart = parseFloat(this.instance.delta[this.directionAxis]);\n                var scrollTarget = Math.max(0, Math.min(offset, this.instance.limit[this.directionAxis])); // Make sure our target is in the scroll boundaries\n                var scrollDiff = scrollTarget - scrollStart;\n                var render = function render(p) {\n                    if (disableLerp) {\n                        if (_this9.direction === \"horizontal\") {\n                            _this9.setScroll(scrollStart + scrollDiff * p, _this9.instance.delta.y);\n                        } else {\n                            _this9.setScroll(_this9.instance.delta.x, scrollStart + scrollDiff * p);\n                        }\n                    } else {\n                        _this9.instance.delta[_this9.directionAxis] = scrollStart + scrollDiff * p;\n                    }\n                }; // Prepare the scroll\n                this.animatingScroll = true; // This boolean allows to prevent `checkScroll()` from calling `stopScrolling` when the animation is slow (i.e. at the beginning of an EaseIn)\n                this.stopScrolling(); // Stop any movement, allows to kill any other `scrollTo` still happening\n                this.startScrolling(); // Restart the scroll\n                // Start the animation loop\n                var start = Date.now();\n                var loop = function loop() {\n                    var p = (Date.now() - start) / duration; // Animation progress\n                    if (p > 1) {\n                        // Animation ends\n                        render(1);\n                        _this9.animatingScroll = false;\n                        if (duration == 0) _this9.update();\n                        if (callback) callback();\n                    } else {\n                        _this9.scrollToRaf = requestAnimationFrame(loop);\n                        render(easing(p));\n                    }\n                };\n                loop();\n            }\n        },\n        {\n            key: \"update\",\n            value: function update() {\n                this.setScrollLimit();\n                this.addSections();\n                this.addElements();\n                this.detectElements();\n                this.updateScroll();\n                this.transformElements(true);\n                this.reinitScrollBar();\n                this.checkScroll(true);\n            }\n        },\n        {\n            key: \"startScroll\",\n            value: function startScroll() {\n                this.stop = false;\n            }\n        },\n        {\n            key: \"stopScroll\",\n            value: function stopScroll() {\n                this.stop = true;\n            }\n        },\n        {\n            key: \"setScroll\",\n            value: function setScroll(x, y) {\n                this.instance = _objectSpread2(_objectSpread2({}, this.instance), {}, {\n                    scroll: {\n                        x: x,\n                        y: y\n                    },\n                    delta: {\n                        x: x,\n                        y: y\n                    },\n                    speed: 0\n                });\n            }\n        },\n        {\n            key: \"destroy\",\n            value: function destroy() {\n                _get(_getPrototypeOf(_default.prototype), \"destroy\", this).call(this);\n                this.stopScrolling();\n                this.html.classList.remove(this.smoothClass);\n                this.vs.destroy();\n                this.destroyScrollBar();\n                window.removeEventListener(\"keydown\", this.checkKey, false);\n            }\n        }\n    ]);\n    return _default;\n}(_default);\nvar Smooth = /*#__PURE__*/ function() {\n    function Smooth() {\n        var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n        _classCallCheck(this, Smooth);\n        this.options = options; // Override default options with given ones\n        Object.assign(this, defaults, options);\n        this.smartphone = defaults.smartphone;\n        if (options.smartphone) Object.assign(this.smartphone, options.smartphone);\n        this.tablet = defaults.tablet;\n        if (options.tablet) Object.assign(this.tablet, options.tablet);\n        if (!this.smooth && this.direction == \"horizontal\") console.warn(\"\\uD83D\\uDEA8 `smooth:false` & `horizontal` direction are not yet compatible\");\n        if (!this.tablet.smooth && this.tablet.direction == \"horizontal\") console.warn(\"\\uD83D\\uDEA8 `smooth:false` & `horizontal` direction are not yet compatible (tablet)\");\n        if (!this.smartphone.smooth && this.smartphone.direction == \"horizontal\") console.warn(\"\\uD83D\\uDEA8 `smooth:false` & `horizontal` direction are not yet compatible (smartphone)\");\n        this.init();\n    }\n    _createClass(Smooth, [\n        {\n            key: \"init\",\n            value: function init() {\n                this.options.isMobile = /Android|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) || navigator.platform === \"MacIntel\" && navigator.maxTouchPoints > 1 || window.innerWidth < this.tablet.breakpoint;\n                this.options.isTablet = this.options.isMobile && window.innerWidth >= this.tablet.breakpoint;\n                if (this.smooth && !this.options.isMobile || this.tablet.smooth && this.options.isTablet || this.smartphone.smooth && this.options.isMobile && !this.options.isTablet) {\n                    this.scroll = new _default$2(this.options);\n                } else {\n                    this.scroll = new _default$1(this.options);\n                }\n                this.scroll.init();\n                if (window.location.hash) {\n                    // Get the hash without the '#' and find the matching element\n                    var id = window.location.hash.slice(1, window.location.hash.length);\n                    var target = document.getElementById(id); // If found, scroll to the element\n                    if (target) this.scroll.scrollTo(target);\n                }\n            }\n        },\n        {\n            key: \"update\",\n            value: function update() {\n                this.scroll.update();\n            }\n        },\n        {\n            key: \"start\",\n            value: function start() {\n                this.scroll.startScroll();\n            }\n        },\n        {\n            key: \"stop\",\n            value: function stop() {\n                this.scroll.stopScroll();\n            }\n        },\n        {\n            key: \"scrollTo\",\n            value: function scrollTo(target, options) {\n                this.scroll.scrollTo(target, options);\n            }\n        },\n        {\n            key: \"setScroll\",\n            value: function setScroll(x, y) {\n                this.scroll.setScroll(x, y);\n            }\n        },\n        {\n            key: \"on\",\n            value: function on(event, func) {\n                this.scroll.setEvents(event, func);\n            }\n        },\n        {\n            key: \"off\",\n            value: function off(event, func) {\n                this.scroll.unsetEvents(event, func);\n            }\n        },\n        {\n            key: \"destroy\",\n            value: function destroy() {\n                this.scroll.destroy();\n            }\n        }\n    ]);\n    return Smooth;\n}();\nvar Native = /*#__PURE__*/ function() {\n    function Native() {\n        var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n        _classCallCheck(this, Native);\n        this.options = options; // Override default options with given ones\n        Object.assign(this, defaults, options);\n        this.smartphone = defaults.smartphone;\n        if (options.smartphone) Object.assign(this.smartphone, options.smartphone);\n        this.tablet = defaults.tablet;\n        if (options.tablet) Object.assign(this.tablet, options.tablet);\n        this.init();\n    }\n    _createClass(Native, [\n        {\n            key: \"init\",\n            value: function init() {\n                this.scroll = new _default$1(this.options);\n                this.scroll.init();\n                if (window.location.hash) {\n                    // Get the hash without the '#' and find the matching element\n                    var id = window.location.hash.slice(1, window.location.hash.length);\n                    var target = document.getElementById(id); // If found, scroll to the element\n                    if (target) this.scroll.scrollTo(target);\n                }\n            }\n        },\n        {\n            key: \"update\",\n            value: function update() {\n                this.scroll.update();\n            }\n        },\n        {\n            key: \"start\",\n            value: function start() {\n                this.scroll.startScroll();\n            }\n        },\n        {\n            key: \"stop\",\n            value: function stop() {\n                this.scroll.stopScroll();\n            }\n        },\n        {\n            key: \"scrollTo\",\n            value: function scrollTo(target, options) {\n                this.scroll.scrollTo(target, options);\n            }\n        },\n        {\n            key: \"setScroll\",\n            value: function setScroll(x, y) {\n                this.scroll.setScroll(x, y);\n            }\n        },\n        {\n            key: \"on\",\n            value: function on(event, func) {\n                this.scroll.setEvents(event, func);\n            }\n        },\n        {\n            key: \"off\",\n            value: function off(event, func) {\n                this.scroll.unsetEvents(event, func);\n            }\n        },\n        {\n            key: \"destroy\",\n            value: function destroy() {\n                this.scroll.destroy();\n            }\n        }\n    ]);\n    return Native;\n}();\n/* harmony default export */ __webpack_exports__[\"default\"] = (Smooth);\n\nvar _c, _c1, _c2, _c3, _c4, _c5;\n$RefreshReg$(_c, \"E\");\n$RefreshReg$(_c1, \"VirtualScroll\");\n$RefreshReg$(_c2, \"A\");\n$RefreshReg$(_c3, \"B\");\n$RefreshReg$(_c4, \"C\");\n$RefreshReg$(_c5, \"LinearEasing\");\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9sb2NvbW90aXZlLXNjcm9sbC9kaXN0L2xvY29tb3RpdmUtc2Nyb2xsLmVzbS5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUFBLCtGQUErRixHQUMvRixTQUFTQSxnQkFBZ0JDLFFBQVEsRUFBRUMsV0FBVztJQUM1QyxJQUFJLENBQUVELENBQUFBLG9CQUFvQkMsV0FBVSxHQUFJO1FBQ3RDLE1BQU0sSUFBSUMsVUFBVTtJQUN0QjtBQUNGO0FBRUEsU0FBU0Msa0JBQWtCQyxNQUFNLEVBQUVDLEtBQUs7SUFDdEMsSUFBSyxJQUFJQyxJQUFJLEdBQUdBLElBQUlELE1BQU1FLE1BQU0sRUFBRUQsSUFBSztRQUNyQyxJQUFJRSxhQUFhSCxLQUFLLENBQUNDLEVBQUU7UUFDekJFLFdBQVdDLFVBQVUsR0FBR0QsV0FBV0MsVUFBVSxJQUFJO1FBQ2pERCxXQUFXRSxZQUFZLEdBQUc7UUFDMUIsSUFBSSxXQUFXRixZQUFZQSxXQUFXRyxRQUFRLEdBQUc7UUFDakRDLE9BQU9DLGNBQWMsQ0FBQ1QsUUFBUUksV0FBV00sR0FBRyxFQUFFTjtJQUNoRDtBQUNGO0FBRUEsU0FBU08sYUFBYWQsV0FBVyxFQUFFZSxVQUFVLEVBQUVDLFdBQVc7SUFDeEQsSUFBSUQsWUFBWWIsa0JBQWtCRixZQUFZaUIsU0FBUyxFQUFFRjtJQUN6RCxJQUFJQyxhQUFhZCxrQkFBa0JGLGFBQWFnQjtJQUNoRCxPQUFPaEI7QUFDVDtBQUVBLFNBQVNrQixnQkFBZ0JDLEdBQUcsRUFBRU4sR0FBRyxFQUFFTyxLQUFLO0lBQ3RDLElBQUlQLE9BQU9NLEtBQUs7UUFDZFIsT0FBT0MsY0FBYyxDQUFDTyxLQUFLTixLQUFLO1lBQzlCTyxPQUFPQTtZQUNQWixZQUFZO1lBQ1pDLGNBQWM7WUFDZEMsVUFBVTtRQUNaO0lBQ0YsT0FBTztRQUNMUyxHQUFHLENBQUNOLElBQUksR0FBR087SUFDYjtJQUVBLE9BQU9EO0FBQ1Q7QUFFQSxTQUFTRSxRQUFRQyxN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QUNEM0csS0FBSztZQUNMTyxPQUFPLFNBQVNvVyxHQUFHcEwsS0FBSyxFQUFFMEMsSUFBSTtnQkFDNUIsSUFBSSxDQUFDNUUsTUFBTSxDQUFDMkUsU0FBUyxDQUFDekMsT0FBTzBDO1lBQy9CO1FBQ0Y7UUFBRztZQUNEak8sS0FBSztZQUNMTyxPQUFPLFNBQVN3VyxJQUFJeEwsS0FBSyxFQUFFMEMsSUFBSTtnQkFDN0IsSUFBSSxDQUFDNUUsTUFBTSxDQUFDOEUsV0FBVyxDQUFDNUMsT0FBTzBDO1lBQ2pDO1FBQ0Y7UUFBRztZQUNEak8sS0FBSztZQUNMTyxPQUFPLFNBQVN1TztnQkFDZCxJQUFJLENBQUN6RixNQUFNLENBQUN5RixPQUFPO1lBQ3JCO1FBQ0Y7S0FBRTtJQUVGLE9BQU9nWjtBQUNUO0FBRUEsK0RBQWVILE1BQU1BLEVBQUM7QUFDSSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbG9jb21vdGl2ZS1zY3JvbGwvZGlzdC9sb2NvbW90aXZlLXNjcm9sbC5lc20uanM/MThiOCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiBsb2NvbW90aXZlLXNjcm9sbCB2NC4xLjMgfCBNSVQgTGljZW5zZSB8IGh0dHBzOi8vZ2l0aHViLmNvbS9sb2NvbW90aXZlbXRsL2xvY29tb3RpdmUtc2Nyb2xsICovXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7XG4gIGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldO1xuICAgIGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTtcbiAgICBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7XG4gICAgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7XG4gIH1cbn1cblxuZnVuY3Rpb24gX2NyZWF0ZUNsYXNzKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykge1xuICBpZiAocHJvdG9Qcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTtcbiAgaWYgKHN0YXRpY1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpO1xuICByZXR1cm4gQ29uc3RydWN0b3I7XG59XG5cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgdmFsdWUpIHtcbiAgaWYgKGtleSBpbiBvYmopIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHtcbiAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICB3cml0YWJsZTogdHJ1ZVxuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIG9ialtrZXldID0gdmFsdWU7XG4gIH1cblxuICByZXR1cm4gb2JqO1xufVxuXG5mdW5jdGlvbiBvd25LZXlzKG9iamVjdCwgZW51bWVyYWJsZU9ubHkpIHtcbiAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhvYmplY3QpO1xuXG4gIGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7XG4gICAgdmFyIHN5bWJvbHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKG9iamVjdCk7XG4gICAgaWYgKGVudW1lcmFibGVPbmx5KSBzeW1ib2xzID0gc3ltYm9scy5maWx0ZXIoZnVuY3Rpb24gKHN5bSkge1xuICAgICAgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqZWN0LCBzeW0pLmVudW1lcmFibGU7XG4gICAgfSk7XG4gICAga2V5cy5wdXNoLmFwcGx5KGtleXMsIHN5bWJvbHMpO1xuICB9XG5cbiAgcmV0dXJuIGtleXM7XG59XG5cbmZ1bmN0aW9uIF9vYmplY3RTcHJlYWQyKHRhcmdldCkge1xuICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV0gIT0gbnVsbCA/IGFyZ3VtZW50c1tpXSA6IHt9O1xuXG4gICAgaWYgKGkgJSAyKSB7XG4gICAgICBvd25LZXlzKE9iamVjdChzb3VyY2UpLCB0cnVlKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgX2RlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBzb3VyY2Vba2V5XSk7XG4gICAgICB9KTtcbiAgICB9IGVsc2UgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKSB7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKHNvdXJjZSkpO1xuICAgIH0gZWxzZSB7XG4gICAgICBvd25LZXlzKE9iamVjdChzb3VyY2UpKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHNvdXJjZSwga2V5KSk7XG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdGFyZ2V0O1xufVxuXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHtcbiAgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvblwiKTtcbiAgfVxuXG4gIHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwge1xuICAgIGNvbnN0cnVjdG9yOiB7XG4gICAgICB2YWx1ZTogc3ViQ2xhc3MsXG4gICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH1cbiAgfSk7XG4gIGlmIChzdXBlckNsYXNzKSBfc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpO1xufVxuXG5mdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2Yobykge1xuICBfZ2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3QuZ2V0UHJvdG90eXBlT2YgOiBmdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2Yobykge1xuICAgIHJldHVybiBvLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2Yobyk7XG4gIH07XG4gIHJldHVybiBfZ2V0UHJvdG90eXBlT2Yobyk7XG59XG5cbmZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7XG4gIF9zZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fCBmdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkge1xuICAgIG8uX19wcm90b19fID0gcDtcbiAgICByZXR1cm4gbztcbiAgfTtcblxuICByZXR1cm4gX3NldFByb3RvdHlwZU9mKG8sIHApO1xufVxuXG5mdW5jdGlvbiBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCkge1xuICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwidW5kZWZpbmVkXCIgfHwgIVJlZmxlY3QuY29uc3RydWN0KSByZXR1cm4gZmFsc2U7XG4gIGlmIChSZWZsZWN0LmNvbnN0cnVjdC5zaGFtKSByZXR1cm4gZmFsc2U7XG4gIGlmICh0eXBlb2YgUHJveHkgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIHRydWU7XG5cbiAgdHJ5IHtcbiAgICBEYXRlLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKFJlZmxlY3QuY29uc3RydWN0KERhdGUsIFtdLCBmdW5jdGlvbiAoKSB7fSkpO1xuICAgIHJldHVybiB0cnVlO1xuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59XG5cbmZ1bmN0aW9uIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZikge1xuICBpZiAoc2VsZiA9PT0gdm9pZCAwKSB7XG4gICAgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpO1xuICB9XG5cbiAgcmV0dXJuIHNlbGY7XG59XG5cbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHtcbiAgaWYgKGNhbGwgJiYgKHR5cGVvZiBjYWxsID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpKSB7XG4gICAgcmV0dXJuIGNhbGw7XG4gIH1cblxuICByZXR1cm4gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKTtcbn1cblxuZnVuY3Rpb24gX2NyZWF0ZVN1cGVyKERlcml2ZWQpIHtcbiAgdmFyIGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QgPSBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCk7XG5cbiAgcmV0dXJuIGZ1bmN0aW9uIF9jcmVhdGVTdXBlckludGVybmFsKCkge1xuICAgIHZhciBTdXBlciA9IF9nZXRQcm90b3R5cGVPZihEZXJpdmVkKSxcbiAgICAgICAgcmVzdWx0O1xuXG4gICAgaWYgKGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QpIHtcbiAgICAgIHZhciBOZXdUYXJnZXQgPSBfZ2V0UHJvdG90eXBlT2YodGhpcykuY29uc3RydWN0b3I7XG5cbiAgICAgIHJlc3VsdCA9IFJlZmxlY3QuY29uc3RydWN0KFN1cGVyLCBhcmd1bWVudHMsIE5ld1RhcmdldCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlc3VsdCA9IFN1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIHJlc3VsdCk7XG4gIH07XG59XG5cbmZ1bmN0aW9uIF9zdXBlclByb3BCYXNlKG9iamVjdCwgcHJvcGVydHkpIHtcbiAgd2hpbGUgKCFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBwcm9wZXJ0eSkpIHtcbiAgICBvYmplY3QgPSBfZ2V0UHJvdG90eXBlT2Yob2JqZWN0KTtcbiAgICBpZiAob2JqZWN0ID09PSBudWxsKSBicmVhaztcbiAgfVxuXG4gIHJldHVybiBvYmplY3Q7XG59XG5cbmZ1bmN0aW9uIF9nZXQodGFyZ2V0LCBwcm9wZXJ0eSwgcmVjZWl2ZXIpIHtcbiAgaWYgKHR5cGVvZiBSZWZsZWN0ICE9PSBcInVuZGVmaW5lZFwiICYmIFJlZmxlY3QuZ2V0KSB7XG4gICAgX2dldCA9IFJlZmxlY3QuZ2V0O1xuICB9IGVsc2Uge1xuICAgIF9nZXQgPSBmdW5jdGlvbiBfZ2V0KHRhcmdldCwgcHJvcGVydHksIHJlY2VpdmVyKSB7XG4gICAgICB2YXIgYmFzZSA9IF9zdXBlclByb3BCYXNlKHRhcmdldCwgcHJvcGVydHkpO1xuXG4gICAgICBpZiAoIWJhc2UpIHJldHVybjtcbiAgICAgIHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihiYXNlLCBwcm9wZXJ0eSk7XG5cbiAgICAgIGlmIChkZXNjLmdldCkge1xuICAgICAgICByZXR1cm4gZGVzYy5nZXQuY2FsbChyZWNlaXZlcik7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBkZXNjLnZhbHVlO1xuICAgIH07XG4gIH1cblxuICByZXR1cm4gX2dldCh0YXJnZXQsIHByb3BlcnR5LCByZWNlaXZlciB8fCB0YXJnZXQpO1xufVxuXG5mdW5jdGlvbiBfc2xpY2VkVG9BcnJheShhcnIsIGkpIHtcbiAgcmV0dXJuIF9hcnJheVdpdGhIb2xlcyhhcnIpIHx8IF9pdGVyYWJsZVRvQXJyYXlMaW1pdChhcnIsIGkpIHx8IF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShhcnIsIGkpIHx8IF9ub25JdGVyYWJsZVJlc3QoKTtcbn1cblxuZnVuY3Rpb24gX3RvQ29uc3VtYWJsZUFycmF5KGFycikge1xuICByZXR1cm4gX2FycmF5V2l0aG91dEhvbGVzKGFycikgfHwgX2l0ZXJhYmxlVG9BcnJheShhcnIpIHx8IF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShhcnIpIHx8IF9ub25JdGVyYWJsZVNwcmVhZCgpO1xufVxuXG5mdW5jdGlvbiBfYXJyYXlXaXRob3V0SG9sZXMoYXJyKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KGFycikpIHJldHVybiBfYXJyYXlMaWtlVG9BcnJheShhcnIpO1xufVxuXG5mdW5jdGlvbiBfYXJyYXlXaXRoSG9sZXMoYXJyKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KGFycikpIHJldHVybiBhcnI7XG59XG5cbmZ1bmN0aW9uIF9pdGVyYWJsZVRvQXJyYXkoaXRlcikge1xuICBpZiAodHlwZW9mIFN5bWJvbCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBTeW1ib2wuaXRlcmF0b3IgaW4gT2JqZWN0KGl0ZXIpKSByZXR1cm4gQXJyYXkuZnJvbShpdGVyKTtcbn1cblxuZnVuY3Rpb24gX2l0ZXJhYmxlVG9BcnJheUxpbWl0KGFyciwgaSkge1xuICBpZiAodHlwZW9mIFN5bWJvbCA9PT0gXCJ1bmRlZmluZWRcIiB8fCAhKFN5bWJvbC5pdGVyYXRvciBpbiBPYmplY3QoYXJyKSkpIHJldHVybjtcbiAgdmFyIF9hcnIgPSBbXTtcbiAgdmFyIF9uID0gdHJ1ZTtcbiAgdmFyIF9kID0gZmFsc2U7XG4gIHZhciBfZSA9IHVuZGVmaW5lZDtcblxuICB0cnkge1xuICAgIGZvciAodmFyIF9pID0gYXJyW1N5bWJvbC5pdGVyYXRvcl0oKSwgX3M7ICEoX24gPSAoX3MgPSBfaS5uZXh0KCkpLmRvbmUpOyBfbiA9IHRydWUpIHtcbiAgICAgIF9hcnIucHVzaChfcy52YWx1ZSk7XG5cbiAgICAgIGlmIChpICYmIF9hcnIubGVuZ3RoID09PSBpKSBicmVhaztcbiAgICB9XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIF9kID0gdHJ1ZTtcbiAgICBfZSA9IGVycjtcbiAgfSBmaW5hbGx5IHtcbiAgICB0cnkge1xuICAgICAgaWYgKCFfbiAmJiBfaVtcInJldHVyblwiXSAhPSBudWxsKSBfaVtcInJldHVyblwiXSgpO1xuICAgIH0gZmluYWxseSB7XG4gICAgICBpZiAoX2QpIHRocm93IF9lO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBfYXJyO1xufVxuXG5mdW5jdGlvbiBfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkobywgbWluTGVuKSB7XG4gIGlmICghbykgcmV0dXJuO1xuICBpZiAodHlwZW9mIG8gPT09IFwic3RyaW5nXCIpIHJldHVybiBfYXJyYXlMaWtlVG9BcnJheShvLCBtaW5MZW4pO1xuICB2YXIgbiA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvKS5zbGljZSg4LCAtMSk7XG4gIGlmIChuID09PSBcIk9iamVjdFwiICYmIG8uY29uc3RydWN0b3IpIG4gPSBvLmNvbnN0cnVjdG9yLm5hbWU7XG4gIGlmIChuID09PSBcIk1hcFwiIHx8IG4gPT09IFwiU2V0XCIpIHJldHVybiBBcnJheS5mcm9tKG8pO1xuICBpZiAobiA9PT0gXCJBcmd1bWVudHNcIiB8fCAvXig/OlVpfEkpbnQoPzo4fDE2fDMyKSg/OkNsYW1wZWQpP0FycmF5JC8udGVzdChuKSkgcmV0dXJuIF9hcnJheUxpa2VUb0FycmF5KG8sIG1pbkxlbik7XG59XG5cbmZ1bmN0aW9uIF9hcnJheUxpa2VUb0FycmF5KGFyciwgbGVuKSB7XG4gIGlmIChsZW4gPT0gbnVsbCB8fCBsZW4gPiBhcnIubGVuZ3RoKSBsZW4gPSBhcnIubGVuZ3RoO1xuXG4gIGZvciAodmFyIGkgPSAwLCBhcnIyID0gbmV3IEFycmF5KGxlbik7IGkgPCBsZW47IGkrKykgYXJyMltpXSA9IGFycltpXTtcblxuICByZXR1cm4gYXJyMjtcbn1cblxuZnVuY3Rpb24gX25vbkl0ZXJhYmxlU3ByZWFkKCkge1xuICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBhdHRlbXB0IHRvIHNwcmVhZCBub24taXRlcmFibGUgaW5zdGFuY2UuXFxuSW4gb3JkZXIgdG8gYmUgaXRlcmFibGUsIG5vbi1hcnJheSBvYmplY3RzIG11c3QgaGF2ZSBhIFtTeW1ib2wuaXRlcmF0b3JdKCkgbWV0aG9kLlwiKTtcbn1cblxuZnVuY3Rpb24gX25vbkl0ZXJhYmxlUmVzdCgpIHtcbiAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXR0ZW1wdCB0byBkZXN0cnVjdHVyZSBub24taXRlcmFibGUgaW5zdGFuY2UuXFxuSW4gb3JkZXIgdG8gYmUgaXRlcmFibGUsIG5vbi1hcnJheSBvYmplY3RzIG11c3QgaGF2ZSBhIFtTeW1ib2wuaXRlcmF0b3JdKCkgbWV0aG9kLlwiKTtcbn1cblxudmFyIGRlZmF1bHRzID0ge1xuICBlbDogZG9jdW1lbnQsXG4gIG5hbWU6ICdzY3JvbGwnLFxuICBvZmZzZXQ6IFswLCAwXSxcbiAgcmVwZWF0OiBmYWxzZSxcbiAgc21vb3RoOiBmYWxzZSxcbiAgaW5pdFBvc2l0aW9uOiB7XG4gICAgeDogMCxcbiAgICB5OiAwXG4gIH0sXG4gIGRpcmVjdGlvbjogJ3ZlcnRpY2FsJyxcbiAgZ2VzdHVyZURpcmVjdGlvbjogJ3ZlcnRpY2FsJyxcbiAgcmVsb2FkT25Db250ZXh0Q2hhbmdlOiBmYWxzZSxcbiAgbGVycDogMC4xLFxuICBcImNsYXNzXCI6ICdpcy1pbnZpZXcnLFxuICBzY3JvbGxiYXJDb250YWluZXI6IGZhbHNlLFxuICBzY3JvbGxiYXJDbGFzczogJ2Mtc2Nyb2xsYmFyJyxcbiAgc2Nyb2xsaW5nQ2xhc3M6ICdoYXMtc2Nyb2xsLXNjcm9sbGluZycsXG4gIGRyYWdnaW5nQ2xhc3M6ICdoYXMtc2Nyb2xsLWRyYWdnaW5nJyxcbiAgc21vb3RoQ2xhc3M6ICdoYXMtc2Nyb2xsLXNtb290aCcsXG4gIGluaXRDbGFzczogJ2hhcy1zY3JvbGwtaW5pdCcsXG4gIGdldFNwZWVkOiBmYWxzZSxcbiAgZ2V0RGlyZWN0aW9uOiBmYWxzZSxcbiAgc2Nyb2xsRnJvbUFueXdoZXJlOiBmYWxzZSxcbiAgbXVsdGlwbGllcjogMSxcbiAgZmlyZWZveE11bHRpcGxpZXI6IDUwLFxuICB0b3VjaE11bHRpcGxpZXI6IDIsXG4gIHJlc2V0TmF0aXZlU2Nyb2xsOiB0cnVlLFxuICB0YWJsZXQ6IHtcbiAgICBzbW9vdGg6IGZhbHNlLFxuICAgIGRpcmVjdGlvbjogJ3ZlcnRpY2FsJyxcbiAgICBnZXN0dXJlRGlyZWN0aW9uOiAndmVydGljYWwnLFxuICAgIGJyZWFrcG9pbnQ6IDEwMjRcbiAgfSxcbiAgc21hcnRwaG9uZToge1xuICAgIHNtb290aDogZmFsc2UsXG4gICAgZGlyZWN0aW9uOiAndmVydGljYWwnLFxuICAgIGdlc3R1cmVEaXJlY3Rpb246ICd2ZXJ0aWNhbCdcbiAgfVxufTtcblxudmFyIF9kZWZhdWx0ID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gX2RlZmF1bHQoKSB7XG4gICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHt9O1xuXG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIF9kZWZhdWx0KTtcblxuICAgIE9iamVjdC5hc3NpZ24odGhpcywgZGVmYXVsdHMsIG9wdGlvbnMpO1xuICAgIHRoaXMuc21hcnRwaG9uZSA9IGRlZmF1bHRzLnNtYXJ0cGhvbmU7XG4gICAgaWYgKG9wdGlvbnMuc21hcnRwaG9uZSkgT2JqZWN0LmFzc2lnbih0aGlzLnNtYXJ0cGhvbmUsIG9wdGlvbnMuc21hcnRwaG9uZSk7XG4gICAgdGhpcy50YWJsZXQgPSBkZWZhdWx0cy50YWJsZXQ7XG4gICAgaWYgKG9wdGlvbnMudGFibGV0KSBPYmplY3QuYXNzaWduKHRoaXMudGFibGV0LCBvcHRpb25zLnRhYmxldCk7XG4gICAgdGhpcy5uYW1lc3BhY2UgPSAnbG9jb21vdGl2ZSc7XG4gICAgdGhpcy5odG1sID0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50O1xuICAgIHRoaXMud2luZG93SGVpZ2h0ID0gd2luZG93LmlubmVySGVpZ2h0O1xuICAgIHRoaXMud2luZG93V2lkdGggPSB3aW5kb3cuaW5uZXJXaWR0aDtcbiAgICB0aGlzLndpbmRvd01pZGRsZSA9IHtcbiAgICAgIHg6IHRoaXMud2luZG93V2lkdGggLyAyLFxuICAgICAgeTogdGhpcy53aW5kb3dIZWlnaHQgLyAyXG4gICAgfTtcbiAgICB0aGlzLmVscyA9IHt9O1xuICAgIHRoaXMuY3VycmVudEVsZW1lbnRzID0ge307XG4gICAgdGhpcy5saXN0ZW5lcnMgPSB7fTtcbiAgICB0aGlzLmhhc1Njcm9sbFRpY2tpbmcgPSBmYWxzZTtcbiAgICB0aGlzLmhhc0NhbGxFdmVudFNldCA9IGZhbHNlO1xuICAgIHRoaXMuY2hlY2tTY3JvbGwgPSB0aGlzLmNoZWNrU2Nyb2xsLmJpbmQodGhpcyk7XG4gICAgdGhpcy5jaGVja1Jlc2l6ZSA9IHRoaXMuY2hlY2tSZXNpemUuYmluZCh0aGlzKTtcbiAgICB0aGlzLmNoZWNrRXZlbnQgPSB0aGlzLmNoZWNrRXZlbnQuYmluZCh0aGlzKTtcbiAgICB0aGlzLmluc3RhbmNlID0ge1xuICAgICAgc2Nyb2xsOiB7XG4gICAgICAgIHg6IDAsXG4gICAgICAgIHk6IDBcbiAgICAgIH0sXG4gICAgICBsaW1pdDoge1xuICAgICAgICB4OiB0aGlzLmh0bWwub2Zmc2V0V2lkdGgsXG4gICAgICAgIHk6IHRoaXMuaHRtbC5vZmZzZXRIZWlnaHRcbiAgICAgIH0sXG4gICAgICBjdXJyZW50RWxlbWVudHM6IHRoaXMuY3VycmVudEVsZW1lbnRzXG4gICAgfTtcblxuICAgIGlmICh0aGlzLmlzTW9iaWxlKSB7XG4gICAgICBpZiAodGhpcy5pc1RhYmxldCkge1xuICAgICAgICB0aGlzLmNvbnRleHQgPSAndGFibGV0JztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuY29udGV4dCA9ICdzbWFydHBob25lJztcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5jb250ZXh0ID0gJ2Rlc2t0b3AnO1xuICAgIH1cblxuICAgIGlmICh0aGlzLmlzTW9iaWxlKSB0aGlzLmRpcmVjdGlvbiA9IHRoaXNbdGhpcy5jb250ZXh0XS5kaXJlY3Rpb247XG5cbiAgICBpZiAodGhpcy5kaXJlY3Rpb24gPT09ICdob3Jpem9udGFsJykge1xuICAgICAgdGhpcy5kaXJlY3Rpb25BeGlzID0gJ3gnO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmRpcmVjdGlvbkF4aXMgPSAneSc7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuZ2V0RGlyZWN0aW9uKSB7XG4gICAgICB0aGlzLmluc3RhbmNlLmRpcmVjdGlvbiA9IG51bGw7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuZ2V0RGlyZWN0aW9uKSB7XG4gICAgICB0aGlzLmluc3RhbmNlLnNwZWVkID0gMDtcbiAgICB9XG5cbiAgICB0aGlzLmh0bWwuY2xhc3NMaXN0LmFkZCh0aGlzLmluaXRDbGFzcyk7XG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIHRoaXMuY2hlY2tSZXNpemUsIGZhbHNlKTtcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhfZGVmYXVsdCwgW3tcbiAgICBrZXk6IFwiaW5pdFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBpbml0KCkge1xuICAgICAgdGhpcy5pbml0RXZlbnRzKCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImNoZWNrU2Nyb2xsXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNoZWNrU2Nyb2xsKCkge1xuICAgICAgdGhpcy5kaXNwYXRjaFNjcm9sbCgpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJjaGVja1Jlc2l6ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjaGVja1Jlc2l6ZSgpIHtcbiAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICAgIGlmICghdGhpcy5yZXNpemVUaWNrKSB7XG4gICAgICAgIHRoaXMucmVzaXplVGljayA9IHRydWU7XG4gICAgICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZShmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgX3RoaXMucmVzaXplKCk7XG5cbiAgICAgICAgICBfdGhpcy5yZXNpemVUaWNrID0gZmFsc2U7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJyZXNpemVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVzaXplKCkge31cbiAgfSwge1xuICAgIGtleTogXCJjaGVja0NvbnRleHRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY2hlY2tDb250ZXh0KCkge1xuICAgICAgaWYgKCF0aGlzLnJlbG9hZE9uQ29udGV4dENoYW5nZSkgcmV0dXJuO1xuICAgICAgdGhpcy5pc01vYmlsZSA9IC9BbmRyb2lkfGlQaG9uZXxpUGFkfGlQb2R8QmxhY2tCZXJyeXxJRU1vYmlsZXxPcGVyYSBNaW5pL2kudGVzdChuYXZpZ2F0b3IudXNlckFnZW50KSB8fCBuYXZpZ2F0b3IucGxhdGZvcm0gPT09ICdNYWNJbnRlbCcgJiYgbmF2aWdhdG9yLm1heFRvdWNoUG9pbnRzID4gMSB8fCB0aGlzLndpbmRvd1dpZHRoIDwgdGhpcy50YWJsZXQuYnJlYWtwb2ludDtcbiAgICAgIHRoaXMuaXNUYWJsZXQgPSB0aGlzLmlzTW9iaWxlICYmIHRoaXMud2luZG93V2lkdGggPj0gdGhpcy50YWJsZXQuYnJlYWtwb2ludDtcbiAgICAgIHZhciBvbGRDb250ZXh0ID0gdGhpcy5jb250ZXh0O1xuXG4gICAgICBpZiAodGhpcy5pc01vYmlsZSkge1xuICAgICAgICBpZiAodGhpcy5pc1RhYmxldCkge1xuICAgICAgICAgIHRoaXMuY29udGV4dCA9ICd0YWJsZXQnO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuY29udGV4dCA9ICdzbWFydHBob25lJztcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5jb250ZXh0ID0gJ2Rlc2t0b3AnO1xuICAgICAgfVxuXG4gICAgICBpZiAob2xkQ29udGV4dCAhPSB0aGlzLmNvbnRleHQpIHtcbiAgICAgICAgdmFyIG9sZFNtb290aCA9IG9sZENvbnRleHQgPT0gJ2Rlc2t0b3AnID8gdGhpcy5zbW9vdGggOiB0aGlzW29sZENvbnRleHRdLnNtb290aDtcbiAgICAgICAgdmFyIG5ld1Ntb290aCA9IHRoaXMuY29udGV4dCA9PSAnZGVza3RvcCcgPyB0aGlzLnNtb290aCA6IHRoaXNbdGhpcy5jb250ZXh0XS5zbW9vdGg7XG4gICAgICAgIGlmIChvbGRTbW9vdGggIT0gbmV3U21vb3RoKSB3aW5kb3cubG9jYXRpb24ucmVsb2FkKCk7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImluaXRFdmVudHNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaW5pdEV2ZW50cygpIHtcbiAgICAgIHZhciBfdGhpczIgPSB0aGlzO1xuXG4gICAgICB0aGlzLnNjcm9sbFRvRWxzID0gdGhpcy5lbC5xdWVyeVNlbGVjdG9yQWxsKFwiW2RhdGEtXCIuY29uY2F0KHRoaXMubmFtZSwgXCItdG9dXCIpKTtcbiAgICAgIHRoaXMuc2V0U2Nyb2xsVG8gPSB0aGlzLnNldFNjcm9sbFRvLmJpbmQodGhpcyk7XG4gICAgICB0aGlzLnNjcm9sbFRvRWxzLmZvckVhY2goZnVuY3Rpb24gKGVsKSB7XG4gICAgICAgIGVsLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgX3RoaXMyLnNldFNjcm9sbFRvLCBmYWxzZSk7XG4gICAgICB9KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwic2V0U2Nyb2xsVG9cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0U2Nyb2xsVG8oZXZlbnQpIHtcbiAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICB0aGlzLnNjcm9sbFRvKGV2ZW50LmN1cnJlbnRUYXJnZXQuZ2V0QXR0cmlidXRlKFwiZGF0YS1cIi5jb25jYXQodGhpcy5uYW1lLCBcIi1ocmVmXCIpKSB8fCBldmVudC5jdXJyZW50VGFyZ2V0LmdldEF0dHJpYnV0ZSgnaHJlZicpLCB7XG4gICAgICAgIG9mZnNldDogZXZlbnQuY3VycmVudFRhcmdldC5nZXRBdHRyaWJ1dGUoXCJkYXRhLVwiLmNvbmNhdCh0aGlzLm5hbWUsIFwiLW9mZnNldFwiKSlcbiAgICAgIH0pO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJhZGRFbGVtZW50c1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhZGRFbGVtZW50cygpIHt9XG4gIH0sIHtcbiAgICBrZXk6IFwiZGV0ZWN0RWxlbWVudHNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZGV0ZWN0RWxlbWVudHMoaGFzQ2FsbEV2ZW50U2V0KSB7XG4gICAgICB2YXIgX3RoaXMzID0gdGhpcztcblxuICAgICAgdmFyIHNjcm9sbFRvcCA9IHRoaXMuaW5zdGFuY2Uuc2Nyb2xsLnk7XG4gICAgICB2YXIgc2Nyb2xsQm90dG9tID0gc2Nyb2xsVG9wICsgdGhpcy53aW5kb3dIZWlnaHQ7XG4gICAgICB2YXIgc2Nyb2xsTGVmdCA9IHRoaXMuaW5zdGFuY2Uuc2Nyb2xsLng7XG4gICAgICB2YXIgc2Nyb2xsUmlnaHQgPSBzY3JvbGxMZWZ0ICsgdGhpcy53aW5kb3dXaWR0aDtcbiAgICAgIE9iamVjdC5lbnRyaWVzKHRoaXMuZWxzKS5mb3JFYWNoKGZ1bmN0aW9uIChfcmVmKSB7XG4gICAgICAgIHZhciBfcmVmMiA9IF9zbGljZWRUb0FycmF5KF9yZWYsIDIpLFxuICAgICAgICAgICAgaSA9IF9yZWYyWzBdLFxuICAgICAgICAgICAgZWwgPSBfcmVmMlsxXTtcblxuICAgICAgICBpZiAoZWwgJiYgKCFlbC5pblZpZXcgfHwgaGFzQ2FsbEV2ZW50U2V0KSkge1xuICAgICAgICAgIGlmIChfdGhpczMuZGlyZWN0aW9uID09PSAnaG9yaXpvbnRhbCcpIHtcbiAgICAgICAgICAgIGlmIChzY3JvbGxSaWdodCA+PSBlbC5sZWZ0ICYmIHNjcm9sbExlZnQgPCBlbC5yaWdodCkge1xuICAgICAgICAgICAgICBfdGhpczMuc2V0SW5WaWV3KGVsLCBpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKHNjcm9sbEJvdHRvbSA+PSBlbC50b3AgJiYgc2Nyb2xsVG9wIDwgZWwuYm90dG9tKSB7XG4gICAgICAgICAgICAgIF90aGlzMy5zZXRJblZpZXcoZWwsIGkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChlbCAmJiBlbC5pblZpZXcpIHtcbiAgICAgICAgICBpZiAoX3RoaXMzLmRpcmVjdGlvbiA9PT0gJ2hvcml6b250YWwnKSB7XG4gICAgICAgICAgICB2YXIgd2lkdGggPSBlbC5yaWdodCAtIGVsLmxlZnQ7XG4gICAgICAgICAgICBlbC5wcm9ncmVzcyA9IChfdGhpczMuaW5zdGFuY2Uuc2Nyb2xsLnggLSAoZWwubGVmdCAtIF90aGlzMy53aW5kb3dXaWR0aCkpIC8gKHdpZHRoICsgX3RoaXMzLndpbmRvd1dpZHRoKTtcblxuICAgICAgICAgICAgaWYgKHNjcm9sbFJpZ2h0IDwgZWwubGVmdCB8fCBzY3JvbGxMZWZ0ID4gZWwucmlnaHQpIHtcbiAgICAgICAgICAgICAgX3RoaXMzLnNldE91dE9mVmlldyhlbCwgaSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhciBoZWlnaHQgPSBlbC5ib3R0b20gLSBlbC50b3A7XG4gICAgICAgICAgICBlbC5wcm9ncmVzcyA9IChfdGhpczMuaW5zdGFuY2Uuc2Nyb2xsLnkgLSAoZWwudG9wIC0gX3RoaXMzLndpbmRvd0hlaWdodCkpIC8gKGhlaWdodCArIF90aGlzMy53aW5kb3dIZWlnaHQpO1xuXG4gICAgICAgICAgICBpZiAoc2Nyb2xsQm90dG9tIDwgZWwudG9wIHx8IHNjcm9sbFRvcCA+IGVsLmJvdHRvbSkge1xuICAgICAgICAgICAgICBfdGhpczMuc2V0T3V0T2ZWaWV3KGVsLCBpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pOyAvLyB0aGlzLmVscyA9IHRoaXMuZWxzLmZpbHRlcigoY3VycmVudCwgaSkgPT4ge1xuICAgICAgLy8gICAgIHJldHVybiBjdXJyZW50ICE9PSBudWxsO1xuICAgICAgLy8gfSk7XG5cbiAgICAgIHRoaXMuaGFzU2Nyb2xsVGlja2luZyA9IGZhbHNlO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJzZXRJblZpZXdcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0SW5WaWV3KGN1cnJlbnQsIGkpIHtcbiAgICAgIHRoaXMuZWxzW2ldLmluVmlldyA9IHRydWU7XG4gICAgICBjdXJyZW50LmVsLmNsYXNzTGlzdC5hZGQoY3VycmVudFtcImNsYXNzXCJdKTtcbiAgICAgIHRoaXMuY3VycmVudEVsZW1lbnRzW2ldID0gY3VycmVudDtcblxuICAgICAgaWYgKGN1cnJlbnQuY2FsbCAmJiB0aGlzLmhhc0NhbGxFdmVudFNldCkge1xuICAgICAgICB0aGlzLmRpc3BhdGNoQ2FsbChjdXJyZW50LCAnZW50ZXInKTtcblxuICAgICAgICBpZiAoIWN1cnJlbnQucmVwZWF0KSB7XG4gICAgICAgICAgdGhpcy5lbHNbaV0uY2FsbCA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9IC8vIGlmICghY3VycmVudC5yZXBlYXQgJiYgIWN1cnJlbnQuc3BlZWQgJiYgIWN1cnJlbnQuc3RpY2t5KSB7XG4gICAgICAvLyAgICAgaWYgKCFjdXJyZW50LmNhbGwgfHwgY3VycmVudC5jYWxsICYmIHRoaXMuaGFzQ2FsbEV2ZW50U2V0KSB7XG4gICAgICAvLyAgICAgICAgdGhpcy5lbHNbaV0gPSBudWxsXG4gICAgICAvLyAgICAgfVxuICAgICAgLy8gfVxuXG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInNldE91dE9mVmlld1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRPdXRPZlZpZXcoY3VycmVudCwgaSkge1xuICAgICAgdmFyIF90aGlzNCA9IHRoaXM7XG5cbiAgICAgIC8vIGlmIChjdXJyZW50LnJlcGVhdCB8fCBjdXJyZW50LnNwZWVkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHRoaXMuZWxzW2ldLmluVmlldyA9IGZhbHNlOyAvLyB9XG5cbiAgICAgIE9iamVjdC5rZXlzKHRoaXMuY3VycmVudEVsZW1lbnRzKS5mb3JFYWNoKGZ1bmN0aW9uIChlbCkge1xuICAgICAgICBlbCA9PT0gaSAmJiBkZWxldGUgX3RoaXM0LmN1cnJlbnRFbGVtZW50c1tlbF07XG4gICAgICB9KTtcblxuICAgICAgaWYgKGN1cnJlbnQuY2FsbCAmJiB0aGlzLmhhc0NhbGxFdmVudFNldCkge1xuICAgICAgICB0aGlzLmRpc3BhdGNoQ2FsbChjdXJyZW50LCAnZXhpdCcpO1xuICAgICAgfVxuXG4gICAgICBpZiAoY3VycmVudC5yZXBlYXQpIHtcbiAgICAgICAgY3VycmVudC5lbC5jbGFzc0xpc3QucmVtb3ZlKGN1cnJlbnRbXCJjbGFzc1wiXSk7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImRpc3BhdGNoQ2FsbFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkaXNwYXRjaENhbGwoY3VycmVudCwgd2F5KSB7XG4gICAgICB0aGlzLmNhbGxXYXkgPSB3YXk7XG4gICAgICB0aGlzLmNhbGxWYWx1ZSA9IGN1cnJlbnQuY2FsbC5zcGxpdCgnLCcpLm1hcChmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgICByZXR1cm4gaXRlbS50cmltKCk7XG4gICAgICB9KTtcbiAgICAgIHRoaXMuY2FsbE9iaiA9IGN1cnJlbnQ7XG4gICAgICBpZiAodGhpcy5jYWxsVmFsdWUubGVuZ3RoID09IDEpIHRoaXMuY2FsbFZhbHVlID0gdGhpcy5jYWxsVmFsdWVbMF07XG4gICAgICB2YXIgY2FsbEV2ZW50ID0gbmV3IEV2ZW50KHRoaXMubmFtZXNwYWNlICsgJ2NhbGwnKTtcbiAgICAgIHRoaXMuZWwuZGlzcGF0Y2hFdmVudChjYWxsRXZlbnQpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJkaXNwYXRjaFNjcm9sbFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkaXNwYXRjaFNjcm9sbCgpIHtcbiAgICAgIHZhciBzY3JvbGxFdmVudCA9IG5ldyBFdmVudCh0aGlzLm5hbWVzcGFjZSArICdzY3JvbGwnKTtcbiAgICAgIHRoaXMuZWwuZGlzcGF0Y2hFdmVudChzY3JvbGxFdmVudCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInNldEV2ZW50c1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRFdmVudHMoZXZlbnQsIGZ1bmMpIHtcbiAgICAgIGlmICghdGhpcy5saXN0ZW5lcnNbZXZlbnRdKSB7XG4gICAgICAgIHRoaXMubGlzdGVuZXJzW2V2ZW50XSA9IFtdO1xuICAgICAgfVxuXG4gICAgICB2YXIgbGlzdCA9IHRoaXMubGlzdGVuZXJzW2V2ZW50XTtcbiAgICAgIGxpc3QucHVzaChmdW5jKTtcblxuICAgICAgaWYgKGxpc3QubGVuZ3RoID09PSAxKSB7XG4gICAgICAgIHRoaXMuZWwuYWRkRXZlbnRMaXN0ZW5lcih0aGlzLm5hbWVzcGFjZSArIGV2ZW50LCB0aGlzLmNoZWNrRXZlbnQsIGZhbHNlKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGV2ZW50ID09PSAnY2FsbCcpIHtcbiAgICAgICAgdGhpcy5oYXNDYWxsRXZlbnRTZXQgPSB0cnVlO1xuICAgICAgICB0aGlzLmRldGVjdEVsZW1lbnRzKHRydWUpO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJ1bnNldEV2ZW50c1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB1bnNldEV2ZW50cyhldmVudCwgZnVuYykge1xuICAgICAgaWYgKCF0aGlzLmxpc3RlbmVyc1tldmVudF0pIHJldHVybjtcbiAgICAgIHZhciBsaXN0ID0gdGhpcy5saXN0ZW5lcnNbZXZlbnRdO1xuICAgICAgdmFyIGluZGV4ID0gbGlzdC5pbmRleE9mKGZ1bmMpO1xuICAgICAgaWYgKGluZGV4IDwgMCkgcmV0dXJuO1xuICAgICAgbGlzdC5zcGxpY2UoaW5kZXgsIDEpO1xuXG4gICAgICBpZiAobGlzdC5pbmRleCA9PT0gMCkge1xuICAgICAgICB0aGlzLmVsLnJlbW92ZUV2ZW50TGlzdGVuZXIodGhpcy5uYW1lc3BhY2UgKyBldmVudCwgdGhpcy5jaGVja0V2ZW50LCBmYWxzZSk7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImNoZWNrRXZlbnRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY2hlY2tFdmVudChldmVudCkge1xuICAgICAgdmFyIF90aGlzNSA9IHRoaXM7XG5cbiAgICAgIHZhciBuYW1lID0gZXZlbnQudHlwZS5yZXBsYWNlKHRoaXMubmFtZXNwYWNlLCAnJyk7XG4gICAgICB2YXIgbGlzdCA9IHRoaXMubGlzdGVuZXJzW25hbWVdO1xuICAgICAgaWYgKCFsaXN0IHx8IGxpc3QubGVuZ3RoID09PSAwKSByZXR1cm47XG4gICAgICBsaXN0LmZvckVhY2goZnVuY3Rpb24gKGZ1bmMpIHtcbiAgICAgICAgc3dpdGNoIChuYW1lKSB7XG4gICAgICAgICAgY2FzZSAnc2Nyb2xsJzpcbiAgICAgICAgICAgIHJldHVybiBmdW5jKF90aGlzNS5pbnN0YW5jZSk7XG5cbiAgICAgICAgICBjYXNlICdjYWxsJzpcbiAgICAgICAgICAgIHJldHVybiBmdW5jKF90aGlzNS5jYWxsVmFsdWUsIF90aGlzNS5jYWxsV2F5LCBfdGhpczUuY2FsbE9iaik7XG5cbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgcmV0dXJuIGZ1bmMoKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInN0YXJ0U2Nyb2xsXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHN0YXJ0U2Nyb2xsKCkge31cbiAgfSwge1xuICAgIGtleTogXCJzdG9wU2Nyb2xsXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHN0b3BTY3JvbGwoKSB7fVxuICB9LCB7XG4gICAga2V5OiBcInNldFNjcm9sbFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRTY3JvbGwoeCwgeSkge1xuICAgICAgdGhpcy5pbnN0YW5jZS5zY3JvbGwgPSB7XG4gICAgICAgIHg6IDAsXG4gICAgICAgIHk6IDBcbiAgICAgIH07XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImRlc3Ryb3lcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZGVzdHJveSgpIHtcbiAgICAgIHZhciBfdGhpczYgPSB0aGlzO1xuXG4gICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcigncmVzaXplJywgdGhpcy5jaGVja1Jlc2l6ZSwgZmFsc2UpO1xuICAgICAgT2JqZWN0LmtleXModGhpcy5saXN0ZW5lcnMpLmZvckVhY2goZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIF90aGlzNi5lbC5yZW1vdmVFdmVudExpc3RlbmVyKF90aGlzNi5uYW1lc3BhY2UgKyBldmVudCwgX3RoaXM2LmNoZWNrRXZlbnQsIGZhbHNlKTtcbiAgICAgIH0pO1xuICAgICAgdGhpcy5saXN0ZW5lcnMgPSB7fTtcbiAgICAgIHRoaXMuc2Nyb2xsVG9FbHMuZm9yRWFjaChmdW5jdGlvbiAoZWwpIHtcbiAgICAgICAgZWwucmVtb3ZlRXZlbnRMaXN0ZW5lcignY2xpY2snLCBfdGhpczYuc2V0U2Nyb2xsVG8sIGZhbHNlKTtcbiAgICAgIH0pO1xuICAgICAgdGhpcy5odG1sLmNsYXNzTGlzdC5yZW1vdmUodGhpcy5pbml0Q2xhc3MpO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBfZGVmYXVsdDtcbn0oKTtcblxudmFyIGNvbW1vbmpzR2xvYmFsID0gdHlwZW9mIGdsb2JhbFRoaXMgIT09ICd1bmRlZmluZWQnID8gZ2xvYmFsVGhpcyA6IHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnID8gd2luZG93IDogdHlwZW9mIGdsb2JhbCAhPT0gJ3VuZGVmaW5lZCcgPyBnbG9iYWwgOiB0eXBlb2Ygc2VsZiAhPT0gJ3VuZGVmaW5lZCcgPyBzZWxmIDoge307XG5cbmZ1bmN0aW9uIGNyZWF0ZUNvbW1vbmpzTW9kdWxlKGZuLCBtb2R1bGUpIHtcblx0cmV0dXJuIG1vZHVsZSA9IHsgZXhwb3J0czoge30gfSwgZm4obW9kdWxlLCBtb2R1bGUuZXhwb3J0cyksIG1vZHVsZS5leHBvcnRzO1xufVxuXG52YXIgc21vb3Roc2Nyb2xsID0gY3JlYXRlQ29tbW9uanNNb2R1bGUoZnVuY3Rpb24gKG1vZHVsZSwgZXhwb3J0cykge1xuLyogc21vb3Roc2Nyb2xsIHYwLjQuNCAtIDIwMTkgLSBEdXN0YW4gS2FzdGVuLCBKZXJlbWlhcyBNZW5pY2hlbGxpIC0gTUlUIExpY2Vuc2UgKi9cbihmdW5jdGlvbiAoKSB7XG5cbiAgLy8gcG9seWZpbGxcbiAgZnVuY3Rpb24gcG9seWZpbGwoKSB7XG4gICAgLy8gYWxpYXNlc1xuICAgIHZhciB3ID0gd2luZG93O1xuICAgIHZhciBkID0gZG9jdW1lbnQ7XG5cbiAgICAvLyByZXR1cm4gaWYgc2Nyb2xsIGJlaGF2aW9yIGlzIHN1cHBvcnRlZCBhbmQgcG9seWZpbGwgaXMgbm90IGZvcmNlZFxuICAgIGlmIChcbiAgICAgICdzY3JvbGxCZWhhdmlvcicgaW4gZC5kb2N1bWVudEVsZW1lbnQuc3R5bGUgJiZcbiAgICAgIHcuX19mb3JjZVNtb290aFNjcm9sbFBvbHlmaWxsX18gIT09IHRydWVcbiAgICApIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBnbG9iYWxzXG4gICAgdmFyIEVsZW1lbnQgPSB3LkhUTUxFbGVtZW50IHx8IHcuRWxlbWVudDtcbiAgICB2YXIgU0NST0xMX1RJTUUgPSA0Njg7XG5cbiAgICAvLyBvYmplY3QgZ2F0aGVyaW5nIG9yaWdpbmFsIHNjcm9sbCBtZXRob2RzXG4gICAgdmFyIG9yaWdpbmFsID0ge1xuICAgICAgc2Nyb2xsOiB3LnNjcm9sbCB8fCB3LnNjcm9sbFRvLFxuICAgICAgc2Nyb2xsQnk6IHcuc2Nyb2xsQnksXG4gICAgICBlbGVtZW50U2Nyb2xsOiBFbGVtZW50LnByb3RvdHlwZS5zY3JvbGwgfHwgc2Nyb2xsRWxlbWVudCxcbiAgICAgIHNjcm9sbEludG9WaWV3OiBFbGVtZW50LnByb3RvdHlwZS5zY3JvbGxJbnRvVmlld1xuICAgIH07XG5cbiAgICAvLyBkZWZpbmUgdGltaW5nIG1ldGhvZFxuICAgIHZhciBub3cgPVxuICAgICAgdy5wZXJmb3JtYW5jZSAmJiB3LnBlcmZvcm1hbmNlLm5vd1xuICAgICAgICA/IHcucGVyZm9ybWFuY2Uubm93LmJpbmQody5wZXJmb3JtYW5jZSlcbiAgICAgICAgOiBEYXRlLm5vdztcblxuICAgIC8qKlxuICAgICAqIGluZGljYXRlcyBpZiBhIHRoZSBjdXJyZW50IGJyb3dzZXIgaXMgbWFkZSBieSBNaWNyb3NvZnRcbiAgICAgKiBAbWV0aG9kIGlzTWljcm9zb2Z0QnJvd3NlclxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB1c2VyQWdlbnRcbiAgICAgKiBAcmV0dXJucyB7Qm9vbGVhbn1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc01pY3Jvc29mdEJyb3dzZXIodXNlckFnZW50KSB7XG4gICAgICB2YXIgdXNlckFnZW50UGF0dGVybnMgPSBbJ01TSUUgJywgJ1RyaWRlbnQvJywgJ0VkZ2UvJ107XG5cbiAgICAgIHJldHVybiBuZXcgUmVnRXhwKHVzZXJBZ2VudFBhdHRlcm5zLmpvaW4oJ3wnKSkudGVzdCh1c2VyQWdlbnQpO1xuICAgIH1cblxuICAgIC8qXG4gICAgICogSUUgaGFzIHJvdW5kaW5nIGJ1ZyByb3VuZGluZyBkb3duIGNsaWVudEhlaWdodCBhbmQgY2xpZW50V2lkdGggYW5kXG4gICAgICogcm91bmRpbmcgdXAgc2Nyb2xsSGVpZ2h0IGFuZCBzY3JvbGxXaWR0aCBjYXVzaW5nIGZhbHNlIHBvc2l0aXZlc1xuICAgICAqIG9uIGhhc1Njcm9sbGFibGVTcGFjZVxuICAgICAqL1xuICAgIHZhciBST1VORElOR19UT0xFUkFOQ0UgPSBpc01pY3Jvc29mdEJyb3dzZXIody5uYXZpZ2F0b3IudXNlckFnZW50KSA/IDEgOiAwO1xuXG4gICAgLyoqXG4gICAgICogY2hhbmdlcyBzY3JvbGwgcG9zaXRpb24gaW5zaWRlIGFuIGVsZW1lbnRcbiAgICAgKiBAbWV0aG9kIHNjcm9sbEVsZW1lbnRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0geFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB5XG4gICAgICogQHJldHVybnMge3VuZGVmaW5lZH1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzY3JvbGxFbGVtZW50KHgsIHkpIHtcbiAgICAgIHRoaXMuc2Nyb2xsTGVmdCA9IHg7XG4gICAgICB0aGlzLnNjcm9sbFRvcCA9IHk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogcmV0dXJucyByZXN1bHQgb2YgYXBwbHlpbmcgZWFzZSBtYXRoIGZ1bmN0aW9uIHRvIGEgbnVtYmVyXG4gICAgICogQG1ldGhvZCBlYXNlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGtcbiAgICAgKiBAcmV0dXJucyB7TnVtYmVyfVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGVhc2Uoaykge1xuICAgICAgcmV0dXJuIDAuNSAqICgxIC0gTWF0aC5jb3MoTWF0aC5QSSAqIGspKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBpbmRpY2F0ZXMgaWYgYSBzbW9vdGggYmVoYXZpb3Igc2hvdWxkIGJlIGFwcGxpZWRcbiAgICAgKiBAbWV0aG9kIHNob3VsZEJhaWxPdXRcbiAgICAgKiBAcGFyYW0ge051bWJlcnxPYmplY3R9IGZpcnN0QXJnXG4gICAgICogQHJldHVybnMge0Jvb2xlYW59XG4gICAgICovXG4gICAgZnVuY3Rpb24gc2hvdWxkQmFpbE91dChmaXJzdEFyZykge1xuICAgICAgaWYgKFxuICAgICAgICBmaXJzdEFyZyA9PT0gbnVsbCB8fFxuICAgICAgICB0eXBlb2YgZmlyc3RBcmcgIT09ICdvYmplY3QnIHx8XG4gICAgICAgIGZpcnN0QXJnLmJlaGF2aW9yID09PSB1bmRlZmluZWQgfHxcbiAgICAgICAgZmlyc3RBcmcuYmVoYXZpb3IgPT09ICdhdXRvJyB8fFxuICAgICAgICBmaXJzdEFyZy5iZWhhdmlvciA9PT0gJ2luc3RhbnQnXG4gICAgICApIHtcbiAgICAgICAgLy8gZmlyc3QgYXJndW1lbnQgaXMgbm90IGFuIG9iamVjdC9udWxsXG4gICAgICAgIC8vIG9yIGJlaGF2aW9yIGlzIGF1dG8sIGluc3RhbnQgb3IgdW5kZWZpbmVkXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuXG4gICAgICBpZiAodHlwZW9mIGZpcnN0QXJnID09PSAnb2JqZWN0JyAmJiBmaXJzdEFyZy5iZWhhdmlvciA9PT0gJ3Ntb290aCcpIHtcbiAgICAgICAgLy8gZmlyc3QgYXJndW1lbnQgaXMgYW4gb2JqZWN0IGFuZCBiZWhhdmlvciBpcyBzbW9vdGhcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuXG4gICAgICAvLyB0aHJvdyBlcnJvciB3aGVuIGJlaGF2aW9yIGlzIG5vdCBzdXBwb3J0ZWRcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICAgICdiZWhhdmlvciBtZW1iZXIgb2YgU2Nyb2xsT3B0aW9ucyAnICtcbiAgICAgICAgICBmaXJzdEFyZy5iZWhhdmlvciArXG4gICAgICAgICAgJyBpcyBub3QgYSB2YWxpZCB2YWx1ZSBmb3IgZW51bWVyYXRpb24gU2Nyb2xsQmVoYXZpb3IuJ1xuICAgICAgKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBpbmRpY2F0ZXMgaWYgYW4gZWxlbWVudCBoYXMgc2Nyb2xsYWJsZSBzcGFjZSBpbiB0aGUgcHJvdmlkZWQgYXhpc1xuICAgICAqIEBtZXRob2QgaGFzU2Nyb2xsYWJsZVNwYWNlXG4gICAgICogQHBhcmFtIHtOb2RlfSBlbFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBheGlzXG4gICAgICogQHJldHVybnMge0Jvb2xlYW59XG4gICAgICovXG4gICAgZnVuY3Rpb24gaGFzU2Nyb2xsYWJsZVNwYWNlKGVsLCBheGlzKSB7XG4gICAgICBpZiAoYXhpcyA9PT0gJ1knKSB7XG4gICAgICAgIHJldHVybiBlbC5jbGllbnRIZWlnaHQgKyBST1VORElOR19UT0xFUkFOQ0UgPCBlbC5zY3JvbGxIZWlnaHQ7XG4gICAgICB9XG5cbiAgICAgIGlmIChheGlzID09PSAnWCcpIHtcbiAgICAgICAgcmV0dXJuIGVsLmNsaWVudFdpZHRoICsgUk9VTkRJTkdfVE9MRVJBTkNFIDwgZWwuc2Nyb2xsV2lkdGg7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogaW5kaWNhdGVzIGlmIGFuIGVsZW1lbnQgaGFzIGEgc2Nyb2xsYWJsZSBvdmVyZmxvdyBwcm9wZXJ0eSBpbiB0aGUgYXhpc1xuICAgICAqIEBtZXRob2QgY2FuT3ZlcmZsb3dcbiAgICAgKiBAcGFyYW0ge05vZGV9IGVsXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGF4aXNcbiAgICAgKiBAcmV0dXJucyB7Qm9vbGVhbn1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjYW5PdmVyZmxvdyhlbCwgYXhpcykge1xuICAgICAgdmFyIG92ZXJmbG93VmFsdWUgPSB3LmdldENvbXB1dGVkU3R5bGUoZWwsIG51bGwpWydvdmVyZmxvdycgKyBheGlzXTtcblxuICAgICAgcmV0dXJuIG92ZXJmbG93VmFsdWUgPT09ICdhdXRvJyB8fCBvdmVyZmxvd1ZhbHVlID09PSAnc2Nyb2xsJztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBpbmRpY2F0ZXMgaWYgYW4gZWxlbWVudCBjYW4gYmUgc2Nyb2xsZWQgaW4gZWl0aGVyIGF4aXNcbiAgICAgKiBAbWV0aG9kIGlzU2Nyb2xsYWJsZVxuICAgICAqIEBwYXJhbSB7Tm9kZX0gZWxcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gYXhpc1xuICAgICAqIEByZXR1cm5zIHtCb29sZWFufVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzU2Nyb2xsYWJsZShlbCkge1xuICAgICAgdmFyIGlzU2Nyb2xsYWJsZVkgPSBoYXNTY3JvbGxhYmxlU3BhY2UoZWwsICdZJykgJiYgY2FuT3ZlcmZsb3coZWwsICdZJyk7XG4gICAgICB2YXIgaXNTY3JvbGxhYmxlWCA9IGhhc1Njcm9sbGFibGVTcGFjZShlbCwgJ1gnKSAmJiBjYW5PdmVyZmxvdyhlbCwgJ1gnKTtcblxuICAgICAgcmV0dXJuIGlzU2Nyb2xsYWJsZVkgfHwgaXNTY3JvbGxhYmxlWDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBmaW5kcyBzY3JvbGxhYmxlIHBhcmVudCBvZiBhbiBlbGVtZW50XG4gICAgICogQG1ldGhvZCBmaW5kU2Nyb2xsYWJsZVBhcmVudFxuICAgICAqIEBwYXJhbSB7Tm9kZX0gZWxcbiAgICAgKiBAcmV0dXJucyB7Tm9kZX0gZWxcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBmaW5kU2Nyb2xsYWJsZVBhcmVudChlbCkge1xuICAgICAgd2hpbGUgKGVsICE9PSBkLmJvZHkgJiYgaXNTY3JvbGxhYmxlKGVsKSA9PT0gZmFsc2UpIHtcbiAgICAgICAgZWwgPSBlbC5wYXJlbnROb2RlIHx8IGVsLmhvc3Q7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBlbDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBzZWxmIGludm9rZWQgZnVuY3Rpb24gdGhhdCwgZ2l2ZW4gYSBjb250ZXh0LCBzdGVwcyB0aHJvdWdoIHNjcm9sbGluZ1xuICAgICAqIEBtZXRob2Qgc3RlcFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjb250ZXh0XG4gICAgICogQHJldHVybnMge3VuZGVmaW5lZH1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzdGVwKGNvbnRleHQpIHtcbiAgICAgIHZhciB0aW1lID0gbm93KCk7XG4gICAgICB2YXIgdmFsdWU7XG4gICAgICB2YXIgY3VycmVudFg7XG4gICAgICB2YXIgY3VycmVudFk7XG4gICAgICB2YXIgZWxhcHNlZCA9ICh0aW1lIC0gY29udGV4dC5zdGFydFRpbWUpIC8gU0NST0xMX1RJTUU7XG5cbiAgICAgIC8vIGF2b2lkIGVsYXBzZWQgdGltZXMgaGlnaGVyIHRoYW4gb25lXG4gICAgICBlbGFwc2VkID0gZWxhcHNlZCA+IDEgPyAxIDogZWxhcHNlZDtcblxuICAgICAgLy8gYXBwbHkgZWFzaW5nIHRvIGVsYXBzZWQgdGltZVxuICAgICAgdmFsdWUgPSBlYXNlKGVsYXBzZWQpO1xuXG4gICAgICBjdXJyZW50WCA9IGNvbnRleHQuc3RhcnRYICsgKGNvbnRleHQueCAtIGNvbnRleHQuc3RhcnRYKSAqIHZhbHVlO1xuICAgICAgY3VycmVudFkgPSBjb250ZXh0LnN0YXJ0WSArIChjb250ZXh0LnkgLSBjb250ZXh0LnN0YXJ0WSkgKiB2YWx1ZTtcblxuICAgICAgY29udGV4dC5tZXRob2QuY2FsbChjb250ZXh0LnNjcm9sbGFibGUsIGN1cnJlbnRYLCBjdXJyZW50WSk7XG5cbiAgICAgIC8vIHNjcm9sbCBtb3JlIGlmIHdlIGhhdmUgbm90IHJlYWNoZWQgb3VyIGRlc3RpbmF0aW9uXG4gICAgICBpZiAoY3VycmVudFggIT09IGNvbnRleHQueCB8fCBjdXJyZW50WSAhPT0gY29udGV4dC55KSB7XG4gICAgICAgIHcucmVxdWVzdEFuaW1hdGlvbkZyYW1lKHN0ZXAuYmluZCh3LCBjb250ZXh0KSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogc2Nyb2xscyB3aW5kb3cgb3IgZWxlbWVudCB3aXRoIGEgc21vb3RoIGJlaGF2aW9yXG4gICAgICogQG1ldGhvZCBzbW9vdGhTY3JvbGxcbiAgICAgKiBAcGFyYW0ge09iamVjdHxOb2RlfSBlbFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB4XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHlcbiAgICAgKiBAcmV0dXJucyB7dW5kZWZpbmVkfVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHNtb290aFNjcm9sbChlbCwgeCwgeSkge1xuICAgICAgdmFyIHNjcm9sbGFibGU7XG4gICAgICB2YXIgc3RhcnRYO1xuICAgICAgdmFyIHN0YXJ0WTtcbiAgICAgIHZhciBtZXRob2Q7XG4gICAgICB2YXIgc3RhcnRUaW1lID0gbm93KCk7XG5cbiAgICAgIC8vIGRlZmluZSBzY3JvbGwgY29udGV4dFxuICAgICAgaWYgKGVsID09PSBkLmJvZHkpIHtcbiAgICAgICAgc2Nyb2xsYWJsZSA9IHc7XG4gICAgICAgIHN0YXJ0WCA9IHcuc2Nyb2xsWCB8fCB3LnBhZ2VYT2Zmc2V0O1xuICAgICAgICBzdGFydFkgPSB3LnNjcm9sbFkgfHwgdy5wYWdlWU9mZnNldDtcbiAgICAgICAgbWV0aG9kID0gb3JpZ2luYWwuc2Nyb2xsO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc2Nyb2xsYWJsZSA9IGVsO1xuICAgICAgICBzdGFydFggPSBlbC5zY3JvbGxMZWZ0O1xuICAgICAgICBzdGFydFkgPSBlbC5zY3JvbGxUb3A7XG4gICAgICAgIG1ldGhvZCA9IHNjcm9sbEVsZW1lbnQ7XG4gICAgICB9XG5cbiAgICAgIC8vIHNjcm9sbCBsb29waW5nIG92ZXIgYSBmcmFtZVxuICAgICAgc3RlcCh7XG4gICAgICAgIHNjcm9sbGFibGU6IHNjcm9sbGFibGUsXG4gICAgICAgIG1ldGhvZDogbWV0aG9kLFxuICAgICAgICBzdGFydFRpbWU6IHN0YXJ0VGltZSxcbiAgICAgICAgc3RhcnRYOiBzdGFydFgsXG4gICAgICAgIHN0YXJ0WTogc3RhcnRZLFxuICAgICAgICB4OiB4LFxuICAgICAgICB5OiB5XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAvLyBPUklHSU5BTCBNRVRIT0RTIE9WRVJSSURFU1xuICAgIC8vIHcuc2Nyb2xsIGFuZCB3LnNjcm9sbFRvXG4gICAgdy5zY3JvbGwgPSB3LnNjcm9sbFRvID0gZnVuY3Rpb24oKSB7XG4gICAgICAvLyBhdm9pZCBhY3Rpb24gd2hlbiBubyBhcmd1bWVudHMgYXJlIHBhc3NlZFxuICAgICAgaWYgKGFyZ3VtZW50c1swXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgLy8gYXZvaWQgc21vb3RoIGJlaGF2aW9yIGlmIG5vdCByZXF1aXJlZFxuICAgICAgaWYgKHNob3VsZEJhaWxPdXQoYXJndW1lbnRzWzBdKSA9PT0gdHJ1ZSkge1xuICAgICAgICBvcmlnaW5hbC5zY3JvbGwuY2FsbChcbiAgICAgICAgICB3LFxuICAgICAgICAgIGFyZ3VtZW50c1swXS5sZWZ0ICE9PSB1bmRlZmluZWRcbiAgICAgICAgICAgID8gYXJndW1lbnRzWzBdLmxlZnRcbiAgICAgICAgICAgIDogdHlwZW9mIGFyZ3VtZW50c1swXSAhPT0gJ29iamVjdCdcbiAgICAgICAgICAgICAgPyBhcmd1bWVudHNbMF1cbiAgICAgICAgICAgICAgOiB3LnNjcm9sbFggfHwgdy5wYWdlWE9mZnNldCxcbiAgICAgICAgICAvLyB1c2UgdG9wIHByb3AsIHNlY29uZCBhcmd1bWVudCBpZiBwcmVzZW50IG9yIGZhbGxiYWNrIHRvIHNjcm9sbFlcbiAgICAgICAgICBhcmd1bWVudHNbMF0udG9wICE9PSB1bmRlZmluZWRcbiAgICAgICAgICAgID8gYXJndW1lbnRzWzBdLnRvcFxuICAgICAgICAgICAgOiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZFxuICAgICAgICAgICAgICA/IGFyZ3VtZW50c1sxXVxuICAgICAgICAgICAgICA6IHcuc2Nyb2xsWSB8fCB3LnBhZ2VZT2Zmc2V0XG4gICAgICAgICk7XG5cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICAvLyBMRVQgVEhFIFNNT09USE5FU1MgQkVHSU4hXG4gICAgICBzbW9vdGhTY3JvbGwuY2FsbChcbiAgICAgICAgdyxcbiAgICAgICAgZC5ib2R5LFxuICAgICAgICBhcmd1bWVudHNbMF0ubGVmdCAhPT0gdW5kZWZpbmVkXG4gICAgICAgICAgPyB+fmFyZ3VtZW50c1swXS5sZWZ0XG4gICAgICAgICAgOiB3LnNjcm9sbFggfHwgdy5wYWdlWE9mZnNldCxcbiAgICAgICAgYXJndW1lbnRzWzBdLnRvcCAhPT0gdW5kZWZpbmVkXG4gICAgICAgICAgPyB+fmFyZ3VtZW50c1swXS50b3BcbiAgICAgICAgICA6IHcuc2Nyb2xsWSB8fCB3LnBhZ2VZT2Zmc2V0XG4gICAgICApO1xuICAgIH07XG5cbiAgICAvLyB3LnNjcm9sbEJ5XG4gICAgdy5zY3JvbGxCeSA9IGZ1bmN0aW9uKCkge1xuICAgICAgLy8gYXZvaWQgYWN0aW9uIHdoZW4gbm8gYXJndW1lbnRzIGFyZSBwYXNzZWRcbiAgICAgIGlmIChhcmd1bWVudHNbMF0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIC8vIGF2b2lkIHNtb290aCBiZWhhdmlvciBpZiBub3QgcmVxdWlyZWRcbiAgICAgIGlmIChzaG91bGRCYWlsT3V0KGFyZ3VtZW50c1swXSkpIHtcbiAgICAgICAgb3JpZ2luYWwuc2Nyb2xsQnkuY2FsbChcbiAgICAgICAgICB3LFxuICAgICAgICAgIGFyZ3VtZW50c1swXS5sZWZ0ICE9PSB1bmRlZmluZWRcbiAgICAgICAgICAgID8gYXJndW1lbnRzWzBdLmxlZnRcbiAgICAgICAgICAgIDogdHlwZW9mIGFyZ3VtZW50c1swXSAhPT0gJ29iamVjdCcgPyBhcmd1bWVudHNbMF0gOiAwLFxuICAgICAgICAgIGFyZ3VtZW50c1swXS50b3AgIT09IHVuZGVmaW5lZFxuICAgICAgICAgICAgPyBhcmd1bWVudHNbMF0udG9wXG4gICAgICAgICAgICA6IGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogMFxuICAgICAgICApO1xuXG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgLy8gTEVUIFRIRSBTTU9PVEhORVNTIEJFR0lOIVxuICAgICAgc21vb3RoU2Nyb2xsLmNhbGwoXG4gICAgICAgIHcsXG4gICAgICAgIGQuYm9keSxcbiAgICAgICAgfn5hcmd1bWVudHNbMF0ubGVmdCArICh3LnNjcm9sbFggfHwgdy5wYWdlWE9mZnNldCksXG4gICAgICAgIH5+YXJndW1lbnRzWzBdLnRvcCArICh3LnNjcm9sbFkgfHwgdy5wYWdlWU9mZnNldClcbiAgICAgICk7XG4gICAgfTtcblxuICAgIC8vIEVsZW1lbnQucHJvdG90eXBlLnNjcm9sbCBhbmQgRWxlbWVudC5wcm90b3R5cGUuc2Nyb2xsVG9cbiAgICBFbGVtZW50LnByb3RvdHlwZS5zY3JvbGwgPSBFbGVtZW50LnByb3RvdHlwZS5zY3JvbGxUbyA9IGZ1bmN0aW9uKCkge1xuICAgICAgLy8gYXZvaWQgYWN0aW9uIHdoZW4gbm8gYXJndW1lbnRzIGFyZSBwYXNzZWRcbiAgICAgIGlmIChhcmd1bWVudHNbMF0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIC8vIGF2b2lkIHNtb290aCBiZWhhdmlvciBpZiBub3QgcmVxdWlyZWRcbiAgICAgIGlmIChzaG91bGRCYWlsT3V0KGFyZ3VtZW50c1swXSkgPT09IHRydWUpIHtcbiAgICAgICAgLy8gaWYgb25lIG51bWJlciBpcyBwYXNzZWQsIHRocm93IGVycm9yIHRvIG1hdGNoIEZpcmVmb3ggaW1wbGVtZW50YXRpb25cbiAgICAgICAgaWYgKHR5cGVvZiBhcmd1bWVudHNbMF0gPT09ICdudW1iZXInICYmIGFyZ3VtZW50c1sxXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKCdWYWx1ZSBjb3VsZCBub3QgYmUgY29udmVydGVkJyk7XG4gICAgICAgIH1cblxuICAgICAgICBvcmlnaW5hbC5lbGVtZW50U2Nyb2xsLmNhbGwoXG4gICAgICAgICAgdGhpcyxcbiAgICAgICAgICAvLyB1c2UgbGVmdCBwcm9wLCBmaXJzdCBudW1iZXIgYXJndW1lbnQgb3IgZmFsbGJhY2sgdG8gc2Nyb2xsTGVmdFxuICAgICAgICAgIGFyZ3VtZW50c1swXS5sZWZ0ICE9PSB1bmRlZmluZWRcbiAgICAgICAgICAgID8gfn5hcmd1bWVudHNbMF0ubGVmdFxuICAgICAgICAgICAgOiB0eXBlb2YgYXJndW1lbnRzWzBdICE9PSAnb2JqZWN0JyA/IH5+YXJndW1lbnRzWzBdIDogdGhpcy5zY3JvbGxMZWZ0LFxuICAgICAgICAgIC8vIHVzZSB0b3AgcHJvcCwgc2Vjb25kIGFyZ3VtZW50IG9yIGZhbGxiYWNrIHRvIHNjcm9sbFRvcFxuICAgICAgICAgIGFyZ3VtZW50c1swXS50b3AgIT09IHVuZGVmaW5lZFxuICAgICAgICAgICAgPyB+fmFyZ3VtZW50c1swXS50b3BcbiAgICAgICAgICAgIDogYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyB+fmFyZ3VtZW50c1sxXSA6IHRoaXMuc2Nyb2xsVG9wXG4gICAgICAgICk7XG5cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB2YXIgbGVmdCA9IGFyZ3VtZW50c1swXS5sZWZ0O1xuICAgICAgdmFyIHRvcCA9IGFyZ3VtZW50c1swXS50b3A7XG5cbiAgICAgIC8vIExFVCBUSEUgU01PT1RITkVTUyBCRUdJTiFcbiAgICAgIHNtb290aFNjcm9sbC5jYWxsKFxuICAgICAgICB0aGlzLFxuICAgICAgICB0aGlzLFxuICAgICAgICB0eXBlb2YgbGVmdCA9PT0gJ3VuZGVmaW5lZCcgPyB0aGlzLnNjcm9sbExlZnQgOiB+fmxlZnQsXG4gICAgICAgIHR5cGVvZiB0b3AgPT09ICd1bmRlZmluZWQnID8gdGhpcy5zY3JvbGxUb3AgOiB+fnRvcFxuICAgICAgKTtcbiAgICB9O1xuXG4gICAgLy8gRWxlbWVudC5wcm90b3R5cGUuc2Nyb2xsQnlcbiAgICBFbGVtZW50LnByb3RvdHlwZS5zY3JvbGxCeSA9IGZ1bmN0aW9uKCkge1xuICAgICAgLy8gYXZvaWQgYWN0aW9uIHdoZW4gbm8gYXJndW1lbnRzIGFyZSBwYXNzZWRcbiAgICAgIGlmIChhcmd1bWVudHNbMF0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIC8vIGF2b2lkIHNtb290aCBiZWhhdmlvciBpZiBub3QgcmVxdWlyZWRcbiAgICAgIGlmIChzaG91bGRCYWlsT3V0KGFyZ3VtZW50c1swXSkgPT09IHRydWUpIHtcbiAgICAgICAgb3JpZ2luYWwuZWxlbWVudFNjcm9sbC5jYWxsKFxuICAgICAgICAgIHRoaXMsXG4gICAgICAgICAgYXJndW1lbnRzWzBdLmxlZnQgIT09IHVuZGVmaW5lZFxuICAgICAgICAgICAgPyB+fmFyZ3VtZW50c1swXS5sZWZ0ICsgdGhpcy5zY3JvbGxMZWZ0XG4gICAgICAgICAgICA6IH5+YXJndW1lbnRzWzBdICsgdGhpcy5zY3JvbGxMZWZ0LFxuICAgICAgICAgIGFyZ3VtZW50c1swXS50b3AgIT09IHVuZGVmaW5lZFxuICAgICAgICAgICAgPyB+fmFyZ3VtZW50c1swXS50b3AgKyB0aGlzLnNjcm9sbFRvcFxuICAgICAgICAgICAgOiB+fmFyZ3VtZW50c1sxXSArIHRoaXMuc2Nyb2xsVG9wXG4gICAgICAgICk7XG5cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB0aGlzLnNjcm9sbCh7XG4gICAgICAgIGxlZnQ6IH5+YXJndW1lbnRzWzBdLmxlZnQgKyB0aGlzLnNjcm9sbExlZnQsXG4gICAgICAgIHRvcDogfn5hcmd1bWVudHNbMF0udG9wICsgdGhpcy5zY3JvbGxUb3AsXG4gICAgICAgIGJlaGF2aW9yOiBhcmd1bWVudHNbMF0uYmVoYXZpb3JcbiAgICAgIH0pO1xuICAgIH07XG5cbiAgICAvLyBFbGVtZW50LnByb3RvdHlwZS5zY3JvbGxJbnRvVmlld1xuICAgIEVsZW1lbnQucHJvdG90eXBlLnNjcm9sbEludG9WaWV3ID0gZnVuY3Rpb24oKSB7XG4gICAgICAvLyBhdm9pZCBzbW9vdGggYmVoYXZpb3IgaWYgbm90IHJlcXVpcmVkXG4gICAgICBpZiAoc2hvdWxkQmFpbE91dChhcmd1bWVudHNbMF0pID09PSB0cnVlKSB7XG4gICAgICAgIG9yaWdpbmFsLnNjcm9sbEludG9WaWV3LmNhbGwoXG4gICAgICAgICAgdGhpcyxcbiAgICAgICAgICBhcmd1bWVudHNbMF0gPT09IHVuZGVmaW5lZCA/IHRydWUgOiBhcmd1bWVudHNbMF1cbiAgICAgICAgKTtcblxuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIC8vIExFVCBUSEUgU01PT1RITkVTUyBCRUdJTiFcbiAgICAgIHZhciBzY3JvbGxhYmxlUGFyZW50ID0gZmluZFNjcm9sbGFibGVQYXJlbnQodGhpcyk7XG4gICAgICB2YXIgcGFyZW50UmVjdHMgPSBzY3JvbGxhYmxlUGFyZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgdmFyIGNsaWVudFJlY3RzID0gdGhpcy5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcblxuICAgICAgaWYgKHNjcm9sbGFibGVQYXJlbnQgIT09IGQuYm9keSkge1xuICAgICAgICAvLyByZXZlYWwgZWxlbWVudCBpbnNpZGUgcGFyZW50XG4gICAgICAgIHNtb290aFNjcm9sbC5jYWxsKFxuICAgICAgICAgIHRoaXMsXG4gICAgICAgICAgc2Nyb2xsYWJsZVBhcmVudCxcbiAgICAgICAgICBzY3JvbGxhYmxlUGFyZW50LnNjcm9sbExlZnQgKyBjbGllbnRSZWN0cy5sZWZ0IC0gcGFyZW50UmVjdHMubGVmdCxcbiAgICAgICAgICBzY3JvbGxhYmxlUGFyZW50LnNjcm9sbFRvcCArIGNsaWVudFJlY3RzLnRvcCAtIHBhcmVudFJlY3RzLnRvcFxuICAgICAgICApO1xuXG4gICAgICAgIC8vIHJldmVhbCBwYXJlbnQgaW4gdmlld3BvcnQgdW5sZXNzIGlzIGZpeGVkXG4gICAgICAgIGlmICh3LmdldENvbXB1dGVkU3R5bGUoc2Nyb2xsYWJsZVBhcmVudCkucG9zaXRpb24gIT09ICdmaXhlZCcpIHtcbiAgICAgICAgICB3LnNjcm9sbEJ5KHtcbiAgICAgICAgICAgIGxlZnQ6IHBhcmVudFJlY3RzLmxlZnQsXG4gICAgICAgICAgICB0b3A6IHBhcmVudFJlY3RzLnRvcCxcbiAgICAgICAgICAgIGJlaGF2aW9yOiAnc21vb3RoJ1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyByZXZlYWwgZWxlbWVudCBpbiB2aWV3cG9ydFxuICAgICAgICB3LnNjcm9sbEJ5KHtcbiAgICAgICAgICBsZWZ0OiBjbGllbnRSZWN0cy5sZWZ0LFxuICAgICAgICAgIHRvcDogY2xpZW50UmVjdHMudG9wLFxuICAgICAgICAgIGJlaGF2aW9yOiAnc21vb3RoJ1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9O1xuICB9XG5cbiAge1xuICAgIC8vIGNvbW1vbmpzXG4gICAgbW9kdWxlLmV4cG9ydHMgPSB7IHBvbHlmaWxsOiBwb2x5ZmlsbCB9O1xuICB9XG5cbn0oKSk7XG59KTtcbnZhciBzbW9vdGhzY3JvbGxfMSA9IHNtb290aHNjcm9sbC5wb2x5ZmlsbDtcblxudmFyIF9kZWZhdWx0JDEgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9Db3JlKSB7XG4gIF9pbmhlcml0cyhfZGVmYXVsdCwgX0NvcmUpO1xuXG4gIHZhciBfc3VwZXIgPSBfY3JlYXRlU3VwZXIoX2RlZmF1bHQpO1xuXG4gIGZ1bmN0aW9uIF9kZWZhdWx0KCkge1xuICAgIHZhciBfdGhpcztcblxuICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fTtcblxuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBfZGVmYXVsdCk7XG5cbiAgICBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIG9wdGlvbnMpO1xuXG4gICAgaWYgKF90aGlzLnJlc2V0TmF0aXZlU2Nyb2xsKSB7XG4gICAgICBpZiAoaGlzdG9yeS5zY3JvbGxSZXN0b3JhdGlvbikge1xuICAgICAgICBoaXN0b3J5LnNjcm9sbFJlc3RvcmF0aW9uID0gJ21hbnVhbCc7XG4gICAgICB9XG5cbiAgICAgIHdpbmRvdy5zY3JvbGxUbygwLCAwKTtcbiAgICB9XG5cbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignc2Nyb2xsJywgX3RoaXMuY2hlY2tTY3JvbGwsIGZhbHNlKTtcblxuICAgIGlmICh3aW5kb3cuc21vb3Roc2Nyb2xsUG9seWZpbGwgPT09IHVuZGVmaW5lZCkge1xuICAgICAgd2luZG93LnNtb290aHNjcm9sbFBvbHlmaWxsID0gc21vb3Roc2Nyb2xsO1xuICAgICAgd2luZG93LnNtb290aHNjcm9sbFBvbHlmaWxsLnBvbHlmaWxsKCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKF9kZWZhdWx0LCBbe1xuICAgIGtleTogXCJpbml0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGluaXQoKSB7XG4gICAgICB0aGlzLmluc3RhbmNlLnNjcm9sbC55ID0gd2luZG93LnBhZ2VZT2Zmc2V0O1xuICAgICAgdGhpcy5hZGRFbGVtZW50cygpO1xuICAgICAgdGhpcy5kZXRlY3RFbGVtZW50cygpO1xuXG4gICAgICBfZ2V0KF9nZXRQcm90b3R5cGVPZihfZGVmYXVsdC5wcm90b3R5cGUpLCBcImluaXRcIiwgdGhpcykuY2FsbCh0aGlzKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiY2hlY2tTY3JvbGxcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY2hlY2tTY3JvbGwoKSB7XG4gICAgICB2YXIgX3RoaXMyID0gdGhpcztcblxuICAgICAgX2dldChfZ2V0UHJvdG90eXBlT2YoX2RlZmF1bHQucHJvdG90eXBlKSwgXCJjaGVja1Njcm9sbFwiLCB0aGlzKS5jYWxsKHRoaXMpO1xuXG4gICAgICBpZiAodGhpcy5nZXREaXJlY3Rpb24pIHtcbiAgICAgICAgdGhpcy5hZGREaXJlY3Rpb24oKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMuZ2V0U3BlZWQpIHtcbiAgICAgICAgdGhpcy5hZGRTcGVlZCgpO1xuICAgICAgICB0aGlzLnNwZWVkVHMgPSBEYXRlLm5vdygpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmluc3RhbmNlLnNjcm9sbC55ID0gd2luZG93LnBhZ2VZT2Zmc2V0O1xuXG4gICAgICBpZiAoT2JqZWN0LmVudHJpZXModGhpcy5lbHMpLmxlbmd0aCkge1xuICAgICAgICBpZiAoIXRoaXMuaGFzU2Nyb2xsVGlja2luZykge1xuICAgICAgICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZShmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBfdGhpczIuZGV0ZWN0RWxlbWVudHMoKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICB0aGlzLmhhc1Njcm9sbFRpY2tpbmcgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImFkZERpcmVjdGlvblwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhZGREaXJlY3Rpb24oKSB7XG4gICAgICBpZiAod2luZG93LnBhZ2VZT2Zmc2V0ID4gdGhpcy5pbnN0YW5jZS5zY3JvbGwueSkge1xuICAgICAgICBpZiAodGhpcy5pbnN0YW5jZS5kaXJlY3Rpb24gIT09ICdkb3duJykge1xuICAgICAgICAgIHRoaXMuaW5zdGFuY2UuZGlyZWN0aW9uID0gJ2Rvd24nO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHdpbmRvdy5wYWdlWU9mZnNldCA8IHRoaXMuaW5zdGFuY2Uuc2Nyb2xsLnkpIHtcbiAgICAgICAgaWYgKHRoaXMuaW5zdGFuY2UuZGlyZWN0aW9uICE9PSAndXAnKSB7XG4gICAgICAgICAgdGhpcy5pbnN0YW5jZS5kaXJlY3Rpb24gPSAndXAnO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImFkZFNwZWVkXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGFkZFNwZWVkKCkge1xuICAgICAgaWYgKHdpbmRvdy5wYWdlWU9mZnNldCAhPSB0aGlzLmluc3RhbmNlLnNjcm9sbC55KSB7XG4gICAgICAgIHRoaXMuaW5zdGFuY2Uuc3BlZWQgPSAod2luZG93LnBhZ2VZT2Zmc2V0IC0gdGhpcy5pbnN0YW5jZS5zY3JvbGwueSkgLyBNYXRoLm1heCgxLCBEYXRlLm5vdygpIC0gdGhpcy5zcGVlZFRzKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuaW5zdGFuY2Uuc3BlZWQgPSAwO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJyZXNpemVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVzaXplKCkge1xuICAgICAgaWYgKE9iamVjdC5lbnRyaWVzKHRoaXMuZWxzKS5sZW5ndGgpIHtcbiAgICAgICAgdGhpcy53aW5kb3dIZWlnaHQgPSB3aW5kb3cuaW5uZXJIZWlnaHQ7XG4gICAgICAgIHRoaXMudXBkYXRlRWxlbWVudHMoKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiYWRkRWxlbWVudHNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gYWRkRWxlbWVudHMoKSB7XG4gICAgICB2YXIgX3RoaXMzID0gdGhpcztcblxuICAgICAgdGhpcy5lbHMgPSB7fTtcbiAgICAgIHZhciBlbHMgPSB0aGlzLmVsLnF1ZXJ5U2VsZWN0b3JBbGwoJ1tkYXRhLScgKyB0aGlzLm5hbWUgKyAnXScpO1xuICAgICAgZWxzLmZvckVhY2goZnVuY3Rpb24gKGVsLCBpbmRleCkge1xuICAgICAgICB2YXIgQkNSID0gZWwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgIHZhciBjbCA9IGVsLmRhdGFzZXRbX3RoaXMzLm5hbWUgKyAnQ2xhc3MnXSB8fCBfdGhpczNbXCJjbGFzc1wiXTtcbiAgICAgICAgdmFyIGlkID0gdHlwZW9mIGVsLmRhdGFzZXRbX3RoaXMzLm5hbWUgKyAnSWQnXSA9PT0gJ3N0cmluZycgPyBlbC5kYXRhc2V0W190aGlzMy5uYW1lICsgJ0lkJ10gOiBpbmRleDtcbiAgICAgICAgdmFyIHRvcDtcbiAgICAgICAgdmFyIGxlZnQ7XG4gICAgICAgIHZhciBvZmZzZXQgPSB0eXBlb2YgZWwuZGF0YXNldFtfdGhpczMubmFtZSArICdPZmZzZXQnXSA9PT0gJ3N0cmluZycgPyBlbC5kYXRhc2V0W190aGlzMy5uYW1lICsgJ09mZnNldCddLnNwbGl0KCcsJykgOiBfdGhpczMub2Zmc2V0O1xuICAgICAgICB2YXIgcmVwZWF0ID0gZWwuZGF0YXNldFtfdGhpczMubmFtZSArICdSZXBlYXQnXTtcbiAgICAgICAgdmFyIGNhbGwgPSBlbC5kYXRhc2V0W190aGlzMy5uYW1lICsgJ0NhbGwnXTtcbiAgICAgICAgdmFyIHRhcmdldCA9IGVsLmRhdGFzZXRbX3RoaXMzLm5hbWUgKyAnVGFyZ2V0J107XG4gICAgICAgIHZhciB0YXJnZXRFbDtcblxuICAgICAgICBpZiAodGFyZ2V0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICB0YXJnZXRFbCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoXCJcIi5jb25jYXQodGFyZ2V0KSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGFyZ2V0RWwgPSBlbDtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciB0YXJnZXRFbEJDUiA9IHRhcmdldEVsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICB0b3AgPSB0YXJnZXRFbEJDUi50b3AgKyBfdGhpczMuaW5zdGFuY2Uuc2Nyb2xsLnk7XG4gICAgICAgIGxlZnQgPSB0YXJnZXRFbEJDUi5sZWZ0ICsgX3RoaXMzLmluc3RhbmNlLnNjcm9sbC54O1xuICAgICAgICB2YXIgYm90dG9tID0gdG9wICsgdGFyZ2V0RWwub2Zmc2V0SGVpZ2h0O1xuICAgICAgICB2YXIgcmlnaHQgPSBsZWZ0ICsgdGFyZ2V0RWwub2Zmc2V0V2lkdGg7XG5cbiAgICAgICAgaWYgKHJlcGVhdCA9PSAnZmFsc2UnKSB7XG4gICAgICAgICAgcmVwZWF0ID0gZmFsc2U7XG4gICAgICAgIH0gZWxzZSBpZiAocmVwZWF0ICE9IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHJlcGVhdCA9IHRydWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVwZWF0ID0gX3RoaXMzLnJlcGVhdDtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciByZWxhdGl2ZU9mZnNldCA9IF90aGlzMy5nZXRSZWxhdGl2ZU9mZnNldChvZmZzZXQpO1xuXG4gICAgICAgIHRvcCA9IHRvcCArIHJlbGF0aXZlT2Zmc2V0WzBdO1xuICAgICAgICBib3R0b20gPSBib3R0b20gLSByZWxhdGl2ZU9mZnNldFsxXTtcbiAgICAgICAgdmFyIG1hcHBlZEVsID0ge1xuICAgICAgICAgIGVsOiBlbCxcbiAgICAgICAgICB0YXJnZXRFbDogdGFyZ2V0RWwsXG4gICAgICAgICAgaWQ6IGlkLFxuICAgICAgICAgIFwiY2xhc3NcIjogY2wsXG4gICAgICAgICAgdG9wOiB0b3AsXG4gICAgICAgICAgYm90dG9tOiBib3R0b20sXG4gICAgICAgICAgbGVmdDogbGVmdCxcbiAgICAgICAgICByaWdodDogcmlnaHQsXG4gICAgICAgICAgb2Zmc2V0OiBvZmZzZXQsXG4gICAgICAgICAgcHJvZ3Jlc3M6IDAsXG4gICAgICAgICAgcmVwZWF0OiByZXBlYXQsXG4gICAgICAgICAgaW5WaWV3OiBmYWxzZSxcbiAgICAgICAgICBjYWxsOiBjYWxsXG4gICAgICAgIH07XG4gICAgICAgIF90aGlzMy5lbHNbaWRdID0gbWFwcGVkRWw7XG5cbiAgICAgICAgaWYgKGVsLmNsYXNzTGlzdC5jb250YWlucyhjbCkpIHtcbiAgICAgICAgICBfdGhpczMuc2V0SW5WaWV3KF90aGlzMy5lbHNbaWRdLCBpZCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJ1cGRhdGVFbGVtZW50c1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB1cGRhdGVFbGVtZW50cygpIHtcbiAgICAgIHZhciBfdGhpczQgPSB0aGlzO1xuXG4gICAgICBPYmplY3QuZW50cmllcyh0aGlzLmVscykuZm9yRWFjaChmdW5jdGlvbiAoX3JlZikge1xuICAgICAgICB2YXIgX3JlZjIgPSBfc2xpY2VkVG9BcnJheShfcmVmLCAyKSxcbiAgICAgICAgICAgIGkgPSBfcmVmMlswXSxcbiAgICAgICAgICAgIGVsID0gX3JlZjJbMV07XG5cbiAgICAgICAgdmFyIHRvcCA9IGVsLnRhcmdldEVsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLnRvcCArIF90aGlzNC5pbnN0YW5jZS5zY3JvbGwueTtcblxuICAgICAgICB2YXIgYm90dG9tID0gdG9wICsgZWwudGFyZ2V0RWwub2Zmc2V0SGVpZ2h0O1xuXG4gICAgICAgIHZhciByZWxhdGl2ZU9mZnNldCA9IF90aGlzNC5nZXRSZWxhdGl2ZU9mZnNldChlbC5vZmZzZXQpO1xuXG4gICAgICAgIF90aGlzNC5lbHNbaV0udG9wID0gdG9wICsgcmVsYXRpdmVPZmZzZXRbMF07XG4gICAgICAgIF90aGlzNC5lbHNbaV0uYm90dG9tID0gYm90dG9tIC0gcmVsYXRpdmVPZmZzZXRbMV07XG4gICAgICB9KTtcbiAgICAgIHRoaXMuaGFzU2Nyb2xsVGlja2luZyA9IGZhbHNlO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJnZXRSZWxhdGl2ZU9mZnNldFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRSZWxhdGl2ZU9mZnNldChvZmZzZXQpIHtcbiAgICAgIHZhciByZWxhdGl2ZU9mZnNldCA9IFswLCAwXTtcblxuICAgICAgaWYgKG9mZnNldCkge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG9mZnNldC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGlmICh0eXBlb2Ygb2Zmc2V0W2ldID09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBpZiAob2Zmc2V0W2ldLmluY2x1ZGVzKCclJykpIHtcbiAgICAgICAgICAgICAgcmVsYXRpdmVPZmZzZXRbaV0gPSBwYXJzZUludChvZmZzZXRbaV0ucmVwbGFjZSgnJScsICcnKSAqIHRoaXMud2luZG93SGVpZ2h0IC8gMTAwKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHJlbGF0aXZlT2Zmc2V0W2ldID0gcGFyc2VJbnQob2Zmc2V0W2ldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVsYXRpdmVPZmZzZXRbaV0gPSBvZmZzZXRbaV07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiByZWxhdGl2ZU9mZnNldDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2Nyb2xsIHRvIGEgZGVzaXJlZCB0YXJnZXQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gIEF2YWlsYWJsZSBvcHRpb25zIDpcbiAgICAgKiAgICAgICAgICB0YXJnZXQge25vZGUsIHN0cmluZywgXCJ0b3BcIiwgXCJib3R0b21cIiwgaW50fSAtIFRoZSBET00gZWxlbWVudCB3ZSB3YW50IHRvIHNjcm9sbCB0b1xuICAgICAqICAgICAgICAgIG9wdGlvbnMge29iamVjdH0gLSBPcHRpb25zIG9iamVjdCBmb3IgYWRkaXRpb25uYWwgc2V0dGluZ3MuXG4gICAgICogQHJldHVybiB7dm9pZH1cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcInNjcm9sbFRvXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNjcm9sbFRvKHRhcmdldCkge1xuICAgICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuICAgICAgLy8gUGFyc2Ugb3B0aW9uc1xuICAgICAgdmFyIG9mZnNldCA9IHBhcnNlSW50KG9wdGlvbnMub2Zmc2V0KSB8fCAwOyAvLyBBbiBvZmZzZXQgdG8gYXBwbHkgb24gdG9wIG9mIGdpdmVuIGB0YXJnZXRgIG9yIGBzb3VyY2VFbGVtYCdzIHRhcmdldFxuXG4gICAgICB2YXIgY2FsbGJhY2sgPSBvcHRpb25zLmNhbGxiYWNrID8gb3B0aW9ucy5jYWxsYmFjayA6IGZhbHNlOyAvLyBmdW5jdGlvbiBjYWxsZWQgd2hlbiBzY3JvbGxUbyBjb21wbGV0ZXMgKG5vdGUgdGhhdCBpdCB3b24ndCB3YWl0IGZvciBsZXJwIHRvIHN0YWJpbGl6ZSlcblxuICAgICAgaWYgKHR5cGVvZiB0YXJnZXQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIC8vIFNlbGVjdG9yIG9yIGJvdW5kYXJpZXNcbiAgICAgICAgaWYgKHRhcmdldCA9PT0gJ3RvcCcpIHtcbiAgICAgICAgICB0YXJnZXQgPSB0aGlzLmh0bWw7XG4gICAgICAgIH0gZWxzZSBpZiAodGFyZ2V0ID09PSAnYm90dG9tJykge1xuICAgICAgICAgIHRhcmdldCA9IHRoaXMuaHRtbC5vZmZzZXRIZWlnaHQgLSB3aW5kb3cuaW5uZXJIZWlnaHQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGFyZ2V0ID0gZG9jdW1lbnQucXVlcnlTZWxlY3Rvcih0YXJnZXQpOyAvLyBJZiB0aGUgcXVlcnkgZmFpbHMsIGFib3J0XG5cbiAgICAgICAgICBpZiAoIXRhcmdldCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmICh0eXBlb2YgdGFyZ2V0ID09PSAnbnVtYmVyJykge1xuICAgICAgICAvLyBBYnNvbHV0ZSBjb29yZGluYXRlXG4gICAgICAgIHRhcmdldCA9IHBhcnNlSW50KHRhcmdldCk7XG4gICAgICB9IGVsc2UgaWYgKHRhcmdldCAmJiB0YXJnZXQudGFnTmFtZSkgOyBlbHNlIHtcbiAgICAgICAgY29uc29sZS53YXJuKCdgdGFyZ2V0YCBwYXJhbWV0ZXIgaXMgbm90IHZhbGlkJyk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH0gLy8gV2UgaGF2ZSBhIHRhcmdldCB0aGF0IGlzIG5vdCBhIGNvb3JkaW5hdGUgeWV0LCBnZXQgaXRcblxuXG4gICAgICBpZiAodHlwZW9mIHRhcmdldCAhPT0gJ251bWJlcicpIHtcbiAgICAgICAgb2Zmc2V0ID0gdGFyZ2V0LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLnRvcCArIG9mZnNldCArIHRoaXMuaW5zdGFuY2Uuc2Nyb2xsLnk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBvZmZzZXQgPSB0YXJnZXQgKyBvZmZzZXQ7XG4gICAgICB9XG5cbiAgICAgIHZhciBpc1RhcmdldFJlYWNoZWQgPSBmdW5jdGlvbiBpc1RhcmdldFJlYWNoZWQoKSB7XG4gICAgICAgIHJldHVybiBwYXJzZUludCh3aW5kb3cucGFnZVlPZmZzZXQpID09PSBwYXJzZUludChvZmZzZXQpO1xuICAgICAgfTtcblxuICAgICAgaWYgKGNhbGxiYWNrKSB7XG4gICAgICAgIGlmIChpc1RhcmdldFJlYWNoZWQoKSkge1xuICAgICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciBvblNjcm9sbCA9IGZ1bmN0aW9uIG9uU2Nyb2xsKCkge1xuICAgICAgICAgICAgaWYgKGlzVGFyZ2V0UmVhY2hlZCgpKSB7XG4gICAgICAgICAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdzY3JvbGwnLCBvblNjcm9sbCk7XG4gICAgICAgICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfTtcblxuICAgICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdzY3JvbGwnLCBvblNjcm9sbCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgd2luZG93LnNjcm9sbFRvKHtcbiAgICAgICAgdG9wOiBvZmZzZXQsXG4gICAgICAgIGJlaGF2aW9yOiBvcHRpb25zLmR1cmF0aW9uID09PSAwID8gJ2F1dG8nIDogJ3Ntb290aCdcbiAgICAgIH0pO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJ1cGRhdGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdXBkYXRlKCkge1xuICAgICAgdGhpcy5hZGRFbGVtZW50cygpO1xuICAgICAgdGhpcy5kZXRlY3RFbGVtZW50cygpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJkZXN0cm95XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRlc3Ryb3koKSB7XG4gICAgICBfZ2V0KF9nZXRQcm90b3R5cGVPZihfZGVmYXVsdC5wcm90b3R5cGUpLCBcImRlc3Ryb3lcIiwgdGhpcykuY2FsbCh0aGlzKTtcblxuICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Njcm9sbCcsIHRoaXMuY2hlY2tTY3JvbGwsIGZhbHNlKTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gX2RlZmF1bHQ7XG59KF9kZWZhdWx0KTtcblxuLypcbm9iamVjdC1hc3NpZ25cbihjKSBTaW5kcmUgU29yaHVzXG5AbGljZW5zZSBNSVRcbiovXG4vKiBlc2xpbnQtZGlzYWJsZSBuby11bnVzZWQtdmFycyAqL1xudmFyIGdldE93blByb3BlcnR5U3ltYm9scyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHM7XG52YXIgaGFzT3duUHJvcGVydHkgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xudmFyIHByb3BJc0VudW1lcmFibGUgPSBPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlO1xuXG5mdW5jdGlvbiB0b09iamVjdCh2YWwpIHtcblx0aWYgKHZhbCA9PT0gbnVsbCB8fCB2YWwgPT09IHVuZGVmaW5lZCkge1xuXHRcdHRocm93IG5ldyBUeXBlRXJyb3IoJ09iamVjdC5hc3NpZ24gY2Fubm90IGJlIGNhbGxlZCB3aXRoIG51bGwgb3IgdW5kZWZpbmVkJyk7XG5cdH1cblxuXHRyZXR1cm4gT2JqZWN0KHZhbCk7XG59XG5cbmZ1bmN0aW9uIHNob3VsZFVzZU5hdGl2ZSgpIHtcblx0dHJ5IHtcblx0XHRpZiAoIU9iamVjdC5hc3NpZ24pIHtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cblx0XHQvLyBEZXRlY3QgYnVnZ3kgcHJvcGVydHkgZW51bWVyYXRpb24gb3JkZXIgaW4gb2xkZXIgVjggdmVyc2lvbnMuXG5cblx0XHQvLyBodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvdjgvaXNzdWVzL2RldGFpbD9pZD00MTE4XG5cdFx0dmFyIHRlc3QxID0gbmV3IFN0cmluZygnYWJjJyk7ICAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLW5ldy13cmFwcGVyc1xuXHRcdHRlc3QxWzVdID0gJ2RlJztcblx0XHRpZiAoT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXModGVzdDEpWzBdID09PSAnNScpIHtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cblx0XHQvLyBodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvdjgvaXNzdWVzL2RldGFpbD9pZD0zMDU2XG5cdFx0dmFyIHRlc3QyID0ge307XG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCAxMDsgaSsrKSB7XG5cdFx0XHR0ZXN0MlsnXycgKyBTdHJpbmcuZnJvbUNoYXJDb2RlKGkpXSA9IGk7XG5cdFx0fVxuXHRcdHZhciBvcmRlcjIgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyh0ZXN0MikubWFwKGZ1bmN0aW9uIChuKSB7XG5cdFx0XHRyZXR1cm4gdGVzdDJbbl07XG5cdFx0fSk7XG5cdFx0aWYgKG9yZGVyMi5qb2luKCcnKSAhPT0gJzAxMjM0NTY3ODknKSB7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXG5cdFx0Ly8gaHR0cHM6Ly9idWdzLmNocm9taXVtLm9yZy9wL3Y4L2lzc3Vlcy9kZXRhaWw/aWQ9MzA1NlxuXHRcdHZhciB0ZXN0MyA9IHt9O1xuXHRcdCdhYmNkZWZnaGlqa2xtbm9wcXJzdCcuc3BsaXQoJycpLmZvckVhY2goZnVuY3Rpb24gKGxldHRlcikge1xuXHRcdFx0dGVzdDNbbGV0dGVyXSA9IGxldHRlcjtcblx0XHR9KTtcblx0XHRpZiAoT2JqZWN0LmtleXMoT2JqZWN0LmFzc2lnbih7fSwgdGVzdDMpKS5qb2luKCcnKSAhPT1cblx0XHRcdFx0J2FiY2RlZmdoaWprbG1ub3BxcnN0Jykge1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblxuXHRcdHJldHVybiB0cnVlO1xuXHR9IGNhdGNoIChlcnIpIHtcblx0XHQvLyBXZSBkb24ndCBleHBlY3QgYW55IG9mIHRoZSBhYm92ZSB0byB0aHJvdywgYnV0IGJldHRlciB0byBiZSBzYWZlLlxuXHRcdHJldHVybiBmYWxzZTtcblx0fVxufVxuXG52YXIgb2JqZWN0QXNzaWduID0gc2hvdWxkVXNlTmF0aXZlKCkgPyBPYmplY3QuYXNzaWduIDogZnVuY3Rpb24gKHRhcmdldCwgc291cmNlKSB7XG5cdHZhciBmcm9tO1xuXHR2YXIgdG8gPSB0b09iamVjdCh0YXJnZXQpO1xuXHR2YXIgc3ltYm9scztcblxuXHRmb3IgKHZhciBzID0gMTsgcyA8IGFyZ3VtZW50cy5sZW5ndGg7IHMrKykge1xuXHRcdGZyb20gPSBPYmplY3QoYXJndW1lbnRzW3NdKTtcblxuXHRcdGZvciAodmFyIGtleSBpbiBmcm9tKSB7XG5cdFx0XHRpZiAoaGFzT3duUHJvcGVydHkuY2FsbChmcm9tLCBrZXkpKSB7XG5cdFx0XHRcdHRvW2tleV0gPSBmcm9tW2tleV07XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0aWYgKGdldE93blByb3BlcnR5U3ltYm9scykge1xuXHRcdFx0c3ltYm9scyA9IGdldE93blByb3BlcnR5U3ltYm9scyhmcm9tKTtcblx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgc3ltYm9scy5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHRpZiAocHJvcElzRW51bWVyYWJsZS5jYWxsKGZyb20sIHN5bWJvbHNbaV0pKSB7XG5cdFx0XHRcdFx0dG9bc3ltYm9sc1tpXV0gPSBmcm9tW3N5bWJvbHNbaV1dO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIHRvO1xufTtcblxuZnVuY3Rpb24gRSAoKSB7XG4gIC8vIEtlZXAgdGhpcyBlbXB0eSBzbyBpdCdzIGVhc2llciB0byBpbmhlcml0IGZyb21cbiAgLy8gKHZpYSBodHRwczovL2dpdGh1Yi5jb20vbGlwc21hY2sgZnJvbSBodHRwczovL2dpdGh1Yi5jb20vc2NvdHRjb3JnYW4vdGlueS1lbWl0dGVyL2lzc3Vlcy8zKVxufVxuXG5FLnByb3RvdHlwZSA9IHtcbiAgb246IGZ1bmN0aW9uIChuYW1lLCBjYWxsYmFjaywgY3R4KSB7XG4gICAgdmFyIGUgPSB0aGlzLmUgfHwgKHRoaXMuZSA9IHt9KTtcblxuICAgIChlW25hbWVdIHx8IChlW25hbWVdID0gW10pKS5wdXNoKHtcbiAgICAgIGZuOiBjYWxsYmFjayxcbiAgICAgIGN0eDogY3R4XG4gICAgfSk7XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfSxcblxuICBvbmNlOiBmdW5jdGlvbiAobmFtZSwgY2FsbGJhY2ssIGN0eCkge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICBmdW5jdGlvbiBsaXN0ZW5lciAoKSB7XG4gICAgICBzZWxmLm9mZihuYW1lLCBsaXN0ZW5lcik7XG4gICAgICBjYWxsYmFjay5hcHBseShjdHgsIGFyZ3VtZW50cyk7XG4gICAgfVxuICAgIGxpc3RlbmVyLl8gPSBjYWxsYmFjaztcbiAgICByZXR1cm4gdGhpcy5vbihuYW1lLCBsaXN0ZW5lciwgY3R4KTtcbiAgfSxcblxuICBlbWl0OiBmdW5jdGlvbiAobmFtZSkge1xuICAgIHZhciBkYXRhID0gW10uc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpO1xuICAgIHZhciBldnRBcnIgPSAoKHRoaXMuZSB8fCAodGhpcy5lID0ge30pKVtuYW1lXSB8fCBbXSkuc2xpY2UoKTtcbiAgICB2YXIgaSA9IDA7XG4gICAgdmFyIGxlbiA9IGV2dEFyci5sZW5ndGg7XG5cbiAgICBmb3IgKGk7IGkgPCBsZW47IGkrKykge1xuICAgICAgZXZ0QXJyW2ldLmZuLmFwcGx5KGV2dEFycltpXS5jdHgsIGRhdGEpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9LFxuXG4gIG9mZjogZnVuY3Rpb24gKG5hbWUsIGNhbGxiYWNrKSB7XG4gICAgdmFyIGUgPSB0aGlzLmUgfHwgKHRoaXMuZSA9IHt9KTtcbiAgICB2YXIgZXZ0cyA9IGVbbmFtZV07XG4gICAgdmFyIGxpdmVFdmVudHMgPSBbXTtcblxuICAgIGlmIChldnRzICYmIGNhbGxiYWNrKSB7XG4gICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gZXZ0cy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICBpZiAoZXZ0c1tpXS5mbiAhPT0gY2FsbGJhY2sgJiYgZXZ0c1tpXS5mbi5fICE9PSBjYWxsYmFjaylcbiAgICAgICAgICBsaXZlRXZlbnRzLnB1c2goZXZ0c1tpXSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gUmVtb3ZlIGV2ZW50IGZyb20gcXVldWUgdG8gcHJldmVudCBtZW1vcnkgbGVha1xuICAgIC8vIFN1Z2dlc3RlZCBieSBodHRwczovL2dpdGh1Yi5jb20vbGF6ZFxuICAgIC8vIFJlZjogaHR0cHM6Ly9naXRodWIuY29tL3Njb3R0Y29yZ2FuL3RpbnktZW1pdHRlci9jb21taXQvYzZlYmZhYTliYzk3M2IzM2QxMTBhODRhMzA3NzQyYjdjZjk0Yzk1MyNjb21taXRjb21tZW50LTUwMjQ5MTBcblxuICAgIChsaXZlRXZlbnRzLmxlbmd0aClcbiAgICAgID8gZVtuYW1lXSA9IGxpdmVFdmVudHNcbiAgICAgIDogZGVsZXRlIGVbbmFtZV07XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfVxufTtcblxudmFyIHRpbnlFbWl0dGVyID0gRTtcblxudmFyIGxldGhhcmd5ID0gY3JlYXRlQ29tbW9uanNNb2R1bGUoZnVuY3Rpb24gKG1vZHVsZSwgZXhwb3J0cykge1xuLy8gR2VuZXJhdGVkIGJ5IENvZmZlZVNjcmlwdCAxLjkuMlxuKGZ1bmN0aW9uKCkge1xuICB2YXIgcm9vdDtcblxuICByb290ID0gIGV4cG9ydHMgIT09IG51bGwgPyBleHBvcnRzIDogdGhpcztcblxuICByb290LkxldGhhcmd5ID0gKGZ1bmN0aW9uKCkge1xuICAgIGZ1bmN0aW9uIExldGhhcmd5KHN0YWJpbGl0eSwgc2Vuc2l0aXZpdHksIHRvbGVyYW5jZSwgZGVsYXkpIHtcbiAgICAgIHRoaXMuc3RhYmlsaXR5ID0gc3RhYmlsaXR5ICE9IG51bGwgPyBNYXRoLmFicyhzdGFiaWxpdHkpIDogODtcbiAgICAgIHRoaXMuc2Vuc2l0aXZpdHkgPSBzZW5zaXRpdml0eSAhPSBudWxsID8gMSArIE1hdGguYWJzKHNlbnNpdGl2aXR5KSA6IDEwMDtcbiAgICAgIHRoaXMudG9sZXJhbmNlID0gdG9sZXJhbmNlICE9IG51bGwgPyAxICsgTWF0aC5hYnModG9sZXJhbmNlKSA6IDEuMTtcbiAgICAgIHRoaXMuZGVsYXkgPSBkZWxheSAhPSBudWxsID8gZGVsYXkgOiAxNTA7XG4gICAgICB0aGlzLmxhc3RVcERlbHRhcyA9IChmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGksIHJlZiwgcmVzdWx0cztcbiAgICAgICAgcmVzdWx0cyA9IFtdO1xuICAgICAgICBmb3IgKGkgPSAxLCByZWYgPSB0aGlzLnN0YWJpbGl0eSAqIDI7IDEgPD0gcmVmID8gaSA8PSByZWYgOiBpID49IHJlZjsgMSA8PSByZWYgPyBpKysgOiBpLS0pIHtcbiAgICAgICAgICByZXN1bHRzLnB1c2gobnVsbCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdHM7XG4gICAgICB9KS5jYWxsKHRoaXMpO1xuICAgICAgdGhpcy5sYXN0RG93bkRlbHRhcyA9IChmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGksIHJlZiwgcmVzdWx0cztcbiAgICAgICAgcmVzdWx0cyA9IFtdO1xuICAgICAgICBmb3IgKGkgPSAxLCByZWYgPSB0aGlzLnN0YWJpbGl0eSAqIDI7IDEgPD0gcmVmID8gaSA8PSByZWYgOiBpID49IHJlZjsgMSA8PSByZWYgPyBpKysgOiBpLS0pIHtcbiAgICAgICAgICByZXN1bHRzLnB1c2gobnVsbCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdHM7XG4gICAgICB9KS5jYWxsKHRoaXMpO1xuICAgICAgdGhpcy5kZWx0YXNUaW1lc3RhbXAgPSAoZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBpLCByZWYsIHJlc3VsdHM7XG4gICAgICAgIHJlc3VsdHMgPSBbXTtcbiAgICAgICAgZm9yIChpID0gMSwgcmVmID0gdGhpcy5zdGFiaWxpdHkgKiAyOyAxIDw9IHJlZiA/IGkgPD0gcmVmIDogaSA+PSByZWY7IDEgPD0gcmVmID8gaSsrIDogaS0tKSB7XG4gICAgICAgICAgcmVzdWx0cy5wdXNoKG51bGwpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHRzO1xuICAgICAgfSkuY2FsbCh0aGlzKTtcbiAgICB9XG5cbiAgICBMZXRoYXJneS5wcm90b3R5cGUuY2hlY2sgPSBmdW5jdGlvbihlKSB7XG4gICAgICB2YXIgbGFzdERlbHRhO1xuICAgICAgZSA9IGUub3JpZ2luYWxFdmVudCB8fCBlO1xuICAgICAgaWYgKGUud2hlZWxEZWx0YSAhPSBudWxsKSB7XG4gICAgICAgIGxhc3REZWx0YSA9IGUud2hlZWxEZWx0YTtcbiAgICAgIH0gZWxzZSBpZiAoZS5kZWx0YVkgIT0gbnVsbCkge1xuICAgICAgICBsYXN0RGVsdGEgPSBlLmRlbHRhWSAqIC00MDtcbiAgICAgIH0gZWxzZSBpZiAoKGUuZGV0YWlsICE9IG51bGwpIHx8IGUuZGV0YWlsID09PSAwKSB7XG4gICAgICAgIGxhc3REZWx0YSA9IGUuZGV0YWlsICogLTQwO1xuICAgICAgfVxuICAgICAgdGhpcy5kZWx0YXNUaW1lc3RhbXAucHVzaChEYXRlLm5vdygpKTtcbiAgICAgIHRoaXMuZGVsdGFzVGltZXN0YW1wLnNoaWZ0KCk7XG4gICAgICBpZiAobGFzdERlbHRhID4gMCkge1xuICAgICAgICB0aGlzLmxhc3RVcERlbHRhcy5wdXNoKGxhc3REZWx0YSk7XG4gICAgICAgIHRoaXMubGFzdFVwRGVsdGFzLnNoaWZ0KCk7XG4gICAgICAgIHJldHVybiB0aGlzLmlzSW5lcnRpYSgxKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMubGFzdERvd25EZWx0YXMucHVzaChsYXN0RGVsdGEpO1xuICAgICAgICB0aGlzLmxhc3REb3duRGVsdGFzLnNoaWZ0KCk7XG4gICAgICAgIHJldHVybiB0aGlzLmlzSW5lcnRpYSgtMSk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIExldGhhcmd5LnByb3RvdHlwZS5pc0luZXJ0aWEgPSBmdW5jdGlvbihkaXJlY3Rpb24pIHtcbiAgICAgIHZhciBsYXN0RGVsdGFzLCBsYXN0RGVsdGFzTmV3LCBsYXN0RGVsdGFzT2xkLCBuZXdBdmVyYWdlLCBuZXdTdW0sIG9sZEF2ZXJhZ2UsIG9sZFN1bTtcbiAgICAgIGxhc3REZWx0YXMgPSBkaXJlY3Rpb24gPT09IC0xID8gdGhpcy5sYXN0RG93bkRlbHRhcyA6IHRoaXMubGFzdFVwRGVsdGFzO1xuICAgICAgaWYgKGxhc3REZWx0YXNbMF0gPT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIGRpcmVjdGlvbjtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLmRlbHRhc1RpbWVzdGFtcFsodGhpcy5zdGFiaWxpdHkgKiAyKSAtIDJdICsgdGhpcy5kZWxheSA+IERhdGUubm93KCkgJiYgbGFzdERlbHRhc1swXSA9PT0gbGFzdERlbHRhc1sodGhpcy5zdGFiaWxpdHkgKiAyKSAtIDFdKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIGxhc3REZWx0YXNPbGQgPSBsYXN0RGVsdGFzLnNsaWNlKDAsIHRoaXMuc3RhYmlsaXR5KTtcbiAgICAgIGxhc3REZWx0YXNOZXcgPSBsYXN0RGVsdGFzLnNsaWNlKHRoaXMuc3RhYmlsaXR5LCB0aGlzLnN0YWJpbGl0eSAqIDIpO1xuICAgICAgb2xkU3VtID0gbGFzdERlbHRhc09sZC5yZWR1Y2UoZnVuY3Rpb24odCwgcykge1xuICAgICAgICByZXR1cm4gdCArIHM7XG4gICAgICB9KTtcbiAgICAgIG5ld1N1bSA9IGxhc3REZWx0YXNOZXcucmVkdWNlKGZ1bmN0aW9uKHQsIHMpIHtcbiAgICAgICAgcmV0dXJuIHQgKyBzO1xuICAgICAgfSk7XG4gICAgICBvbGRBdmVyYWdlID0gb2xkU3VtIC8gbGFzdERlbHRhc09sZC5sZW5ndGg7XG4gICAgICBuZXdBdmVyYWdlID0gbmV3U3VtIC8gbGFzdERlbHRhc05ldy5sZW5ndGg7XG4gICAgICBpZiAoTWF0aC5hYnMob2xkQXZlcmFnZSkgPCBNYXRoLmFicyhuZXdBdmVyYWdlICogdGhpcy50b2xlcmFuY2UpICYmICh0aGlzLnNlbnNpdGl2aXR5IDwgTWF0aC5hYnMobmV3QXZlcmFnZSkpKSB7XG4gICAgICAgIHJldHVybiBkaXJlY3Rpb247XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfTtcblxuICAgIExldGhhcmd5LnByb3RvdHlwZS5zaG93TGFzdFVwRGVsdGFzID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5sYXN0VXBEZWx0YXM7XG4gICAgfTtcblxuICAgIExldGhhcmd5LnByb3RvdHlwZS5zaG93TGFzdERvd25EZWx0YXMgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLmxhc3REb3duRGVsdGFzO1xuICAgIH07XG5cbiAgICByZXR1cm4gTGV0aGFyZ3k7XG5cbiAgfSkoKTtcblxufSkuY2FsbChjb21tb25qc0dsb2JhbCk7XG59KTtcblxudmFyIHN1cHBvcnQgPSAoZnVuY3Rpb24gZ2V0U3VwcG9ydCgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBoYXNXaGVlbEV2ZW50OiAnb253aGVlbCcgaW4gZG9jdW1lbnQsXG4gICAgICAgIGhhc01vdXNlV2hlZWxFdmVudDogJ29ubW91c2V3aGVlbCcgaW4gZG9jdW1lbnQsXG4gICAgICAgIGhhc1RvdWNoOiAoJ29udG91Y2hzdGFydCcgaW4gd2luZG93KSB8fCB3aW5kb3cuVG91Y2hFdmVudCB8fCB3aW5kb3cuRG9jdW1lbnRUb3VjaCAmJiBkb2N1bWVudCBpbnN0YW5jZW9mIERvY3VtZW50VG91Y2gsXG4gICAgICAgIGhhc1RvdWNoV2luOiBuYXZpZ2F0b3IubXNNYXhUb3VjaFBvaW50cyAmJiBuYXZpZ2F0b3IubXNNYXhUb3VjaFBvaW50cyA+IDEsXG4gICAgICAgIGhhc1BvaW50ZXI6ICEhd2luZG93Lm5hdmlnYXRvci5tc1BvaW50ZXJFbmFibGVkLFxuICAgICAgICBoYXNLZXlEb3duOiAnb25rZXlkb3duJyBpbiBkb2N1bWVudCxcbiAgICAgICAgaXNGaXJlZm94OiBuYXZpZ2F0b3IudXNlckFnZW50LmluZGV4T2YoJ0ZpcmVmb3gnKSA+IC0xXG4gICAgfTtcbn0pKCk7XG5cbnZhciB0b1N0cmluZyA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcsXG4gICAgaGFzT3duUHJvcGVydHkkMSA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG5cbnZhciBiaW5kYWxsU3RhbmRhbG9uZSA9IGZ1bmN0aW9uKG9iamVjdCkge1xuICAgIGlmKCFvYmplY3QpIHJldHVybiBjb25zb2xlLndhcm4oJ2JpbmRBbGwgcmVxdWlyZXMgYXQgbGVhc3Qgb25lIGFyZ3VtZW50LicpO1xuXG4gICAgdmFyIGZ1bmN0aW9ucyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSk7XG5cbiAgICBpZiAoZnVuY3Rpb25zLmxlbmd0aCA9PT0gMCkge1xuXG4gICAgICAgIGZvciAodmFyIG1ldGhvZCBpbiBvYmplY3QpIHtcbiAgICAgICAgICAgIGlmKGhhc093blByb3BlcnR5JDEuY2FsbChvYmplY3QsIG1ldGhvZCkpIHtcbiAgICAgICAgICAgICAgICBpZih0eXBlb2Ygb2JqZWN0W21ldGhvZF0gPT0gJ2Z1bmN0aW9uJyAmJiB0b1N0cmluZy5jYWxsKG9iamVjdFttZXRob2RdKSA9PSBcIltvYmplY3QgRnVuY3Rpb25dXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb25zLnB1c2gobWV0aG9kKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmb3IodmFyIGkgPSAwOyBpIDwgZnVuY3Rpb25zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBmID0gZnVuY3Rpb25zW2ldO1xuICAgICAgICBvYmplY3RbZl0gPSBiaW5kKG9iamVjdFtmXSwgb2JqZWN0KTtcbiAgICB9XG59O1xuXG4vKlxuICAgIEZhc3RlciBiaW5kIHdpdGhvdXQgc3BlY2lmaWMtY2FzZSBjaGVja2luZy4gKHNlZSBodHRwczovL2NvZGVyd2FsbC5jb20vcC9vaTNqM3cpLlxuICAgIGJpbmRBbGwgaXMgb25seSBuZWVkZWQgZm9yIGV2ZW50cyBiaW5kaW5nIHNvIG5vIG5lZWQgdG8gbWFrZSBzbG93IGZpeGVzIGZvciBjb25zdHJ1Y3RvclxuICAgIG9yIHBhcnRpYWwgYXBwbGljYXRpb24uXG4qL1xuZnVuY3Rpb24gYmluZChmdW5jLCBjb250ZXh0KSB7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gZnVuYy5hcHBseShjb250ZXh0LCBhcmd1bWVudHMpO1xuICB9O1xufVxuXG52YXIgTGV0aGFyZ3kgPSBsZXRoYXJneS5MZXRoYXJneTtcblxuXG5cbnZhciBFVlRfSUQgPSAndmlydHVhbHNjcm9sbCc7XG5cbnZhciBzcmMgPSBWaXJ0dWFsU2Nyb2xsO1xuXG52YXIga2V5Q29kZXMgPSB7XG4gICAgTEVGVDogMzcsXG4gICAgVVA6IDM4LFxuICAgIFJJR0hUOiAzOSxcbiAgICBET1dOOiA0MCxcbiAgICBTUEFDRTogMzJcbn07XG5cbmZ1bmN0aW9uIFZpcnR1YWxTY3JvbGwob3B0aW9ucykge1xuICAgIGJpbmRhbGxTdGFuZGFsb25lKHRoaXMsICdfb25XaGVlbCcsICdfb25Nb3VzZVdoZWVsJywgJ19vblRvdWNoU3RhcnQnLCAnX29uVG91Y2hNb3ZlJywgJ19vbktleURvd24nKTtcblxuICAgIHRoaXMuZWwgPSB3aW5kb3c7XG4gICAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5lbCkge1xuICAgICAgICB0aGlzLmVsID0gb3B0aW9ucy5lbDtcbiAgICAgICAgZGVsZXRlIG9wdGlvbnMuZWw7XG4gICAgfVxuICAgIHRoaXMub3B0aW9ucyA9IG9iamVjdEFzc2lnbih7XG4gICAgICAgIG1vdXNlTXVsdGlwbGllcjogMSxcbiAgICAgICAgdG91Y2hNdWx0aXBsaWVyOiAyLFxuICAgICAgICBmaXJlZm94TXVsdGlwbGllcjogMTUsXG4gICAgICAgIGtleVN0ZXA6IDEyMCxcbiAgICAgICAgcHJldmVudFRvdWNoOiBmYWxzZSxcbiAgICAgICAgdW5wcmV2ZW50VG91Y2hDbGFzczogJ3ZzLXRvdWNobW92ZS1hbGxvd2VkJyxcbiAgICAgICAgbGltaXRJbmVydGlhOiBmYWxzZSxcbiAgICAgICAgdXNlS2V5Ym9hcmQ6IHRydWUsXG4gICAgICAgIHVzZVRvdWNoOiB0cnVlXG4gICAgfSwgb3B0aW9ucyk7XG5cbiAgICBpZiAodGhpcy5vcHRpb25zLmxpbWl0SW5lcnRpYSkgdGhpcy5fbGV0aGFyZ3kgPSBuZXcgTGV0aGFyZ3koKTtcblxuICAgIHRoaXMuX2VtaXR0ZXIgPSBuZXcgdGlueUVtaXR0ZXIoKTtcbiAgICB0aGlzLl9ldmVudCA9IHtcbiAgICAgICAgeTogMCxcbiAgICAgICAgeDogMCxcbiAgICAgICAgZGVsdGFYOiAwLFxuICAgICAgICBkZWx0YVk6IDBcbiAgICB9O1xuICAgIHRoaXMudG91Y2hTdGFydFggPSBudWxsO1xuICAgIHRoaXMudG91Y2hTdGFydFkgPSBudWxsO1xuICAgIHRoaXMuYm9keVRvdWNoQWN0aW9uID0gbnVsbDtcblxuICAgIGlmICh0aGlzLm9wdGlvbnMucGFzc2l2ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRoaXMubGlzdGVuZXJPcHRpb25zID0ge3Bhc3NpdmU6IHRoaXMub3B0aW9ucy5wYXNzaXZlfTtcbiAgICB9XG59XG5cblZpcnR1YWxTY3JvbGwucHJvdG90eXBlLl9ub3RpZnkgPSBmdW5jdGlvbihlKSB7XG4gICAgdmFyIGV2dCA9IHRoaXMuX2V2ZW50O1xuICAgIGV2dC54ICs9IGV2dC5kZWx0YVg7XG4gICAgZXZ0LnkgKz0gZXZ0LmRlbHRhWTtcblxuICAgdGhpcy5fZW1pdHRlci5lbWl0KEVWVF9JRCwge1xuICAgICAgICB4OiBldnQueCxcbiAgICAgICAgeTogZXZ0LnksXG4gICAgICAgIGRlbHRhWDogZXZ0LmRlbHRhWCxcbiAgICAgICAgZGVsdGFZOiBldnQuZGVsdGFZLFxuICAgICAgICBvcmlnaW5hbEV2ZW50OiBlXG4gICB9KTtcbn07XG5cblZpcnR1YWxTY3JvbGwucHJvdG90eXBlLl9vbldoZWVsID0gZnVuY3Rpb24oZSkge1xuICAgIHZhciBvcHRpb25zID0gdGhpcy5vcHRpb25zO1xuICAgIGlmICh0aGlzLl9sZXRoYXJneSAmJiB0aGlzLl9sZXRoYXJneS5jaGVjayhlKSA9PT0gZmFsc2UpIHJldHVybjtcbiAgICB2YXIgZXZ0ID0gdGhpcy5fZXZlbnQ7XG5cbiAgICAvLyBJbiBDaHJvbWUgYW5kIGluIEZpcmVmb3ggKGF0IGxlYXN0IHRoZSBuZXcgb25lKVxuICAgIGV2dC5kZWx0YVggPSBlLndoZWVsRGVsdGFYIHx8IGUuZGVsdGFYICogLTE7XG4gICAgZXZ0LmRlbHRhWSA9IGUud2hlZWxEZWx0YVkgfHwgZS5kZWx0YVkgKiAtMTtcblxuICAgIC8vIGZvciBvdXIgcHVycG9zZSBkZWx0YW1vZGUgPSAxIG1lYW5zIHVzZXIgaXMgb24gYSB3aGVlbCBtb3VzZSwgbm90IHRvdWNoIHBhZFxuICAgIC8vIHJlYWwgbWVhbmluZzogaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL1doZWVsRXZlbnQjRGVsdGFfbW9kZXNcbiAgICBpZihzdXBwb3J0LmlzRmlyZWZveCAmJiBlLmRlbHRhTW9kZSA9PSAxKSB7XG4gICAgICAgIGV2dC5kZWx0YVggKj0gb3B0aW9ucy5maXJlZm94TXVsdGlwbGllcjtcbiAgICAgICAgZXZ0LmRlbHRhWSAqPSBvcHRpb25zLmZpcmVmb3hNdWx0aXBsaWVyO1xuICAgIH1cblxuICAgIGV2dC5kZWx0YVggKj0gb3B0aW9ucy5tb3VzZU11bHRpcGxpZXI7XG4gICAgZXZ0LmRlbHRhWSAqPSBvcHRpb25zLm1vdXNlTXVsdGlwbGllcjtcblxuICAgIHRoaXMuX25vdGlmeShlKTtcbn07XG5cblZpcnR1YWxTY3JvbGwucHJvdG90eXBlLl9vbk1vdXNlV2hlZWwgPSBmdW5jdGlvbihlKSB7XG4gICAgaWYgKHRoaXMub3B0aW9ucy5saW1pdEluZXJ0aWEgJiYgdGhpcy5fbGV0aGFyZ3kuY2hlY2soZSkgPT09IGZhbHNlKSByZXR1cm47XG5cbiAgICB2YXIgZXZ0ID0gdGhpcy5fZXZlbnQ7XG5cbiAgICAvLyBJbiBTYWZhcmksIElFIGFuZCBpbiBDaHJvbWUgaWYgJ3doZWVsJyBpc24ndCBkZWZpbmVkXG4gICAgZXZ0LmRlbHRhWCA9IChlLndoZWVsRGVsdGFYKSA/IGUud2hlZWxEZWx0YVggOiAwO1xuICAgIGV2dC5kZWx0YVkgPSAoZS53aGVlbERlbHRhWSkgPyBlLndoZWVsRGVsdGFZIDogZS53aGVlbERlbHRhO1xuXG4gICAgdGhpcy5fbm90aWZ5KGUpO1xufTtcblxuVmlydHVhbFNjcm9sbC5wcm90b3R5cGUuX29uVG91Y2hTdGFydCA9IGZ1bmN0aW9uKGUpIHtcbiAgICB2YXIgdCA9IChlLnRhcmdldFRvdWNoZXMpID8gZS50YXJnZXRUb3VjaGVzWzBdIDogZTtcbiAgICB0aGlzLnRvdWNoU3RhcnRYID0gdC5wYWdlWDtcbiAgICB0aGlzLnRvdWNoU3RhcnRZID0gdC5wYWdlWTtcbn07XG5cblZpcnR1YWxTY3JvbGwucHJvdG90eXBlLl9vblRvdWNoTW92ZSA9IGZ1bmN0aW9uKGUpIHtcbiAgICB2YXIgb3B0aW9ucyA9IHRoaXMub3B0aW9ucztcbiAgICBpZihvcHRpb25zLnByZXZlbnRUb3VjaFxuICAgICAgICAmJiAhZS50YXJnZXQuY2xhc3NMaXN0LmNvbnRhaW5zKG9wdGlvbnMudW5wcmV2ZW50VG91Y2hDbGFzcykpIHtcbiAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIH1cblxuICAgIHZhciBldnQgPSB0aGlzLl9ldmVudDtcblxuICAgIHZhciB0ID0gKGUudGFyZ2V0VG91Y2hlcykgPyBlLnRhcmdldFRvdWNoZXNbMF0gOiBlO1xuXG4gICAgZXZ0LmRlbHRhWCA9ICh0LnBhZ2VYIC0gdGhpcy50b3VjaFN0YXJ0WCkgKiBvcHRpb25zLnRvdWNoTXVsdGlwbGllcjtcbiAgICBldnQuZGVsdGFZID0gKHQucGFnZVkgLSB0aGlzLnRvdWNoU3RhcnRZKSAqIG9wdGlvbnMudG91Y2hNdWx0aXBsaWVyO1xuXG4gICAgdGhpcy50b3VjaFN0YXJ0WCA9IHQucGFnZVg7XG4gICAgdGhpcy50b3VjaFN0YXJ0WSA9IHQucGFnZVk7XG5cbiAgICB0aGlzLl9ub3RpZnkoZSk7XG59O1xuXG5WaXJ0dWFsU2Nyb2xsLnByb3RvdHlwZS5fb25LZXlEb3duID0gZnVuY3Rpb24oZSkge1xuICAgIHZhciBldnQgPSB0aGlzLl9ldmVudDtcbiAgICBldnQuZGVsdGFYID0gZXZ0LmRlbHRhWSA9IDA7XG4gICAgdmFyIHdpbmRvd0hlaWdodCA9IHdpbmRvdy5pbm5lckhlaWdodCAtIDQwO1xuXG4gICAgc3dpdGNoKGUua2V5Q29kZSkge1xuICAgICAgICBjYXNlIGtleUNvZGVzLkxFRlQ6XG4gICAgICAgIGNhc2Uga2V5Q29kZXMuVVA6XG4gICAgICAgICAgICBldnQuZGVsdGFZID0gdGhpcy5vcHRpb25zLmtleVN0ZXA7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlIGtleUNvZGVzLlJJR0hUOlxuICAgICAgICBjYXNlIGtleUNvZGVzLkRPV046XG4gICAgICAgICAgICBldnQuZGVsdGFZID0gLSB0aGlzLm9wdGlvbnMua2V5U3RlcDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICBlLnNoaWZ0S2V5OlxuICAgICAgICAgICAgZXZ0LmRlbHRhWSA9IHdpbmRvd0hlaWdodDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIGtleUNvZGVzLlNQQUNFOlxuICAgICAgICAgICAgZXZ0LmRlbHRhWSA9IC0gd2luZG93SGVpZ2h0O1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy5fbm90aWZ5KGUpO1xufTtcblxuVmlydHVhbFNjcm9sbC5wcm90b3R5cGUuX2JpbmQgPSBmdW5jdGlvbigpIHtcbiAgICBpZihzdXBwb3J0Lmhhc1doZWVsRXZlbnQpIHRoaXMuZWwuYWRkRXZlbnRMaXN0ZW5lcignd2hlZWwnLCB0aGlzLl9vbldoZWVsLCB0aGlzLmxpc3RlbmVyT3B0aW9ucyk7XG4gICAgaWYoc3VwcG9ydC5oYXNNb3VzZVdoZWVsRXZlbnQpIHRoaXMuZWwuYWRkRXZlbnRMaXN0ZW5lcignbW91c2V3aGVlbCcsIHRoaXMuX29uTW91c2VXaGVlbCwgdGhpcy5saXN0ZW5lck9wdGlvbnMpO1xuXG4gICAgaWYoc3VwcG9ydC5oYXNUb3VjaCAmJiB0aGlzLm9wdGlvbnMudXNlVG91Y2gpIHtcbiAgICAgICAgdGhpcy5lbC5hZGRFdmVudExpc3RlbmVyKCd0b3VjaHN0YXJ0JywgdGhpcy5fb25Ub3VjaFN0YXJ0LCB0aGlzLmxpc3RlbmVyT3B0aW9ucyk7XG4gICAgICAgIHRoaXMuZWwuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2htb3ZlJywgdGhpcy5fb25Ub3VjaE1vdmUsIHRoaXMubGlzdGVuZXJPcHRpb25zKTtcbiAgICB9XG5cbiAgICBpZihzdXBwb3J0Lmhhc1BvaW50ZXIgJiYgc3VwcG9ydC5oYXNUb3VjaFdpbikge1xuICAgICAgICB0aGlzLmJvZHlUb3VjaEFjdGlvbiA9IGRvY3VtZW50LmJvZHkuc3R5bGUubXNUb3VjaEFjdGlvbjtcbiAgICAgICAgZG9jdW1lbnQuYm9keS5zdHlsZS5tc1RvdWNoQWN0aW9uID0gJ25vbmUnO1xuICAgICAgICB0aGlzLmVsLmFkZEV2ZW50TGlzdGVuZXIoJ01TUG9pbnRlckRvd24nLCB0aGlzLl9vblRvdWNoU3RhcnQsIHRydWUpO1xuICAgICAgICB0aGlzLmVsLmFkZEV2ZW50TGlzdGVuZXIoJ01TUG9pbnRlck1vdmUnLCB0aGlzLl9vblRvdWNoTW92ZSwgdHJ1ZSk7XG4gICAgfVxuXG4gICAgaWYoc3VwcG9ydC5oYXNLZXlEb3duICYmIHRoaXMub3B0aW9ucy51c2VLZXlib2FyZCkgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigna2V5ZG93bicsIHRoaXMuX29uS2V5RG93bik7XG59O1xuXG5WaXJ0dWFsU2Nyb2xsLnByb3RvdHlwZS5fdW5iaW5kID0gZnVuY3Rpb24oKSB7XG4gICAgaWYoc3VwcG9ydC5oYXNXaGVlbEV2ZW50KSB0aGlzLmVsLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3doZWVsJywgdGhpcy5fb25XaGVlbCk7XG4gICAgaWYoc3VwcG9ydC5oYXNNb3VzZVdoZWVsRXZlbnQpIHRoaXMuZWwucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2V3aGVlbCcsIHRoaXMuX29uTW91c2VXaGVlbCk7XG5cbiAgICBpZihzdXBwb3J0Lmhhc1RvdWNoKSB7XG4gICAgICAgIHRoaXMuZWwucmVtb3ZlRXZlbnRMaXN0ZW5lcigndG91Y2hzdGFydCcsIHRoaXMuX29uVG91Y2hTdGFydCk7XG4gICAgICAgIHRoaXMuZWwucmVtb3ZlRXZlbnRMaXN0ZW5lcigndG91Y2htb3ZlJywgdGhpcy5fb25Ub3VjaE1vdmUpO1xuICAgIH1cblxuICAgIGlmKHN1cHBvcnQuaGFzUG9pbnRlciAmJiBzdXBwb3J0Lmhhc1RvdWNoV2luKSB7XG4gICAgICAgIGRvY3VtZW50LmJvZHkuc3R5bGUubXNUb3VjaEFjdGlvbiA9IHRoaXMuYm9keVRvdWNoQWN0aW9uO1xuICAgICAgICB0aGlzLmVsLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ01TUG9pbnRlckRvd24nLCB0aGlzLl9vblRvdWNoU3RhcnQsIHRydWUpO1xuICAgICAgICB0aGlzLmVsLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ01TUG9pbnRlck1vdmUnLCB0aGlzLl9vblRvdWNoTW92ZSwgdHJ1ZSk7XG4gICAgfVxuXG4gICAgaWYoc3VwcG9ydC5oYXNLZXlEb3duICYmIHRoaXMub3B0aW9ucy51c2VLZXlib2FyZCkgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcigna2V5ZG93bicsIHRoaXMuX29uS2V5RG93bik7XG59O1xuXG5WaXJ0dWFsU2Nyb2xsLnByb3RvdHlwZS5vbiA9IGZ1bmN0aW9uKGNiLCBjdHgpIHtcbiAgdGhpcy5fZW1pdHRlci5vbihFVlRfSUQsIGNiLCBjdHgpO1xuXG4gIHZhciBldmVudHMgPSB0aGlzLl9lbWl0dGVyLmU7XG4gIGlmIChldmVudHMgJiYgZXZlbnRzW0VWVF9JRF0gJiYgZXZlbnRzW0VWVF9JRF0ubGVuZ3RoID09PSAxKSB0aGlzLl9iaW5kKCk7XG59O1xuXG5WaXJ0dWFsU2Nyb2xsLnByb3RvdHlwZS5vZmYgPSBmdW5jdGlvbihjYiwgY3R4KSB7XG4gIHRoaXMuX2VtaXR0ZXIub2ZmKEVWVF9JRCwgY2IsIGN0eCk7XG5cbiAgdmFyIGV2ZW50cyA9IHRoaXMuX2VtaXR0ZXIuZTtcbiAgaWYgKCFldmVudHNbRVZUX0lEXSB8fCBldmVudHNbRVZUX0lEXS5sZW5ndGggPD0gMCkgdGhpcy5fdW5iaW5kKCk7XG59O1xuXG5WaXJ0dWFsU2Nyb2xsLnByb3RvdHlwZS5yZXNldCA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBldnQgPSB0aGlzLl9ldmVudDtcbiAgICBldnQueCA9IDA7XG4gICAgZXZ0LnkgPSAwO1xufTtcblxuVmlydHVhbFNjcm9sbC5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuX2VtaXR0ZXIub2ZmKCk7XG4gICAgdGhpcy5fdW5iaW5kKCk7XG59O1xuXG5mdW5jdGlvbiBsZXJwKHN0YXJ0LCBlbmQsIGFtdCkge1xuICByZXR1cm4gKDEgLSBhbXQpICogc3RhcnQgKyBhbXQgKiBlbmQ7XG59XG5cbmZ1bmN0aW9uIGdldFRyYW5zbGF0ZShlbCkge1xuICB2YXIgdHJhbnNsYXRlID0ge307XG4gIGlmICghd2luZG93LmdldENvbXB1dGVkU3R5bGUpIHJldHVybjtcbiAgdmFyIHN0eWxlID0gZ2V0Q29tcHV0ZWRTdHlsZShlbCk7XG4gIHZhciB0cmFuc2Zvcm0gPSBzdHlsZS50cmFuc2Zvcm0gfHwgc3R5bGUud2Via2l0VHJhbnNmb3JtIHx8IHN0eWxlLm1velRyYW5zZm9ybTtcbiAgdmFyIG1hdCA9IHRyYW5zZm9ybS5tYXRjaCgvXm1hdHJpeDNkXFwoKC4rKVxcKSQvKTtcblxuICBpZiAobWF0KSB7XG4gICAgdHJhbnNsYXRlLnggPSBtYXQgPyBwYXJzZUZsb2F0KG1hdFsxXS5zcGxpdCgnLCAnKVsxMl0pIDogMDtcbiAgICB0cmFuc2xhdGUueSA9IG1hdCA/IHBhcnNlRmxvYXQobWF0WzFdLnNwbGl0KCcsICcpWzEzXSkgOiAwO1xuICB9IGVsc2Uge1xuICAgIG1hdCA9IHRyYW5zZm9ybS5tYXRjaCgvXm1hdHJpeFxcKCguKylcXCkkLyk7XG4gICAgdHJhbnNsYXRlLnggPSBtYXQgPyBwYXJzZUZsb2F0KG1hdFsxXS5zcGxpdCgnLCAnKVs0XSkgOiAwO1xuICAgIHRyYW5zbGF0ZS55ID0gbWF0ID8gcGFyc2VGbG9hdChtYXRbMV0uc3BsaXQoJywgJylbNV0pIDogMDtcbiAgfVxuXG4gIHJldHVybiB0cmFuc2xhdGU7XG59XG5cbi8qKlxuICogUmV0dXJucyBhbiBhcnJheSBjb250YWluaW5nIGFsbCB0aGUgcGFyZW50IG5vZGVzIG9mIHRoZSBnaXZlbiBub2RlXG4gKiBAcGFyYW0gIHtvYmplY3R9IG5vZGVcbiAqIEByZXR1cm4ge2FycmF5fSBwYXJlbnQgbm9kZXNcbiAqL1xuZnVuY3Rpb24gZ2V0UGFyZW50cyhlbGVtKSB7XG4gIC8vIFNldCB1cCBhIHBhcmVudCBhcnJheVxuICB2YXIgcGFyZW50cyA9IFtdOyAvLyBQdXNoIGVhY2ggcGFyZW50IGVsZW1lbnQgdG8gdGhlIGFycmF5XG5cbiAgZm9yICg7IGVsZW0gJiYgZWxlbSAhPT0gZG9jdW1lbnQ7IGVsZW0gPSBlbGVtLnBhcmVudE5vZGUpIHtcbiAgICBwYXJlbnRzLnB1c2goZWxlbSk7XG4gIH0gLy8gUmV0dXJuIG91ciBwYXJlbnQgYXJyYXlcblxuXG4gIHJldHVybiBwYXJlbnRzO1xufSAvLyBodHRwczovL2dvbWFrZXRoaW5ncy5jb20vaG93LXRvLWdldC10aGUtY2xvc2VzdC1wYXJlbnQtZWxlbWVudC13aXRoLWEtbWF0Y2hpbmctc2VsZWN0b3ItdXNpbmctdmFuaWxsYS1qYXZhc2NyaXB0L1xuXG4vKipcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9ncmUvYmV6aWVyLWVhc2luZ1xuICogQmV6aWVyRWFzaW5nIC0gdXNlIGJlemllciBjdXJ2ZSBmb3IgdHJhbnNpdGlvbiBlYXNpbmcgZnVuY3Rpb25cbiAqIGJ5IEdhw6t0YW4gUmVuYXVkZWF1IDIwMTQgLSAyMDE1IOKAkyBNSVQgTGljZW5zZVxuICovXG5cbi8vIFRoZXNlIHZhbHVlcyBhcmUgZXN0YWJsaXNoZWQgYnkgZW1waXJpY2lzbSB3aXRoIHRlc3RzICh0cmFkZW9mZjogcGVyZm9ybWFuY2UgVlMgcHJlY2lzaW9uKVxudmFyIE5FV1RPTl9JVEVSQVRJT05TID0gNDtcbnZhciBORVdUT05fTUlOX1NMT1BFID0gMC4wMDE7XG52YXIgU1VCRElWSVNJT05fUFJFQ0lTSU9OID0gMC4wMDAwMDAxO1xudmFyIFNVQkRJVklTSU9OX01BWF9JVEVSQVRJT05TID0gMTA7XG5cbnZhciBrU3BsaW5lVGFibGVTaXplID0gMTE7XG52YXIga1NhbXBsZVN0ZXBTaXplID0gMS4wIC8gKGtTcGxpbmVUYWJsZVNpemUgLSAxLjApO1xuXG52YXIgZmxvYXQzMkFycmF5U3VwcG9ydGVkID0gdHlwZW9mIEZsb2F0MzJBcnJheSA9PT0gJ2Z1bmN0aW9uJztcblxuZnVuY3Rpb24gQSAoYUExLCBhQTIpIHsgcmV0dXJuIDEuMCAtIDMuMCAqIGFBMiArIDMuMCAqIGFBMTsgfVxuZnVuY3Rpb24gQiAoYUExLCBhQTIpIHsgcmV0dXJuIDMuMCAqIGFBMiAtIDYuMCAqIGFBMTsgfVxuZnVuY3Rpb24gQyAoYUExKSAgICAgIHsgcmV0dXJuIDMuMCAqIGFBMTsgfVxuXG4vLyBSZXR1cm5zIHgodCkgZ2l2ZW4gdCwgeDEsIGFuZCB4Miwgb3IgeSh0KSBnaXZlbiB0LCB5MSwgYW5kIHkyLlxuZnVuY3Rpb24gY2FsY0JlemllciAoYVQsIGFBMSwgYUEyKSB7IHJldHVybiAoKEEoYUExLCBhQTIpICogYVQgKyBCKGFBMSwgYUEyKSkgKiBhVCArIEMoYUExKSkgKiBhVDsgfVxuXG4vLyBSZXR1cm5zIGR4L2R0IGdpdmVuIHQsIHgxLCBhbmQgeDIsIG9yIGR5L2R0IGdpdmVuIHQsIHkxLCBhbmQgeTIuXG5mdW5jdGlvbiBnZXRTbG9wZSAoYVQsIGFBMSwgYUEyKSB7IHJldHVybiAzLjAgKiBBKGFBMSwgYUEyKSAqIGFUICogYVQgKyAyLjAgKiBCKGFBMSwgYUEyKSAqIGFUICsgQyhhQTEpOyB9XG5cbmZ1bmN0aW9uIGJpbmFyeVN1YmRpdmlkZSAoYVgsIGFBLCBhQiwgbVgxLCBtWDIpIHtcbiAgdmFyIGN1cnJlbnRYLCBjdXJyZW50VCwgaSA9IDA7XG4gIGRvIHtcbiAgICBjdXJyZW50VCA9IGFBICsgKGFCIC0gYUEpIC8gMi4wO1xuICAgIGN1cnJlbnRYID0gY2FsY0JlemllcihjdXJyZW50VCwgbVgxLCBtWDIpIC0gYVg7XG4gICAgaWYgKGN1cnJlbnRYID4gMC4wKSB7XG4gICAgICBhQiA9IGN1cnJlbnRUO1xuICAgIH0gZWxzZSB7XG4gICAgICBhQSA9IGN1cnJlbnRUO1xuICAgIH1cbiAgfSB3aGlsZSAoTWF0aC5hYnMoY3VycmVudFgpID4gU1VCRElWSVNJT05fUFJFQ0lTSU9OICYmICsraSA8IFNVQkRJVklTSU9OX01BWF9JVEVSQVRJT05TKTtcbiAgcmV0dXJuIGN1cnJlbnRUO1xufVxuXG5mdW5jdGlvbiBuZXd0b25SYXBoc29uSXRlcmF0ZSAoYVgsIGFHdWVzc1QsIG1YMSwgbVgyKSB7XG4gZm9yICh2YXIgaSA9IDA7IGkgPCBORVdUT05fSVRFUkFUSU9OUzsgKytpKSB7XG4gICB2YXIgY3VycmVudFNsb3BlID0gZ2V0U2xvcGUoYUd1ZXNzVCwgbVgxLCBtWDIpO1xuICAgaWYgKGN1cnJlbnRTbG9wZSA9PT0gMC4wKSB7XG4gICAgIHJldHVybiBhR3Vlc3NUO1xuICAgfVxuICAgdmFyIGN1cnJlbnRYID0gY2FsY0JlemllcihhR3Vlc3NULCBtWDEsIG1YMikgLSBhWDtcbiAgIGFHdWVzc1QgLT0gY3VycmVudFggLyBjdXJyZW50U2xvcGU7XG4gfVxuIHJldHVybiBhR3Vlc3NUO1xufVxuXG5mdW5jdGlvbiBMaW5lYXJFYXNpbmcgKHgpIHtcbiAgcmV0dXJuIHg7XG59XG5cbnZhciBzcmMkMSA9IGZ1bmN0aW9uIGJlemllciAobVgxLCBtWTEsIG1YMiwgbVkyKSB7XG4gIGlmICghKDAgPD0gbVgxICYmIG1YMSA8PSAxICYmIDAgPD0gbVgyICYmIG1YMiA8PSAxKSkge1xuICAgIHRocm93IG5ldyBFcnJvcignYmV6aWVyIHggdmFsdWVzIG11c3QgYmUgaW4gWzAsIDFdIHJhbmdlJyk7XG4gIH1cblxuICBpZiAobVgxID09PSBtWTEgJiYgbVgyID09PSBtWTIpIHtcbiAgICByZXR1cm4gTGluZWFyRWFzaW5nO1xuICB9XG5cbiAgLy8gUHJlY29tcHV0ZSBzYW1wbGVzIHRhYmxlXG4gIHZhciBzYW1wbGVWYWx1ZXMgPSBmbG9hdDMyQXJyYXlTdXBwb3J0ZWQgPyBuZXcgRmxvYXQzMkFycmF5KGtTcGxpbmVUYWJsZVNpemUpIDogbmV3IEFycmF5KGtTcGxpbmVUYWJsZVNpemUpO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGtTcGxpbmVUYWJsZVNpemU7ICsraSkge1xuICAgIHNhbXBsZVZhbHVlc1tpXSA9IGNhbGNCZXppZXIoaSAqIGtTYW1wbGVTdGVwU2l6ZSwgbVgxLCBtWDIpO1xuICB9XG5cbiAgZnVuY3Rpb24gZ2V0VEZvclggKGFYKSB7XG4gICAgdmFyIGludGVydmFsU3RhcnQgPSAwLjA7XG4gICAgdmFyIGN1cnJlbnRTYW1wbGUgPSAxO1xuICAgIHZhciBsYXN0U2FtcGxlID0ga1NwbGluZVRhYmxlU2l6ZSAtIDE7XG5cbiAgICBmb3IgKDsgY3VycmVudFNhbXBsZSAhPT0gbGFzdFNhbXBsZSAmJiBzYW1wbGVWYWx1ZXNbY3VycmVudFNhbXBsZV0gPD0gYVg7ICsrY3VycmVudFNhbXBsZSkge1xuICAgICAgaW50ZXJ2YWxTdGFydCArPSBrU2FtcGxlU3RlcFNpemU7XG4gICAgfVxuICAgIC0tY3VycmVudFNhbXBsZTtcblxuICAgIC8vIEludGVycG9sYXRlIHRvIHByb3ZpZGUgYW4gaW5pdGlhbCBndWVzcyBmb3IgdFxuICAgIHZhciBkaXN0ID0gKGFYIC0gc2FtcGxlVmFsdWVzW2N1cnJlbnRTYW1wbGVdKSAvIChzYW1wbGVWYWx1ZXNbY3VycmVudFNhbXBsZSArIDFdIC0gc2FtcGxlVmFsdWVzW2N1cnJlbnRTYW1wbGVdKTtcbiAgICB2YXIgZ3Vlc3NGb3JUID0gaW50ZXJ2YWxTdGFydCArIGRpc3QgKiBrU2FtcGxlU3RlcFNpemU7XG5cbiAgICB2YXIgaW5pdGlhbFNsb3BlID0gZ2V0U2xvcGUoZ3Vlc3NGb3JULCBtWDEsIG1YMik7XG4gICAgaWYgKGluaXRpYWxTbG9wZSA+PSBORVdUT05fTUlOX1NMT1BFKSB7XG4gICAgICByZXR1cm4gbmV3dG9uUmFwaHNvbkl0ZXJhdGUoYVgsIGd1ZXNzRm9yVCwgbVgxLCBtWDIpO1xuICAgIH0gZWxzZSBpZiAoaW5pdGlhbFNsb3BlID09PSAwLjApIHtcbiAgICAgIHJldHVybiBndWVzc0ZvclQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBiaW5hcnlTdWJkaXZpZGUoYVgsIGludGVydmFsU3RhcnQsIGludGVydmFsU3RhcnQgKyBrU2FtcGxlU3RlcFNpemUsIG1YMSwgbVgyKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZnVuY3Rpb24gQmV6aWVyRWFzaW5nICh4KSB7XG4gICAgLy8gQmVjYXVzZSBKYXZhU2NyaXB0IG51bWJlciBhcmUgaW1wcmVjaXNlLCB3ZSBzaG91bGQgZ3VhcmFudGVlIHRoZSBleHRyZW1lcyBhcmUgcmlnaHQuXG4gICAgaWYgKHggPT09IDApIHtcbiAgICAgIHJldHVybiAwO1xuICAgIH1cbiAgICBpZiAoeCA9PT0gMSkge1xuICAgICAgcmV0dXJuIDE7XG4gICAgfVxuICAgIHJldHVybiBjYWxjQmV6aWVyKGdldFRGb3JYKHgpLCBtWTEsIG1ZMik7XG4gIH07XG59O1xuXG52YXIga2V5Q29kZXMkMSA9IHtcbiAgTEVGVDogMzcsXG4gIFVQOiAzOCxcbiAgUklHSFQ6IDM5LFxuICBET1dOOiA0MCxcbiAgU1BBQ0U6IDMyLFxuICBUQUI6IDksXG4gIFBBR0VVUDogMzMsXG4gIFBBR0VET1dOOiAzNCxcbiAgSE9NRTogMzYsXG4gIEVORDogMzVcbn07XG5cbnZhciBfZGVmYXVsdCQyID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfQ29yZSkge1xuICBfaW5oZXJpdHMoX2RlZmF1bHQsIF9Db3JlKTtcblxuICB2YXIgX3N1cGVyID0gX2NyZWF0ZVN1cGVyKF9kZWZhdWx0KTtcblxuICBmdW5jdGlvbiBfZGVmYXVsdCgpIHtcbiAgICB2YXIgX3RoaXM7XG5cbiAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge307XG5cbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgX2RlZmF1bHQpO1xuXG4gICAgaWYgKGhpc3Rvcnkuc2Nyb2xsUmVzdG9yYXRpb24pIHtcbiAgICAgIGhpc3Rvcnkuc2Nyb2xsUmVzdG9yYXRpb24gPSAnbWFudWFsJztcbiAgICB9XG5cbiAgICB3aW5kb3cuc2Nyb2xsVG8oMCwgMCk7XG4gICAgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBvcHRpb25zKTtcbiAgICBpZiAoX3RoaXMuaW5lcnRpYSkgX3RoaXMubGVycCA9IF90aGlzLmluZXJ0aWEgKiAwLjE7XG4gICAgX3RoaXMuaXNTY3JvbGxpbmcgPSBmYWxzZTtcbiAgICBfdGhpcy5pc0RyYWdnaW5nU2Nyb2xsYmFyID0gZmFsc2U7XG4gICAgX3RoaXMuaXNUaWNraW5nID0gZmFsc2U7XG4gICAgX3RoaXMuaGFzU2Nyb2xsVGlja2luZyA9IGZhbHNlO1xuICAgIF90aGlzLnBhcmFsbGF4RWxlbWVudHMgPSB7fTtcbiAgICBfdGhpcy5zdG9wID0gZmFsc2U7XG4gICAgX3RoaXMuc2Nyb2xsYmFyQ29udGFpbmVyID0gb3B0aW9ucy5zY3JvbGxiYXJDb250YWluZXI7XG4gICAgX3RoaXMuY2hlY2tLZXkgPSBfdGhpcy5jaGVja0tleS5iaW5kKF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpKTtcbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigna2V5ZG93bicsIF90aGlzLmNoZWNrS2V5LCBmYWxzZSk7XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKF9kZWZhdWx0LCBbe1xuICAgIGtleTogXCJpbml0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGluaXQoKSB7XG4gICAgICB2YXIgX3RoaXMyID0gdGhpcztcblxuICAgICAgdGhpcy5odG1sLmNsYXNzTGlzdC5hZGQodGhpcy5zbW9vdGhDbGFzcyk7XG4gICAgICB0aGlzLmh0bWwuc2V0QXR0cmlidXRlKFwiZGF0YS1cIi5jb25jYXQodGhpcy5uYW1lLCBcIi1kaXJlY3Rpb25cIiksIHRoaXMuZGlyZWN0aW9uKTtcbiAgICAgIHRoaXMuaW5zdGFuY2UgPSBfb2JqZWN0U3ByZWFkMih7XG4gICAgICAgIGRlbHRhOiB7XG4gICAgICAgICAgeDogdGhpcy5pbml0UG9zaXRpb24ueCxcbiAgICAgICAgICB5OiB0aGlzLmluaXRQb3NpdGlvbi55XG4gICAgICAgIH0sXG4gICAgICAgIHNjcm9sbDoge1xuICAgICAgICAgIHg6IHRoaXMuaW5pdFBvc2l0aW9uLngsXG4gICAgICAgICAgeTogdGhpcy5pbml0UG9zaXRpb24ueVxuICAgICAgICB9XG4gICAgICB9LCB0aGlzLmluc3RhbmNlKTtcbiAgICAgIHRoaXMudnMgPSBuZXcgc3JjKHtcbiAgICAgICAgZWw6IHRoaXMuc2Nyb2xsRnJvbUFueXdoZXJlID8gZG9jdW1lbnQgOiB0aGlzLmVsLFxuICAgICAgICBtb3VzZU11bHRpcGxpZXI6IG5hdmlnYXRvci5wbGF0Zm9ybS5pbmRleE9mKCdXaW4nKSA+IC0xID8gMSA6IDAuNCxcbiAgICAgICAgZmlyZWZveE11bHRpcGxpZXI6IHRoaXMuZmlyZWZveE11bHRpcGxpZXIsXG4gICAgICAgIHRvdWNoTXVsdGlwbGllcjogdGhpcy50b3VjaE11bHRpcGxpZXIsXG4gICAgICAgIHVzZUtleWJvYXJkOiBmYWxzZSxcbiAgICAgICAgcGFzc2l2ZTogdHJ1ZVxuICAgICAgfSk7XG4gICAgICB0aGlzLnZzLm9uKGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIGlmIChfdGhpczIuc3RvcCkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghX3RoaXMyLmlzRHJhZ2dpbmdTY3JvbGxiYXIpIHtcbiAgICAgICAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgX3RoaXMyLnVwZGF0ZURlbHRhKGUpO1xuXG4gICAgICAgICAgICBpZiAoIV90aGlzMi5pc1Njcm9sbGluZykgX3RoaXMyLnN0YXJ0U2Nyb2xsaW5nKCk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgdGhpcy5zZXRTY3JvbGxMaW1pdCgpO1xuICAgICAgdGhpcy5pbml0U2Nyb2xsQmFyKCk7XG4gICAgICB0aGlzLmFkZFNlY3Rpb25zKCk7XG4gICAgICB0aGlzLmFkZEVsZW1lbnRzKCk7XG4gICAgICB0aGlzLmNoZWNrU2Nyb2xsKHRydWUpO1xuICAgICAgdGhpcy50cmFuc2Zvcm1FbGVtZW50cyh0cnVlLCB0cnVlKTtcblxuICAgICAgX2dldChfZ2V0UHJvdG90eXBlT2YoX2RlZmF1bHQucHJvdG90eXBlKSwgXCJpbml0XCIsIHRoaXMpLmNhbGwodGhpcyk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInNldFNjcm9sbExpbWl0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNldFNjcm9sbExpbWl0KCkge1xuICAgICAgdGhpcy5pbnN0YW5jZS5saW1pdC55ID0gdGhpcy5lbC5vZmZzZXRIZWlnaHQgLSB0aGlzLndpbmRvd0hlaWdodDtcblxuICAgICAgaWYgKHRoaXMuZGlyZWN0aW9uID09PSAnaG9yaXpvbnRhbCcpIHtcbiAgICAgICAgdmFyIHRvdGFsV2lkdGggPSAwO1xuICAgICAgICB2YXIgbm9kZXMgPSB0aGlzLmVsLmNoaWxkcmVuO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbm9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICB0b3RhbFdpZHRoICs9IG5vZGVzW2ldLm9mZnNldFdpZHRoO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5pbnN0YW5jZS5saW1pdC54ID0gdG90YWxXaWR0aCAtIHRoaXMud2luZG93V2lkdGg7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInN0YXJ0U2Nyb2xsaW5nXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHN0YXJ0U2Nyb2xsaW5nKCkge1xuICAgICAgdGhpcy5zdGFydFNjcm9sbFRzID0gRGF0ZS5ub3coKTsgLy8gUmVjb3JkIHRpbWVzdGFtcFxuXG4gICAgICB0aGlzLmlzU2Nyb2xsaW5nID0gdHJ1ZTtcbiAgICAgIHRoaXMuY2hlY2tTY3JvbGwoKTtcbiAgICAgIHRoaXMuaHRtbC5jbGFzc0xpc3QuYWRkKHRoaXMuc2Nyb2xsaW5nQ2xhc3MpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJzdG9wU2Nyb2xsaW5nXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHN0b3BTY3JvbGxpbmcoKSB7XG4gICAgICBjYW5jZWxBbmltYXRpb25GcmFtZSh0aGlzLmNoZWNrU2Nyb2xsUmFmKTsgLy8gUHJldmVudCBjaGVja1Njcm9sbCB0byBjb250aW51ZSBsb29waW5nXG4gICAgICAvL1BldmVudCBzY3JvbGxiYXIgZ2xpdGNoL2xvY2tpbmdcblxuICAgICAgdGhpcy5zdGFydFNjcm9sbFRzID0gdW5kZWZpbmVkO1xuXG4gICAgICBpZiAodGhpcy5zY3JvbGxUb1JhZikge1xuICAgICAgICBjYW5jZWxBbmltYXRpb25GcmFtZSh0aGlzLnNjcm9sbFRvUmFmKTtcbiAgICAgICAgdGhpcy5zY3JvbGxUb1JhZiA9IG51bGw7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuaXNTY3JvbGxpbmcgPSBmYWxzZTtcbiAgICAgIHRoaXMuaW5zdGFuY2Uuc2Nyb2xsLnkgPSBNYXRoLnJvdW5kKHRoaXMuaW5zdGFuY2Uuc2Nyb2xsLnkpO1xuICAgICAgdGhpcy5odG1sLmNsYXNzTGlzdC5yZW1vdmUodGhpcy5zY3JvbGxpbmdDbGFzcyk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImNoZWNrS2V5XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNoZWNrS2V5KGUpIHtcbiAgICAgIHZhciBfdGhpczMgPSB0aGlzO1xuXG4gICAgICBpZiAodGhpcy5zdG9wKSB7XG4gICAgICAgIC8vIElmIHdlIGFyZSBzdG9wcGVkLCB3ZSBkb24ndCB3YW50IGFueSBzY3JvbGwgdG8gb2NjdXIgYmVjYXVzZSBvZiBhIGtleXByZXNzXG4gICAgICAgIC8vIFByZXZlbnQgdGFiIHRvIHNjcm9sbCB0byBhY3RpdmVFbGVtZW50XG4gICAgICAgIGlmIChlLmtleUNvZGUgPT0ga2V5Q29kZXMkMS5UQUIpIHtcbiAgICAgICAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgLy8gTWFrZSBzdXJlIG5hdGl2ZSBzY3JvbGwgaXMgYWx3YXlzIGF0IHRvcCBvZiBwYWdlXG4gICAgICAgICAgICBfdGhpczMuaHRtbC5zY3JvbGxUb3AgPSAwO1xuICAgICAgICAgICAgZG9jdW1lbnQuYm9keS5zY3JvbGxUb3AgPSAwO1xuICAgICAgICAgICAgX3RoaXMzLmh0bWwuc2Nyb2xsTGVmdCA9IDA7XG4gICAgICAgICAgICBkb2N1bWVudC5ib2R5LnNjcm9sbExlZnQgPSAwO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBzd2l0Y2ggKGUua2V5Q29kZSkge1xuICAgICAgICBjYXNlIGtleUNvZGVzJDEuVEFCOlxuICAgICAgICAgIC8vIERvIG5vdCByZW1vdmUgdGhlIFJBRlxuICAgICAgICAgIC8vIEl0IGFsbG93cyB0byBvdmVycmlkZSB0aGUgYnJvd3NlcidzIG5hdGl2ZSBzY3JvbGxUbywgd2hpY2ggaXMgZXNzZW50aWFsXG4gICAgICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIC8vIE1ha2Ugc3VyZSBuYXRpdmUgc2Nyb2xsIGlzIGFsd2F5cyBhdCB0b3Agb2YgcGFnZVxuICAgICAgICAgICAgX3RoaXMzLmh0bWwuc2Nyb2xsVG9wID0gMDtcbiAgICAgICAgICAgIGRvY3VtZW50LmJvZHkuc2Nyb2xsVG9wID0gMDtcbiAgICAgICAgICAgIF90aGlzMy5odG1sLnNjcm9sbExlZnQgPSAwO1xuICAgICAgICAgICAgZG9jdW1lbnQuYm9keS5zY3JvbGxMZWZ0ID0gMDsgLy8gUmVxdWVzdCBzY3JvbGxUbyBvbiB0aGUgZm9jdXNlZEVsZW1lbnQsIHB1dHRpbmcgaXQgYXQgdGhlIGNlbnRlciBvZiB0aGUgc2NyZWVuXG5cbiAgICAgICAgICAgIF90aGlzMy5zY3JvbGxUbyhkb2N1bWVudC5hY3RpdmVFbGVtZW50LCB7XG4gICAgICAgICAgICAgIG9mZnNldDogLXdpbmRvdy5pbm5lckhlaWdodCAvIDJcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2Uga2V5Q29kZXMkMS5VUDpcbiAgICAgICAgICBpZiAodGhpcy5pc0FjdGl2ZUVsZW1lbnRTY3JvbGxTZW5zaXRpdmUoKSkge1xuICAgICAgICAgICAgdGhpcy5pbnN0YW5jZS5kZWx0YVt0aGlzLmRpcmVjdGlvbkF4aXNdIC09IDI0MDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlIGtleUNvZGVzJDEuRE9XTjpcbiAgICAgICAgICBpZiAodGhpcy5pc0FjdGl2ZUVsZW1lbnRTY3JvbGxTZW5zaXRpdmUoKSkge1xuICAgICAgICAgICAgdGhpcy5pbnN0YW5jZS5kZWx0YVt0aGlzLmRpcmVjdGlvbkF4aXNdICs9IDI0MDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlIGtleUNvZGVzJDEuUEFHRVVQOlxuICAgICAgICAgIHRoaXMuaW5zdGFuY2UuZGVsdGFbdGhpcy5kaXJlY3Rpb25BeGlzXSAtPSB3aW5kb3cuaW5uZXJIZWlnaHQ7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSBrZXlDb2RlcyQxLlBBR0VET1dOOlxuICAgICAgICAgIHRoaXMuaW5zdGFuY2UuZGVsdGFbdGhpcy5kaXJlY3Rpb25BeGlzXSArPSB3aW5kb3cuaW5uZXJIZWlnaHQ7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSBrZXlDb2RlcyQxLkhPTUU6XG4gICAgICAgICAgdGhpcy5pbnN0YW5jZS5kZWx0YVt0aGlzLmRpcmVjdGlvbkF4aXNdIC09IHRoaXMuaW5zdGFuY2UubGltaXRbdGhpcy5kaXJlY3Rpb25BeGlzXTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlIGtleUNvZGVzJDEuRU5EOlxuICAgICAgICAgIHRoaXMuaW5zdGFuY2UuZGVsdGFbdGhpcy5kaXJlY3Rpb25BeGlzXSArPSB0aGlzLmluc3RhbmNlLmxpbWl0W3RoaXMuZGlyZWN0aW9uQXhpc107XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSBrZXlDb2RlcyQxLlNQQUNFOlxuICAgICAgICAgIGlmICh0aGlzLmlzQWN0aXZlRWxlbWVudFNjcm9sbFNlbnNpdGl2ZSgpKSB7XG4gICAgICAgICAgICBpZiAoZS5zaGlmdEtleSkge1xuICAgICAgICAgICAgICB0aGlzLmluc3RhbmNlLmRlbHRhW3RoaXMuZGlyZWN0aW9uQXhpc10gLT0gd2luZG93LmlubmVySGVpZ2h0O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgdGhpcy5pbnN0YW5jZS5kZWx0YVt0aGlzLmRpcmVjdGlvbkF4aXNdICs9IHdpbmRvdy5pbm5lckhlaWdodDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMuaW5zdGFuY2UuZGVsdGFbdGhpcy5kaXJlY3Rpb25BeGlzXSA8IDApIHRoaXMuaW5zdGFuY2UuZGVsdGFbdGhpcy5kaXJlY3Rpb25BeGlzXSA9IDA7XG4gICAgICBpZiAodGhpcy5pbnN0YW5jZS5kZWx0YVt0aGlzLmRpcmVjdGlvbkF4aXNdID4gdGhpcy5pbnN0YW5jZS5saW1pdFt0aGlzLmRpcmVjdGlvbkF4aXNdKSB0aGlzLmluc3RhbmNlLmRlbHRhW3RoaXMuZGlyZWN0aW9uQXhpc10gPSB0aGlzLmluc3RhbmNlLmxpbWl0W3RoaXMuZGlyZWN0aW9uQXhpc107XG4gICAgICB0aGlzLnN0b3BTY3JvbGxpbmcoKTsgLy8gU3RvcCBhbnkgbW92ZW1lbnQsIGFsbG93cyB0byBraWxsIGFueSBvdGhlciBgc2Nyb2xsVG9gIHN0aWxsIGhhcHBlbmluZ1xuXG4gICAgICB0aGlzLmlzU2Nyb2xsaW5nID0gdHJ1ZTtcbiAgICAgIHRoaXMuY2hlY2tTY3JvbGwoKTtcbiAgICAgIHRoaXMuaHRtbC5jbGFzc0xpc3QuYWRkKHRoaXMuc2Nyb2xsaW5nQ2xhc3MpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJpc0FjdGl2ZUVsZW1lbnRTY3JvbGxTZW5zaXRpdmVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaXNBY3RpdmVFbGVtZW50U2Nyb2xsU2Vuc2l0aXZlKCkge1xuICAgICAgcmV0dXJuICEoZG9jdW1lbnQuYWN0aXZlRWxlbWVudCBpbnN0YW5jZW9mIEhUTUxJbnB1dEVsZW1lbnQpICYmICEoZG9jdW1lbnQuYWN0aXZlRWxlbWVudCBpbnN0YW5jZW9mIEhUTUxUZXh0QXJlYUVsZW1lbnQpICYmICEoZG9jdW1lbnQuYWN0aXZlRWxlbWVudCBpbnN0YW5jZW9mIEhUTUxCdXR0b25FbGVtZW50KSAmJiAhKGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQgaW5zdGFuY2VvZiBIVE1MU2VsZWN0RWxlbWVudCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImNoZWNrU2Nyb2xsXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNoZWNrU2Nyb2xsKCkge1xuICAgICAgdmFyIF90aGlzNCA9IHRoaXM7XG5cbiAgICAgIHZhciBmb3JjZWQgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IGZhbHNlO1xuXG4gICAgICBpZiAoZm9yY2VkIHx8IHRoaXMuaXNTY3JvbGxpbmcgfHwgdGhpcy5pc0RyYWdnaW5nU2Nyb2xsYmFyKSB7XG4gICAgICAgIGlmICghdGhpcy5oYXNTY3JvbGxUaWNraW5nKSB7XG4gICAgICAgICAgdGhpcy5jaGVja1Njcm9sbFJhZiA9IHJlcXVlc3RBbmltYXRpb25GcmFtZShmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gX3RoaXM0LmNoZWNrU2Nyb2xsKCk7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgdGhpcy5oYXNTY3JvbGxUaWNraW5nID0gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMudXBkYXRlU2Nyb2xsKCk7XG4gICAgICAgIHZhciBkaXN0YW5jZSA9IE1hdGguYWJzKHRoaXMuaW5zdGFuY2UuZGVsdGFbdGhpcy5kaXJlY3Rpb25BeGlzXSAtIHRoaXMuaW5zdGFuY2Uuc2Nyb2xsW3RoaXMuZGlyZWN0aW9uQXhpc10pO1xuICAgICAgICB2YXIgdGltZVNpbmNlU3RhcnQgPSBEYXRlLm5vdygpIC0gdGhpcy5zdGFydFNjcm9sbFRzOyAvLyBHZXQgdGhlIHRpbWUgc2luY2UgdGhlIHNjcm9sbCB3YXMgc3RhcnRlZDogdGhlIHNjcm9sbCBjYW4gYmUgc3RvcHBlZCBhZ2FpbiBvbmx5IHBhc3QgMTAwbXNcblxuICAgICAgICBpZiAoIXRoaXMuYW5pbWF0aW5nU2Nyb2xsICYmIHRpbWVTaW5jZVN0YXJ0ID4gMTAwICYmIChkaXN0YW5jZSA8IDAuNSAmJiB0aGlzLmluc3RhbmNlLmRlbHRhW3RoaXMuZGlyZWN0aW9uQXhpc10gIT0gMCB8fCBkaXN0YW5jZSA8IDAuNSAmJiB0aGlzLmluc3RhbmNlLmRlbHRhW3RoaXMuZGlyZWN0aW9uQXhpc10gPT0gMCkpIHtcbiAgICAgICAgICB0aGlzLnN0b3BTY3JvbGxpbmcoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIE9iamVjdC5lbnRyaWVzKHRoaXMuc2VjdGlvbnMpLmZvckVhY2goZnVuY3Rpb24gKF9yZWYpIHtcbiAgICAgICAgICB2YXIgX3JlZjIgPSBfc2xpY2VkVG9BcnJheShfcmVmLCAyKSxcbiAgICAgICAgICAgICAgaSA9IF9yZWYyWzBdLFxuICAgICAgICAgICAgICBzZWN0aW9uID0gX3JlZjJbMV07XG5cbiAgICAgICAgICBpZiAoc2VjdGlvbi5wZXJzaXN0ZW50IHx8IF90aGlzNC5pbnN0YW5jZS5zY3JvbGxbX3RoaXM0LmRpcmVjdGlvbkF4aXNdID4gc2VjdGlvbi5vZmZzZXRbX3RoaXM0LmRpcmVjdGlvbkF4aXNdICYmIF90aGlzNC5pbnN0YW5jZS5zY3JvbGxbX3RoaXM0LmRpcmVjdGlvbkF4aXNdIDwgc2VjdGlvbi5saW1pdFtfdGhpczQuZGlyZWN0aW9uQXhpc10pIHtcbiAgICAgICAgICAgIGlmIChfdGhpczQuZGlyZWN0aW9uID09PSAnaG9yaXpvbnRhbCcpIHtcbiAgICAgICAgICAgICAgX3RoaXM0LnRyYW5zZm9ybShzZWN0aW9uLmVsLCAtX3RoaXM0Lmluc3RhbmNlLnNjcm9sbFtfdGhpczQuZGlyZWN0aW9uQXhpc10sIDApO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgX3RoaXM0LnRyYW5zZm9ybShzZWN0aW9uLmVsLCAwLCAtX3RoaXM0Lmluc3RhbmNlLnNjcm9sbFtfdGhpczQuZGlyZWN0aW9uQXhpc10pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoIXNlY3Rpb24uaW5WaWV3KSB7XG4gICAgICAgICAgICAgIHNlY3Rpb24uaW5WaWV3ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgc2VjdGlvbi5lbC5zdHlsZS5vcGFjaXR5ID0gMTtcbiAgICAgICAgICAgICAgc2VjdGlvbi5lbC5zdHlsZS5wb2ludGVyRXZlbnRzID0gJ2FsbCc7XG4gICAgICAgICAgICAgIHNlY3Rpb24uZWwuc2V0QXR0cmlidXRlKFwiZGF0YS1cIi5jb25jYXQoX3RoaXM0Lm5hbWUsIFwiLXNlY3Rpb24taW52aWV3XCIpLCAnJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmIChzZWN0aW9uLmluVmlldyB8fCBmb3JjZWQpIHtcbiAgICAgICAgICAgICAgc2VjdGlvbi5pblZpZXcgPSBmYWxzZTtcbiAgICAgICAgICAgICAgc2VjdGlvbi5lbC5zdHlsZS5vcGFjaXR5ID0gMDtcbiAgICAgICAgICAgICAgc2VjdGlvbi5lbC5zdHlsZS5wb2ludGVyRXZlbnRzID0gJ25vbmUnO1xuICAgICAgICAgICAgICBzZWN0aW9uLmVsLnJlbW92ZUF0dHJpYnV0ZShcImRhdGEtXCIuY29uY2F0KF90aGlzNC5uYW1lLCBcIi1zZWN0aW9uLWludmlld1wiKSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIF90aGlzNC50cmFuc2Zvcm0oc2VjdGlvbi5lbCwgMCwgMCk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICBpZiAodGhpcy5nZXREaXJlY3Rpb24pIHtcbiAgICAgICAgICB0aGlzLmFkZERpcmVjdGlvbigpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuZ2V0U3BlZWQpIHtcbiAgICAgICAgICB0aGlzLmFkZFNwZWVkKCk7XG4gICAgICAgICAgdGhpcy5zcGVlZFRzID0gRGF0ZS5ub3coKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuZGV0ZWN0RWxlbWVudHMoKTtcbiAgICAgICAgdGhpcy50cmFuc2Zvcm1FbGVtZW50cygpO1xuXG4gICAgICAgIGlmICh0aGlzLmhhc1Njcm9sbGJhcikge1xuICAgICAgICAgIHZhciBzY3JvbGxCYXJUcmFuc2xhdGlvbiA9IHRoaXMuaW5zdGFuY2Uuc2Nyb2xsW3RoaXMuZGlyZWN0aW9uQXhpc10gLyB0aGlzLmluc3RhbmNlLmxpbWl0W3RoaXMuZGlyZWN0aW9uQXhpc10gKiB0aGlzLnNjcm9sbEJhckxpbWl0W3RoaXMuZGlyZWN0aW9uQXhpc107XG5cbiAgICAgICAgICBpZiAodGhpcy5kaXJlY3Rpb24gPT09ICdob3Jpem9udGFsJykge1xuICAgICAgICAgICAgdGhpcy50cmFuc2Zvcm0odGhpcy5zY3JvbGxiYXJUaHVtYiwgc2Nyb2xsQmFyVHJhbnNsYXRpb24sIDApO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnRyYW5zZm9ybSh0aGlzLnNjcm9sbGJhclRodW1iLCAwLCBzY3JvbGxCYXJUcmFuc2xhdGlvbik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgX2dldChfZ2V0UHJvdG90eXBlT2YoX2RlZmF1bHQucHJvdG90eXBlKSwgXCJjaGVja1Njcm9sbFwiLCB0aGlzKS5jYWxsKHRoaXMpO1xuXG4gICAgICAgIHRoaXMuaGFzU2Nyb2xsVGlja2luZyA9IGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJyZXNpemVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVzaXplKCkge1xuICAgICAgdGhpcy53aW5kb3dIZWlnaHQgPSB3aW5kb3cuaW5uZXJIZWlnaHQ7XG4gICAgICB0aGlzLndpbmRvd1dpZHRoID0gd2luZG93LmlubmVyV2lkdGg7XG4gICAgICB0aGlzLmNoZWNrQ29udGV4dCgpO1xuICAgICAgdGhpcy53aW5kb3dNaWRkbGUgPSB7XG4gICAgICAgIHg6IHRoaXMud2luZG93V2lkdGggLyAyLFxuICAgICAgICB5OiB0aGlzLndpbmRvd0hlaWdodCAvIDJcbiAgICAgIH07XG4gICAgICB0aGlzLnVwZGF0ZSgpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJ1cGRhdGVEZWx0YVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB1cGRhdGVEZWx0YShlKSB7XG4gICAgICB2YXIgZGVsdGE7XG4gICAgICB2YXIgZ2VzdHVyZURpcmVjdGlvbiA9IHRoaXNbdGhpcy5jb250ZXh0XSAmJiB0aGlzW3RoaXMuY29udGV4dF0uZ2VzdHVyZURpcmVjdGlvbiA/IHRoaXNbdGhpcy5jb250ZXh0XS5nZXN0dXJlRGlyZWN0aW9uIDogdGhpcy5nZXN0dXJlRGlyZWN0aW9uO1xuXG4gICAgICBpZiAoZ2VzdHVyZURpcmVjdGlvbiA9PT0gJ2JvdGgnKSB7XG4gICAgICAgIGRlbHRhID0gZS5kZWx0YVggKyBlLmRlbHRhWTtcbiAgICAgIH0gZWxzZSBpZiAoZ2VzdHVyZURpcmVjdGlvbiA9PT0gJ3ZlcnRpY2FsJykge1xuICAgICAgICBkZWx0YSA9IGUuZGVsdGFZO1xuICAgICAgfSBlbHNlIGlmIChnZXN0dXJlRGlyZWN0aW9uID09PSAnaG9yaXpvbnRhbCcpIHtcbiAgICAgICAgZGVsdGEgPSBlLmRlbHRhWDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRlbHRhID0gZS5kZWx0YVk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuaW5zdGFuY2UuZGVsdGFbdGhpcy5kaXJlY3Rpb25BeGlzXSAtPSBkZWx0YSAqIHRoaXMubXVsdGlwbGllcjtcbiAgICAgIGlmICh0aGlzLmluc3RhbmNlLmRlbHRhW3RoaXMuZGlyZWN0aW9uQXhpc10gPCAwKSB0aGlzLmluc3RhbmNlLmRlbHRhW3RoaXMuZGlyZWN0aW9uQXhpc10gPSAwO1xuICAgICAgaWYgKHRoaXMuaW5zdGFuY2UuZGVsdGFbdGhpcy5kaXJlY3Rpb25BeGlzXSA+IHRoaXMuaW5zdGFuY2UubGltaXRbdGhpcy5kaXJlY3Rpb25BeGlzXSkgdGhpcy5pbnN0YW5jZS5kZWx0YVt0aGlzLmRpcmVjdGlvbkF4aXNdID0gdGhpcy5pbnN0YW5jZS5saW1pdFt0aGlzLmRpcmVjdGlvbkF4aXNdO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJ1cGRhdGVTY3JvbGxcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdXBkYXRlU2Nyb2xsKGUpIHtcbiAgICAgIGlmICh0aGlzLmlzU2Nyb2xsaW5nIHx8IHRoaXMuaXNEcmFnZ2luZ1Njcm9sbGJhcikge1xuICAgICAgICB0aGlzLmluc3RhbmNlLnNjcm9sbFt0aGlzLmRpcmVjdGlvbkF4aXNdID0gbGVycCh0aGlzLmluc3RhbmNlLnNjcm9sbFt0aGlzLmRpcmVjdGlvbkF4aXNdLCB0aGlzLmluc3RhbmNlLmRlbHRhW3RoaXMuZGlyZWN0aW9uQXhpc10sIHRoaXMubGVycCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAodGhpcy5pbnN0YW5jZS5zY3JvbGxbdGhpcy5kaXJlY3Rpb25BeGlzXSA+IHRoaXMuaW5zdGFuY2UubGltaXRbdGhpcy5kaXJlY3Rpb25BeGlzXSkge1xuICAgICAgICAgIHRoaXMuc2V0U2Nyb2xsKHRoaXMuaW5zdGFuY2Uuc2Nyb2xsW3RoaXMuZGlyZWN0aW9uQXhpc10sIHRoaXMuaW5zdGFuY2UubGltaXRbdGhpcy5kaXJlY3Rpb25BeGlzXSk7XG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5pbnN0YW5jZS5zY3JvbGwueSA8IDApIHtcbiAgICAgICAgICB0aGlzLnNldFNjcm9sbCh0aGlzLmluc3RhbmNlLnNjcm9sbFt0aGlzLmRpcmVjdGlvbkF4aXNdLCAwKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLnNldFNjcm9sbCh0aGlzLmluc3RhbmNlLnNjcm9sbFt0aGlzLmRpcmVjdGlvbkF4aXNdLCB0aGlzLmluc3RhbmNlLmRlbHRhW3RoaXMuZGlyZWN0aW9uQXhpc10pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImFkZERpcmVjdGlvblwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhZGREaXJlY3Rpb24oKSB7XG4gICAgICBpZiAodGhpcy5pbnN0YW5jZS5kZWx0YS55ID4gdGhpcy5pbnN0YW5jZS5zY3JvbGwueSkge1xuICAgICAgICBpZiAodGhpcy5pbnN0YW5jZS5kaXJlY3Rpb24gIT09ICdkb3duJykge1xuICAgICAgICAgIHRoaXMuaW5zdGFuY2UuZGlyZWN0aW9uID0gJ2Rvd24nO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHRoaXMuaW5zdGFuY2UuZGVsdGEueSA8IHRoaXMuaW5zdGFuY2Uuc2Nyb2xsLnkpIHtcbiAgICAgICAgaWYgKHRoaXMuaW5zdGFuY2UuZGlyZWN0aW9uICE9PSAndXAnKSB7XG4gICAgICAgICAgdGhpcy5pbnN0YW5jZS5kaXJlY3Rpb24gPSAndXAnO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLmluc3RhbmNlLmRlbHRhLnggPiB0aGlzLmluc3RhbmNlLnNjcm9sbC54KSB7XG4gICAgICAgIGlmICh0aGlzLmluc3RhbmNlLmRpcmVjdGlvbiAhPT0gJ3JpZ2h0Jykge1xuICAgICAgICAgIHRoaXMuaW5zdGFuY2UuZGlyZWN0aW9uID0gJ3JpZ2h0JztcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmICh0aGlzLmluc3RhbmNlLmRlbHRhLnggPCB0aGlzLmluc3RhbmNlLnNjcm9sbC54KSB7XG4gICAgICAgIGlmICh0aGlzLmluc3RhbmNlLmRpcmVjdGlvbiAhPT0gJ2xlZnQnKSB7XG4gICAgICAgICAgdGhpcy5pbnN0YW5jZS5kaXJlY3Rpb24gPSAnbGVmdCc7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiYWRkU3BlZWRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gYWRkU3BlZWQoKSB7XG4gICAgICBpZiAodGhpcy5pbnN0YW5jZS5kZWx0YVt0aGlzLmRpcmVjdGlvbkF4aXNdICE9IHRoaXMuaW5zdGFuY2Uuc2Nyb2xsW3RoaXMuZGlyZWN0aW9uQXhpc10pIHtcbiAgICAgICAgdGhpcy5pbnN0YW5jZS5zcGVlZCA9ICh0aGlzLmluc3RhbmNlLmRlbHRhW3RoaXMuZGlyZWN0aW9uQXhpc10gLSB0aGlzLmluc3RhbmNlLnNjcm9sbFt0aGlzLmRpcmVjdGlvbkF4aXNdKSAvIE1hdGgubWF4KDEsIERhdGUubm93KCkgLSB0aGlzLnNwZWVkVHMpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5pbnN0YW5jZS5zcGVlZCA9IDA7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImluaXRTY3JvbGxCYXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaW5pdFNjcm9sbEJhcigpIHtcbiAgICAgIHRoaXMuc2Nyb2xsYmFyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3BhbicpO1xuICAgICAgdGhpcy5zY3JvbGxiYXJUaHVtYiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NwYW4nKTtcbiAgICAgIHRoaXMuc2Nyb2xsYmFyLmNsYXNzTGlzdC5hZGQoXCJcIi5jb25jYXQodGhpcy5zY3JvbGxiYXJDbGFzcykpO1xuICAgICAgdGhpcy5zY3JvbGxiYXJUaHVtYi5jbGFzc0xpc3QuYWRkKFwiXCIuY29uY2F0KHRoaXMuc2Nyb2xsYmFyQ2xhc3MsIFwiX3RodW1iXCIpKTtcbiAgICAgIHRoaXMuc2Nyb2xsYmFyLmFwcGVuZCh0aGlzLnNjcm9sbGJhclRodW1iKTtcblxuICAgICAgaWYgKHRoaXMuc2Nyb2xsYmFyQ29udGFpbmVyKSB7XG4gICAgICAgIHRoaXMuc2Nyb2xsYmFyQ29udGFpbmVyLmFwcGVuZCh0aGlzLnNjcm9sbGJhcik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkb2N1bWVudC5ib2R5LmFwcGVuZCh0aGlzLnNjcm9sbGJhcik7XG4gICAgICB9IC8vIFNjcm9sbGJhciBFdmVudHNcblxuXG4gICAgICB0aGlzLmdldFNjcm9sbEJhciA9IHRoaXMuZ2V0U2Nyb2xsQmFyLmJpbmQodGhpcyk7XG4gICAgICB0aGlzLnJlbGVhc2VTY3JvbGxCYXIgPSB0aGlzLnJlbGVhc2VTY3JvbGxCYXIuYmluZCh0aGlzKTtcbiAgICAgIHRoaXMubW92ZVNjcm9sbEJhciA9IHRoaXMubW92ZVNjcm9sbEJhci5iaW5kKHRoaXMpO1xuICAgICAgdGhpcy5zY3JvbGxiYXJUaHVtYi5hZGRFdmVudExpc3RlbmVyKCdtb3VzZWRvd24nLCB0aGlzLmdldFNjcm9sbEJhcik7XG4gICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignbW91c2V1cCcsIHRoaXMucmVsZWFzZVNjcm9sbEJhcik7XG4gICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vtb3ZlJywgdGhpcy5tb3ZlU2Nyb2xsQmFyKTsgLy8gU2V0IHNjcm9sbGJhciB2YWx1ZXNcblxuICAgICAgdGhpcy5oYXNTY3JvbGxiYXIgPSBmYWxzZTtcblxuICAgICAgaWYgKHRoaXMuZGlyZWN0aW9uID09ICdob3Jpem9udGFsJykge1xuICAgICAgICBpZiAodGhpcy5pbnN0YW5jZS5saW1pdC54ICsgdGhpcy53aW5kb3dXaWR0aCA8PSB0aGlzLndpbmRvd1dpZHRoKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAodGhpcy5pbnN0YW5jZS5saW1pdC55ICsgdGhpcy53aW5kb3dIZWlnaHQgPD0gdGhpcy53aW5kb3dIZWlnaHQpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdGhpcy5oYXNTY3JvbGxiYXIgPSB0cnVlO1xuICAgICAgdGhpcy5zY3JvbGxiYXJCQ1IgPSB0aGlzLnNjcm9sbGJhci5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgIHRoaXMuc2Nyb2xsYmFySGVpZ2h0ID0gdGhpcy5zY3JvbGxiYXJCQ1IuaGVpZ2h0O1xuICAgICAgdGhpcy5zY3JvbGxiYXJXaWR0aCA9IHRoaXMuc2Nyb2xsYmFyQkNSLndpZHRoO1xuXG4gICAgICBpZiAodGhpcy5kaXJlY3Rpb24gPT09ICdob3Jpem9udGFsJykge1xuICAgICAgICB0aGlzLnNjcm9sbGJhclRodW1iLnN0eWxlLndpZHRoID0gXCJcIi5jb25jYXQodGhpcy5zY3JvbGxiYXJXaWR0aCAqIHRoaXMuc2Nyb2xsYmFyV2lkdGggLyAodGhpcy5pbnN0YW5jZS5saW1pdC54ICsgdGhpcy5zY3JvbGxiYXJXaWR0aCksIFwicHhcIik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnNjcm9sbGJhclRodW1iLnN0eWxlLmhlaWdodCA9IFwiXCIuY29uY2F0KHRoaXMuc2Nyb2xsYmFySGVpZ2h0ICogdGhpcy5zY3JvbGxiYXJIZWlnaHQgLyAodGhpcy5pbnN0YW5jZS5saW1pdC55ICsgdGhpcy5zY3JvbGxiYXJIZWlnaHQpLCBcInB4XCIpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLnNjcm9sbGJhclRodW1iQkNSID0gdGhpcy5zY3JvbGxiYXJUaHVtYi5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgIHRoaXMuc2Nyb2xsQmFyTGltaXQgPSB7XG4gICAgICAgIHg6IHRoaXMuc2Nyb2xsYmFyV2lkdGggLSB0aGlzLnNjcm9sbGJhclRodW1iQkNSLndpZHRoLFxuICAgICAgICB5OiB0aGlzLnNjcm9sbGJhckhlaWdodCAtIHRoaXMuc2Nyb2xsYmFyVGh1bWJCQ1IuaGVpZ2h0XG4gICAgICB9O1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJyZWluaXRTY3JvbGxCYXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVpbml0U2Nyb2xsQmFyKCkge1xuICAgICAgdGhpcy5oYXNTY3JvbGxiYXIgPSBmYWxzZTtcblxuICAgICAgaWYgKHRoaXMuZGlyZWN0aW9uID09ICdob3Jpem9udGFsJykge1xuICAgICAgICBpZiAodGhpcy5pbnN0YW5jZS5saW1pdC54ICsgdGhpcy53aW5kb3dXaWR0aCA8PSB0aGlzLndpbmRvd1dpZHRoKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAodGhpcy5pbnN0YW5jZS5saW1pdC55ICsgdGhpcy53aW5kb3dIZWlnaHQgPD0gdGhpcy53aW5kb3dIZWlnaHQpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdGhpcy5oYXNTY3JvbGxiYXIgPSB0cnVlO1xuICAgICAgdGhpcy5zY3JvbGxiYXJCQ1IgPSB0aGlzLnNjcm9sbGJhci5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgIHRoaXMuc2Nyb2xsYmFySGVpZ2h0ID0gdGhpcy5zY3JvbGxiYXJCQ1IuaGVpZ2h0O1xuICAgICAgdGhpcy5zY3JvbGxiYXJXaWR0aCA9IHRoaXMuc2Nyb2xsYmFyQkNSLndpZHRoO1xuXG4gICAgICBpZiAodGhpcy5kaXJlY3Rpb24gPT09ICdob3Jpem9udGFsJykge1xuICAgICAgICB0aGlzLnNjcm9sbGJhclRodW1iLnN0eWxlLndpZHRoID0gXCJcIi5jb25jYXQodGhpcy5zY3JvbGxiYXJXaWR0aCAqIHRoaXMuc2Nyb2xsYmFyV2lkdGggLyAodGhpcy5pbnN0YW5jZS5saW1pdC54ICsgdGhpcy5zY3JvbGxiYXJXaWR0aCksIFwicHhcIik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnNjcm9sbGJhclRodW1iLnN0eWxlLmhlaWdodCA9IFwiXCIuY29uY2F0KHRoaXMuc2Nyb2xsYmFySGVpZ2h0ICogdGhpcy5zY3JvbGxiYXJIZWlnaHQgLyAodGhpcy5pbnN0YW5jZS5saW1pdC55ICsgdGhpcy5zY3JvbGxiYXJIZWlnaHQpLCBcInB4XCIpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLnNjcm9sbGJhclRodW1iQkNSID0gdGhpcy5zY3JvbGxiYXJUaHVtYi5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgIHRoaXMuc2Nyb2xsQmFyTGltaXQgPSB7XG4gICAgICAgIHg6IHRoaXMuc2Nyb2xsYmFyV2lkdGggLSB0aGlzLnNjcm9sbGJhclRodW1iQkNSLndpZHRoLFxuICAgICAgICB5OiB0aGlzLnNjcm9sbGJhckhlaWdodCAtIHRoaXMuc2Nyb2xsYmFyVGh1bWJCQ1IuaGVpZ2h0XG4gICAgICB9O1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJkZXN0cm95U2Nyb2xsQmFyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRlc3Ryb3lTY3JvbGxCYXIoKSB7XG4gICAgICB0aGlzLnNjcm9sbGJhclRodW1iLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNlZG93bicsIHRoaXMuZ2V0U2Nyb2xsQmFyKTtcbiAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZXVwJywgdGhpcy5yZWxlYXNlU2Nyb2xsQmFyKTtcbiAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCB0aGlzLm1vdmVTY3JvbGxCYXIpO1xuICAgICAgdGhpcy5zY3JvbGxiYXIucmVtb3ZlKCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImdldFNjcm9sbEJhclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRTY3JvbGxCYXIoZSkge1xuICAgICAgdGhpcy5pc0RyYWdnaW5nU2Nyb2xsYmFyID0gdHJ1ZTtcbiAgICAgIHRoaXMuY2hlY2tTY3JvbGwoKTtcbiAgICAgIHRoaXMuaHRtbC5jbGFzc0xpc3QucmVtb3ZlKHRoaXMuc2Nyb2xsaW5nQ2xhc3MpO1xuICAgICAgdGhpcy5odG1sLmNsYXNzTGlzdC5hZGQodGhpcy5kcmFnZ2luZ0NsYXNzKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwicmVsZWFzZVNjcm9sbEJhclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZWxlYXNlU2Nyb2xsQmFyKGUpIHtcbiAgICAgIHRoaXMuaXNEcmFnZ2luZ1Njcm9sbGJhciA9IGZhbHNlO1xuXG4gICAgICBpZiAodGhpcy5pc1Njcm9sbGluZykge1xuICAgICAgICB0aGlzLmh0bWwuY2xhc3NMaXN0LmFkZCh0aGlzLnNjcm9sbGluZ0NsYXNzKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5odG1sLmNsYXNzTGlzdC5yZW1vdmUodGhpcy5kcmFnZ2luZ0NsYXNzKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwibW92ZVNjcm9sbEJhclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBtb3ZlU2Nyb2xsQmFyKGUpIHtcbiAgICAgIHZhciBfdGhpczUgPSB0aGlzO1xuXG4gICAgICBpZiAodGhpcy5pc0RyYWdnaW5nU2Nyb2xsYmFyKSB7XG4gICAgICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZShmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgdmFyIHggPSAoZS5jbGllbnRYIC0gX3RoaXM1LnNjcm9sbGJhckJDUi5sZWZ0KSAqIDEwMCAvIF90aGlzNS5zY3JvbGxiYXJXaWR0aCAqIF90aGlzNS5pbnN0YW5jZS5saW1pdC54IC8gMTAwO1xuICAgICAgICAgIHZhciB5ID0gKGUuY2xpZW50WSAtIF90aGlzNS5zY3JvbGxiYXJCQ1IudG9wKSAqIDEwMCAvIF90aGlzNS5zY3JvbGxiYXJIZWlnaHQgKiBfdGhpczUuaW5zdGFuY2UubGltaXQueSAvIDEwMDtcblxuICAgICAgICAgIGlmICh5ID4gMCAmJiB5IDwgX3RoaXM1Lmluc3RhbmNlLmxpbWl0LnkpIHtcbiAgICAgICAgICAgIF90aGlzNS5pbnN0YW5jZS5kZWx0YS55ID0geTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoeCA+IDAgJiYgeCA8IF90aGlzNS5pbnN0YW5jZS5saW1pdC54KSB7XG4gICAgICAgICAgICBfdGhpczUuaW5zdGFuY2UuZGVsdGEueCA9IHg7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiYWRkRWxlbWVudHNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gYWRkRWxlbWVudHMoKSB7XG4gICAgICB2YXIgX3RoaXM2ID0gdGhpcztcblxuICAgICAgdGhpcy5lbHMgPSB7fTtcbiAgICAgIHRoaXMucGFyYWxsYXhFbGVtZW50cyA9IHt9OyAvLyB0aGlzLnNlY3Rpb25zLmZvckVhY2goKHNlY3Rpb24sIHkpID0+IHtcblxuICAgICAgdmFyIGVscyA9IHRoaXMuZWwucXVlcnlTZWxlY3RvckFsbChcIltkYXRhLVwiLmNvbmNhdCh0aGlzLm5hbWUsIFwiXVwiKSk7XG4gICAgICBlbHMuZm9yRWFjaChmdW5jdGlvbiAoZWwsIGluZGV4KSB7XG4gICAgICAgIC8vIFRyeSBhbmQgZmluZCB0aGUgdGFyZ2V0J3MgcGFyZW50IHNlY3Rpb25cbiAgICAgICAgdmFyIHRhcmdldFBhcmVudHMgPSBnZXRQYXJlbnRzKGVsKTtcbiAgICAgICAgdmFyIHNlY3Rpb24gPSBPYmplY3QuZW50cmllcyhfdGhpczYuc2VjdGlvbnMpLm1hcChmdW5jdGlvbiAoX3JlZjMpIHtcbiAgICAgICAgICB2YXIgX3JlZjQgPSBfc2xpY2VkVG9BcnJheShfcmVmMywgMiksXG4gICAgICAgICAgICAgIGtleSA9IF9yZWY0WzBdLFxuICAgICAgICAgICAgICBzZWN0aW9uID0gX3JlZjRbMV07XG5cbiAgICAgICAgICByZXR1cm4gc2VjdGlvbjtcbiAgICAgICAgfSkuZmluZChmdW5jdGlvbiAoc2VjdGlvbikge1xuICAgICAgICAgIHJldHVybiB0YXJnZXRQYXJlbnRzLmluY2x1ZGVzKHNlY3Rpb24uZWwpO1xuICAgICAgICB9KTtcbiAgICAgICAgdmFyIGNsID0gZWwuZGF0YXNldFtfdGhpczYubmFtZSArICdDbGFzcyddIHx8IF90aGlzNltcImNsYXNzXCJdO1xuICAgICAgICB2YXIgaWQgPSB0eXBlb2YgZWwuZGF0YXNldFtfdGhpczYubmFtZSArICdJZCddID09PSAnc3RyaW5nJyA/IGVsLmRhdGFzZXRbX3RoaXM2Lm5hbWUgKyAnSWQnXSA6ICdlbCcgKyBpbmRleDtcbiAgICAgICAgdmFyIHRvcDtcbiAgICAgICAgdmFyIGxlZnQ7XG4gICAgICAgIHZhciByZXBlYXQgPSBlbC5kYXRhc2V0W190aGlzNi5uYW1lICsgJ1JlcGVhdCddO1xuICAgICAgICB2YXIgY2FsbCA9IGVsLmRhdGFzZXRbX3RoaXM2Lm5hbWUgKyAnQ2FsbCddO1xuICAgICAgICB2YXIgcG9zaXRpb24gPSBlbC5kYXRhc2V0W190aGlzNi5uYW1lICsgJ1Bvc2l0aW9uJ107XG4gICAgICAgIHZhciBkZWxheSA9IGVsLmRhdGFzZXRbX3RoaXM2Lm5hbWUgKyAnRGVsYXknXTtcbiAgICAgICAgdmFyIGRpcmVjdGlvbiA9IGVsLmRhdGFzZXRbX3RoaXM2Lm5hbWUgKyAnRGlyZWN0aW9uJ107XG4gICAgICAgIHZhciBzdGlja3kgPSB0eXBlb2YgZWwuZGF0YXNldFtfdGhpczYubmFtZSArICdTdGlja3knXSA9PT0gJ3N0cmluZyc7XG4gICAgICAgIHZhciBzcGVlZCA9IGVsLmRhdGFzZXRbX3RoaXM2Lm5hbWUgKyAnU3BlZWQnXSA/IHBhcnNlRmxvYXQoZWwuZGF0YXNldFtfdGhpczYubmFtZSArICdTcGVlZCddKSAvIDEwIDogZmFsc2U7XG4gICAgICAgIHZhciBvZmZzZXQgPSB0eXBlb2YgZWwuZGF0YXNldFtfdGhpczYubmFtZSArICdPZmZzZXQnXSA9PT0gJ3N0cmluZycgPyBlbC5kYXRhc2V0W190aGlzNi5uYW1lICsgJ09mZnNldCddLnNwbGl0KCcsJykgOiBfdGhpczYub2Zmc2V0O1xuICAgICAgICB2YXIgdGFyZ2V0ID0gZWwuZGF0YXNldFtfdGhpczYubmFtZSArICdUYXJnZXQnXTtcbiAgICAgICAgdmFyIHRhcmdldEVsO1xuXG4gICAgICAgIGlmICh0YXJnZXQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHRhcmdldEVsID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihcIlwiLmNvbmNhdCh0YXJnZXQpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0YXJnZXRFbCA9IGVsO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHRhcmdldEVsQkNSID0gdGFyZ2V0RWwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG5cbiAgICAgICAgaWYgKHNlY3Rpb24gPT09IG51bGwpIHtcbiAgICAgICAgICB0b3AgPSB0YXJnZXRFbEJDUi50b3AgKyBfdGhpczYuaW5zdGFuY2Uuc2Nyb2xsLnkgLSBnZXRUcmFuc2xhdGUodGFyZ2V0RWwpLnk7XG4gICAgICAgICAgbGVmdCA9IHRhcmdldEVsQkNSLmxlZnQgKyBfdGhpczYuaW5zdGFuY2Uuc2Nyb2xsLnggLSBnZXRUcmFuc2xhdGUodGFyZ2V0RWwpLng7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKCFzZWN0aW9uLmluVmlldykge1xuICAgICAgICAgICAgdG9wID0gdGFyZ2V0RWxCQ1IudG9wIC0gZ2V0VHJhbnNsYXRlKHNlY3Rpb24uZWwpLnkgLSBnZXRUcmFuc2xhdGUodGFyZ2V0RWwpLnk7XG4gICAgICAgICAgICBsZWZ0ID0gdGFyZ2V0RWxCQ1IubGVmdCAtIGdldFRyYW5zbGF0ZShzZWN0aW9uLmVsKS54IC0gZ2V0VHJhbnNsYXRlKHRhcmdldEVsKS54O1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0b3AgPSB0YXJnZXRFbEJDUi50b3AgKyBfdGhpczYuaW5zdGFuY2Uuc2Nyb2xsLnkgLSBnZXRUcmFuc2xhdGUodGFyZ2V0RWwpLnk7XG4gICAgICAgICAgICBsZWZ0ID0gdGFyZ2V0RWxCQ1IubGVmdCArIF90aGlzNi5pbnN0YW5jZS5zY3JvbGwueCAtIGdldFRyYW5zbGF0ZSh0YXJnZXRFbCkueDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgYm90dG9tID0gdG9wICsgdGFyZ2V0RWwub2Zmc2V0SGVpZ2h0O1xuICAgICAgICB2YXIgcmlnaHQgPSBsZWZ0ICsgdGFyZ2V0RWwub2Zmc2V0V2lkdGg7XG4gICAgICAgIHZhciBtaWRkbGUgPSB7XG4gICAgICAgICAgeDogKHJpZ2h0IC0gbGVmdCkgLyAyICsgbGVmdCxcbiAgICAgICAgICB5OiAoYm90dG9tIC0gdG9wKSAvIDIgKyB0b3BcbiAgICAgICAgfTtcblxuICAgICAgICBpZiAoc3RpY2t5KSB7XG4gICAgICAgICAgdmFyIGVsQkNSID0gZWwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgICAgdmFyIGVsVG9wID0gZWxCQ1IudG9wO1xuICAgICAgICAgIHZhciBlbExlZnQgPSBlbEJDUi5sZWZ0O1xuICAgICAgICAgIHZhciBlbERpc3RhbmNlID0ge1xuICAgICAgICAgICAgeDogZWxMZWZ0IC0gbGVmdCxcbiAgICAgICAgICAgIHk6IGVsVG9wIC0gdG9wXG4gICAgICAgICAgfTtcbiAgICAgICAgICB0b3AgKz0gd2luZG93LmlubmVySGVpZ2h0O1xuICAgICAgICAgIGxlZnQgKz0gd2luZG93LmlubmVyV2lkdGg7XG4gICAgICAgICAgYm90dG9tID0gZWxUb3AgKyB0YXJnZXRFbC5vZmZzZXRIZWlnaHQgLSBlbC5vZmZzZXRIZWlnaHQgLSBlbERpc3RhbmNlW190aGlzNi5kaXJlY3Rpb25BeGlzXTtcbiAgICAgICAgICByaWdodCA9IGVsTGVmdCArIHRhcmdldEVsLm9mZnNldFdpZHRoIC0gZWwub2Zmc2V0V2lkdGggLSBlbERpc3RhbmNlW190aGlzNi5kaXJlY3Rpb25BeGlzXTtcbiAgICAgICAgICBtaWRkbGUgPSB7XG4gICAgICAgICAgICB4OiAocmlnaHQgLSBsZWZ0KSAvIDIgKyBsZWZ0LFxuICAgICAgICAgICAgeTogKGJvdHRvbSAtIHRvcCkgLyAyICsgdG9wXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChyZXBlYXQgPT0gJ2ZhbHNlJykge1xuICAgICAgICAgIHJlcGVhdCA9IGZhbHNlO1xuICAgICAgICB9IGVsc2UgaWYgKHJlcGVhdCAhPSB1bmRlZmluZWQpIHtcbiAgICAgICAgICByZXBlYXQgPSB0cnVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJlcGVhdCA9IF90aGlzNi5yZXBlYXQ7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgcmVsYXRpdmVPZmZzZXQgPSBbMCwgMF07XG5cbiAgICAgICAgaWYgKG9mZnNldCkge1xuICAgICAgICAgIGlmIChfdGhpczYuZGlyZWN0aW9uID09PSAnaG9yaXpvbnRhbCcpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgb2Zmc2V0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgIGlmICh0eXBlb2Ygb2Zmc2V0W2ldID09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgaWYgKG9mZnNldFtpXS5pbmNsdWRlcygnJScpKSB7XG4gICAgICAgICAgICAgICAgICByZWxhdGl2ZU9mZnNldFtpXSA9IHBhcnNlSW50KG9mZnNldFtpXS5yZXBsYWNlKCclJywgJycpICogX3RoaXM2LndpbmRvd1dpZHRoIC8gMTAwKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgcmVsYXRpdmVPZmZzZXRbaV0gPSBwYXJzZUludChvZmZzZXRbaV0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZWxhdGl2ZU9mZnNldFtpXSA9IG9mZnNldFtpXTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBsZWZ0ID0gbGVmdCArIHJlbGF0aXZlT2Zmc2V0WzBdO1xuICAgICAgICAgICAgcmlnaHQgPSByaWdodCAtIHJlbGF0aXZlT2Zmc2V0WzFdO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG9mZnNldC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICBpZiAodHlwZW9mIG9mZnNldFtpXSA9PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIGlmIChvZmZzZXRbaV0uaW5jbHVkZXMoJyUnKSkge1xuICAgICAgICAgICAgICAgICAgcmVsYXRpdmVPZmZzZXRbaV0gPSBwYXJzZUludChvZmZzZXRbaV0ucmVwbGFjZSgnJScsICcnKSAqIF90aGlzNi53aW5kb3dIZWlnaHQgLyAxMDApO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICByZWxhdGl2ZU9mZnNldFtpXSA9IHBhcnNlSW50KG9mZnNldFtpXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlbGF0aXZlT2Zmc2V0W2ldID0gb2Zmc2V0W2ldO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRvcCA9IHRvcCArIHJlbGF0aXZlT2Zmc2V0WzBdO1xuICAgICAgICAgICAgYm90dG9tID0gYm90dG9tIC0gcmVsYXRpdmVPZmZzZXRbMV07XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdmFyIG1hcHBlZEVsID0ge1xuICAgICAgICAgIGVsOiBlbCxcbiAgICAgICAgICBpZDogaWQsXG4gICAgICAgICAgXCJjbGFzc1wiOiBjbCxcbiAgICAgICAgICBzZWN0aW9uOiBzZWN0aW9uLFxuICAgICAgICAgIHRvcDogdG9wLFxuICAgICAgICAgIG1pZGRsZTogbWlkZGxlLFxuICAgICAgICAgIGJvdHRvbTogYm90dG9tLFxuICAgICAgICAgIGxlZnQ6IGxlZnQsXG4gICAgICAgICAgcmlnaHQ6IHJpZ2h0LFxuICAgICAgICAgIG9mZnNldDogb2Zmc2V0LFxuICAgICAgICAgIHByb2dyZXNzOiAwLFxuICAgICAgICAgIHJlcGVhdDogcmVwZWF0LFxuICAgICAgICAgIGluVmlldzogZmFsc2UsXG4gICAgICAgICAgY2FsbDogY2FsbCxcbiAgICAgICAgICBzcGVlZDogc3BlZWQsXG4gICAgICAgICAgZGVsYXk6IGRlbGF5LFxuICAgICAgICAgIHBvc2l0aW9uOiBwb3NpdGlvbixcbiAgICAgICAgICB0YXJnZXQ6IHRhcmdldEVsLFxuICAgICAgICAgIGRpcmVjdGlvbjogZGlyZWN0aW9uLFxuICAgICAgICAgIHN0aWNreTogc3RpY2t5XG4gICAgICAgIH07XG4gICAgICAgIF90aGlzNi5lbHNbaWRdID0gbWFwcGVkRWw7XG5cbiAgICAgICAgaWYgKGVsLmNsYXNzTGlzdC5jb250YWlucyhjbCkpIHtcbiAgICAgICAgICBfdGhpczYuc2V0SW5WaWV3KF90aGlzNi5lbHNbaWRdLCBpZCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoc3BlZWQgIT09IGZhbHNlIHx8IHN0aWNreSkge1xuICAgICAgICAgIF90aGlzNi5wYXJhbGxheEVsZW1lbnRzW2lkXSA9IG1hcHBlZEVsO1xuICAgICAgICB9XG4gICAgICB9KTsgLy8gfSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImFkZFNlY3Rpb25zXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGFkZFNlY3Rpb25zKCkge1xuICAgICAgdmFyIF90aGlzNyA9IHRoaXM7XG5cbiAgICAgIHRoaXMuc2VjdGlvbnMgPSB7fTtcbiAgICAgIHZhciBzZWN0aW9ucyA9IHRoaXMuZWwucXVlcnlTZWxlY3RvckFsbChcIltkYXRhLVwiLmNvbmNhdCh0aGlzLm5hbWUsIFwiLXNlY3Rpb25dXCIpKTtcblxuICAgICAgaWYgKHNlY3Rpb25zLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICBzZWN0aW9ucyA9IFt0aGlzLmVsXTtcbiAgICAgIH1cblxuICAgICAgc2VjdGlvbnMuZm9yRWFjaChmdW5jdGlvbiAoc2VjdGlvbiwgaW5kZXgpIHtcbiAgICAgICAgdmFyIGlkID0gdHlwZW9mIHNlY3Rpb24uZGF0YXNldFtfdGhpczcubmFtZSArICdJZCddID09PSAnc3RyaW5nJyA/IHNlY3Rpb24uZGF0YXNldFtfdGhpczcubmFtZSArICdJZCddIDogJ3NlY3Rpb24nICsgaW5kZXg7XG4gICAgICAgIHZhciBzZWN0aW9uQkNSID0gc2VjdGlvbi5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgdmFyIG9mZnNldCA9IHtcbiAgICAgICAgICB4OiBzZWN0aW9uQkNSLmxlZnQgLSB3aW5kb3cuaW5uZXJXaWR0aCAqIDEuNSAtIGdldFRyYW5zbGF0ZShzZWN0aW9uKS54LFxuICAgICAgICAgIHk6IHNlY3Rpb25CQ1IudG9wIC0gd2luZG93LmlubmVySGVpZ2h0ICogMS41IC0gZ2V0VHJhbnNsYXRlKHNlY3Rpb24pLnlcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIGxpbWl0ID0ge1xuICAgICAgICAgIHg6IG9mZnNldC54ICsgc2VjdGlvbkJDUi53aWR0aCArIHdpbmRvdy5pbm5lcldpZHRoICogMixcbiAgICAgICAgICB5OiBvZmZzZXQueSArIHNlY3Rpb25CQ1IuaGVpZ2h0ICsgd2luZG93LmlubmVySGVpZ2h0ICogMlxuICAgICAgICB9O1xuICAgICAgICB2YXIgcGVyc2lzdGVudCA9IHR5cGVvZiBzZWN0aW9uLmRhdGFzZXRbX3RoaXM3Lm5hbWUgKyAnUGVyc2lzdGVudCddID09PSAnc3RyaW5nJztcbiAgICAgICAgc2VjdGlvbi5zZXRBdHRyaWJ1dGUoJ2RhdGEtc2Nyb2xsLXNlY3Rpb24taWQnLCBpZCk7XG4gICAgICAgIHZhciBtYXBwZWRTZWN0aW9uID0ge1xuICAgICAgICAgIGVsOiBzZWN0aW9uLFxuICAgICAgICAgIG9mZnNldDogb2Zmc2V0LFxuICAgICAgICAgIGxpbWl0OiBsaW1pdCxcbiAgICAgICAgICBpblZpZXc6IGZhbHNlLFxuICAgICAgICAgIHBlcnNpc3RlbnQ6IHBlcnNpc3RlbnQsXG4gICAgICAgICAgaWQ6IGlkXG4gICAgICAgIH07XG4gICAgICAgIF90aGlzNy5zZWN0aW9uc1tpZF0gPSBtYXBwZWRTZWN0aW9uO1xuICAgICAgfSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInRyYW5zZm9ybVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB0cmFuc2Zvcm0oZWxlbWVudCwgeCwgeSwgZGVsYXkpIHtcbiAgICAgIHZhciB0cmFuc2Zvcm07XG5cbiAgICAgIGlmICghZGVsYXkpIHtcbiAgICAgICAgdHJhbnNmb3JtID0gXCJtYXRyaXgzZCgxLDAsMC4wMCwwLDAuMDAsMSwwLjAwLDAsMCwwLDEsMCxcIi5jb25jYXQoeCwgXCIsXCIpLmNvbmNhdCh5LCBcIiwwLDEpXCIpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIHN0YXJ0ID0gZ2V0VHJhbnNsYXRlKGVsZW1lbnQpO1xuICAgICAgICB2YXIgbGVycFggPSBsZXJwKHN0YXJ0LngsIHgsIGRlbGF5KTtcbiAgICAgICAgdmFyIGxlcnBZID0gbGVycChzdGFydC55LCB5LCBkZWxheSk7XG4gICAgICAgIHRyYW5zZm9ybSA9IFwibWF0cml4M2QoMSwwLDAuMDAsMCwwLjAwLDEsMC4wMCwwLDAsMCwxLDAsXCIuY29uY2F0KGxlcnBYLCBcIixcIikuY29uY2F0KGxlcnBZLCBcIiwwLDEpXCIpO1xuICAgICAgfVxuXG4gICAgICBlbGVtZW50LnN0eWxlLndlYmtpdFRyYW5zZm9ybSA9IHRyYW5zZm9ybTtcbiAgICAgIGVsZW1lbnQuc3R5bGUubXNUcmFuc2Zvcm0gPSB0cmFuc2Zvcm07XG4gICAgICBlbGVtZW50LnN0eWxlLnRyYW5zZm9ybSA9IHRyYW5zZm9ybTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwidHJhbnNmb3JtRWxlbWVudHNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdHJhbnNmb3JtRWxlbWVudHMoaXNGb3JjZWQpIHtcbiAgICAgIHZhciBfdGhpczggPSB0aGlzO1xuXG4gICAgICB2YXIgc2V0QWxsRWxlbWVudHMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IGZhbHNlO1xuICAgICAgdmFyIHNjcm9sbFJpZ2h0ID0gdGhpcy5pbnN0YW5jZS5zY3JvbGwueCArIHRoaXMud2luZG93V2lkdGg7XG4gICAgICB2YXIgc2Nyb2xsQm90dG9tID0gdGhpcy5pbnN0YW5jZS5zY3JvbGwueSArIHRoaXMud2luZG93SGVpZ2h0O1xuICAgICAgdmFyIHNjcm9sbE1pZGRsZSA9IHtcbiAgICAgICAgeDogdGhpcy5pbnN0YW5jZS5zY3JvbGwueCArIHRoaXMud2luZG93TWlkZGxlLngsXG4gICAgICAgIHk6IHRoaXMuaW5zdGFuY2Uuc2Nyb2xsLnkgKyB0aGlzLndpbmRvd01pZGRsZS55XG4gICAgICB9O1xuICAgICAgT2JqZWN0LmVudHJpZXModGhpcy5wYXJhbGxheEVsZW1lbnRzKS5mb3JFYWNoKGZ1bmN0aW9uIChfcmVmNSkge1xuICAgICAgICB2YXIgX3JlZjYgPSBfc2xpY2VkVG9BcnJheShfcmVmNSwgMiksXG4gICAgICAgICAgICBpID0gX3JlZjZbMF0sXG4gICAgICAgICAgICBjdXJyZW50ID0gX3JlZjZbMV07XG5cbiAgICAgICAgdmFyIHRyYW5zZm9ybURpc3RhbmNlID0gZmFsc2U7XG5cbiAgICAgICAgaWYgKGlzRm9yY2VkKSB7XG4gICAgICAgICAgdHJhbnNmb3JtRGlzdGFuY2UgPSAwO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGN1cnJlbnQuaW5WaWV3IHx8IHNldEFsbEVsZW1lbnRzKSB7XG4gICAgICAgICAgc3dpdGNoIChjdXJyZW50LnBvc2l0aW9uKSB7XG4gICAgICAgICAgICBjYXNlICd0b3AnOlxuICAgICAgICAgICAgICB0cmFuc2Zvcm1EaXN0YW5jZSA9IF90aGlzOC5pbnN0YW5jZS5zY3JvbGxbX3RoaXM4LmRpcmVjdGlvbkF4aXNdICogLWN1cnJlbnQuc3BlZWQ7XG4gICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBjYXNlICdlbGVtZW50VG9wJzpcbiAgICAgICAgICAgICAgdHJhbnNmb3JtRGlzdGFuY2UgPSAoc2Nyb2xsQm90dG9tIC0gY3VycmVudC50b3ApICogLWN1cnJlbnQuc3BlZWQ7XG4gICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBjYXNlICdib3R0b20nOlxuICAgICAgICAgICAgICB0cmFuc2Zvcm1EaXN0YW5jZSA9IChfdGhpczguaW5zdGFuY2UubGltaXRbX3RoaXM4LmRpcmVjdGlvbkF4aXNdIC0gc2Nyb2xsQm90dG9tICsgX3RoaXM4LndpbmRvd0hlaWdodCkgKiBjdXJyZW50LnNwZWVkO1xuICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgY2FzZSAnbGVmdCc6XG4gICAgICAgICAgICAgIHRyYW5zZm9ybURpc3RhbmNlID0gX3RoaXM4Lmluc3RhbmNlLnNjcm9sbFtfdGhpczguZGlyZWN0aW9uQXhpc10gKiAtY3VycmVudC5zcGVlZDtcbiAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGNhc2UgJ2VsZW1lbnRMZWZ0JzpcbiAgICAgICAgICAgICAgdHJhbnNmb3JtRGlzdGFuY2UgPSAoc2Nyb2xsUmlnaHQgLSBjdXJyZW50LmxlZnQpICogLWN1cnJlbnQuc3BlZWQ7XG4gICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBjYXNlICdyaWdodCc6XG4gICAgICAgICAgICAgIHRyYW5zZm9ybURpc3RhbmNlID0gKF90aGlzOC5pbnN0YW5jZS5saW1pdFtfdGhpczguZGlyZWN0aW9uQXhpc10gLSBzY3JvbGxSaWdodCArIF90aGlzOC53aW5kb3dIZWlnaHQpICogY3VycmVudC5zcGVlZDtcbiAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgIHRyYW5zZm9ybURpc3RhbmNlID0gKHNjcm9sbE1pZGRsZVtfdGhpczguZGlyZWN0aW9uQXhpc10gLSBjdXJyZW50Lm1pZGRsZVtfdGhpczguZGlyZWN0aW9uQXhpc10pICogLWN1cnJlbnQuc3BlZWQ7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChjdXJyZW50LnN0aWNreSkge1xuICAgICAgICAgIGlmIChjdXJyZW50LmluVmlldykge1xuICAgICAgICAgICAgaWYgKF90aGlzOC5kaXJlY3Rpb24gPT09ICdob3Jpem9udGFsJykge1xuICAgICAgICAgICAgICB0cmFuc2Zvcm1EaXN0YW5jZSA9IF90aGlzOC5pbnN0YW5jZS5zY3JvbGwueCAtIGN1cnJlbnQubGVmdCArIHdpbmRvdy5pbm5lcldpZHRoO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgdHJhbnNmb3JtRGlzdGFuY2UgPSBfdGhpczguaW5zdGFuY2Uuc2Nyb2xsLnkgLSBjdXJyZW50LnRvcCArIHdpbmRvdy5pbm5lckhlaWdodDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKF90aGlzOC5kaXJlY3Rpb24gPT09ICdob3Jpem9udGFsJykge1xuICAgICAgICAgICAgICBpZiAoX3RoaXM4Lmluc3RhbmNlLnNjcm9sbC54IDwgY3VycmVudC5sZWZ0IC0gd2luZG93LmlubmVyV2lkdGggJiYgX3RoaXM4Lmluc3RhbmNlLnNjcm9sbC54IDwgY3VycmVudC5sZWZ0IC0gd2luZG93LmlubmVyV2lkdGggLyAyKSB7XG4gICAgICAgICAgICAgICAgdHJhbnNmb3JtRGlzdGFuY2UgPSAwO1xuICAgICAgICAgICAgICB9IGVsc2UgaWYgKF90aGlzOC5pbnN0YW5jZS5zY3JvbGwueCA+IGN1cnJlbnQucmlnaHQgJiYgX3RoaXM4Lmluc3RhbmNlLnNjcm9sbC54ID4gY3VycmVudC5yaWdodCArIDEwMCkge1xuICAgICAgICAgICAgICAgIHRyYW5zZm9ybURpc3RhbmNlID0gY3VycmVudC5yaWdodCAtIGN1cnJlbnQubGVmdCArIHdpbmRvdy5pbm5lcldpZHRoO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRyYW5zZm9ybURpc3RhbmNlID0gZmFsc2U7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGlmIChfdGhpczguaW5zdGFuY2Uuc2Nyb2xsLnkgPCBjdXJyZW50LnRvcCAtIHdpbmRvdy5pbm5lckhlaWdodCAmJiBfdGhpczguaW5zdGFuY2Uuc2Nyb2xsLnkgPCBjdXJyZW50LnRvcCAtIHdpbmRvdy5pbm5lckhlaWdodCAvIDIpIHtcbiAgICAgICAgICAgICAgICB0cmFuc2Zvcm1EaXN0YW5jZSA9IDA7XG4gICAgICAgICAgICAgIH0gZWxzZSBpZiAoX3RoaXM4Lmluc3RhbmNlLnNjcm9sbC55ID4gY3VycmVudC5ib3R0b20gJiYgX3RoaXM4Lmluc3RhbmNlLnNjcm9sbC55ID4gY3VycmVudC5ib3R0b20gKyAxMDApIHtcbiAgICAgICAgICAgICAgICB0cmFuc2Zvcm1EaXN0YW5jZSA9IGN1cnJlbnQuYm90dG9tIC0gY3VycmVudC50b3AgKyB3aW5kb3cuaW5uZXJIZWlnaHQ7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdHJhbnNmb3JtRGlzdGFuY2UgPSBmYWxzZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0cmFuc2Zvcm1EaXN0YW5jZSAhPT0gZmFsc2UpIHtcbiAgICAgICAgICBpZiAoY3VycmVudC5kaXJlY3Rpb24gPT09ICdob3Jpem9udGFsJyB8fCBfdGhpczguZGlyZWN0aW9uID09PSAnaG9yaXpvbnRhbCcgJiYgY3VycmVudC5kaXJlY3Rpb24gIT09ICd2ZXJ0aWNhbCcpIHtcbiAgICAgICAgICAgIF90aGlzOC50cmFuc2Zvcm0oY3VycmVudC5lbCwgdHJhbnNmb3JtRGlzdGFuY2UsIDAsIGlzRm9yY2VkID8gZmFsc2UgOiBjdXJyZW50LmRlbGF5KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgX3RoaXM4LnRyYW5zZm9ybShjdXJyZW50LmVsLCAwLCB0cmFuc2Zvcm1EaXN0YW5jZSwgaXNGb3JjZWQgPyBmYWxzZSA6IGN1cnJlbnQuZGVsYXkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNjcm9sbCB0byBhIGRlc2lyZWQgdGFyZ2V0LlxuICAgICAqXG4gICAgICogQHBhcmFtICBBdmFpbGFibGUgb3B0aW9ucyA6XG4gICAgICogICAgICAgICAgdGFyZ2V0IHtub2RlLCBzdHJpbmcsIFwidG9wXCIsIFwiYm90dG9tXCIsIGludH0gLSBUaGUgRE9NIGVsZW1lbnQgd2Ugd2FudCB0byBzY3JvbGwgdG9cbiAgICAgKiAgICAgICAgICBvcHRpb25zIHtvYmplY3R9IC0gT3B0aW9ucyBvYmplY3QgZm9yIGFkZGl0aW9ubmFsIHNldHRpbmdzLlxuICAgICAqIEByZXR1cm4ge3ZvaWR9XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJzY3JvbGxUb1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzY3JvbGxUbyh0YXJnZXQpIHtcbiAgICAgIHZhciBfdGhpczkgPSB0aGlzO1xuXG4gICAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG4gICAgICAvLyBQYXJzZSBvcHRpb25zXG4gICAgICB2YXIgb2Zmc2V0ID0gcGFyc2VJbnQob3B0aW9ucy5vZmZzZXQpIHx8IDA7IC8vIEFuIG9mZnNldCB0byBhcHBseSBvbiB0b3Agb2YgZ2l2ZW4gYHRhcmdldGAgb3IgYHNvdXJjZUVsZW1gJ3MgdGFyZ2V0XG5cbiAgICAgIHZhciBkdXJhdGlvbiA9ICFpc05hTihwYXJzZUludChvcHRpb25zLmR1cmF0aW9uKSkgPyBwYXJzZUludChvcHRpb25zLmR1cmF0aW9uKSA6IDEwMDA7IC8vIER1cmF0aW9uIG9mIHRoZSBzY3JvbGwgYW5pbWF0aW9uIGluIG1pbGxpc2Vjb25kc1xuXG4gICAgICB2YXIgZWFzaW5nID0gb3B0aW9ucy5lYXNpbmcgfHwgWzAuMjUsIDAuMCwgMC4zNSwgMS4wXTsgLy8gQW4gYXJyYXkgb2YgNCBmbG9hdHMgYmV0d2VlbiAwIGFuZCAxIGRlZmluaW5nIHRoZSBiZXppZXIgY3VydmUgZm9yIHRoZSBhbmltYXRpb24ncyBlYXNpbmcuIFNlZSBodHRwOi8vZ3Jld2ViLm1lL2Jlemllci1lYXNpbmctZWRpdG9yL2V4YW1wbGUvXG5cbiAgICAgIHZhciBkaXNhYmxlTGVycCA9IG9wdGlvbnMuZGlzYWJsZUxlcnAgPyB0cnVlIDogZmFsc2U7IC8vIExlcnAgZWZmZWN0IHdvbid0IGJlIGFwcGxpZWQgaWYgc2V0IHRvIHRydWVcblxuICAgICAgdmFyIGNhbGxiYWNrID0gb3B0aW9ucy5jYWxsYmFjayA/IG9wdGlvbnMuY2FsbGJhY2sgOiBmYWxzZTsgLy8gZnVuY3Rpb24gY2FsbGVkIHdoZW4gc2Nyb2xsVG8gY29tcGxldGVzIChub3RlIHRoYXQgaXQgd29uJ3Qgd2FpdCBmb3IgbGVycCB0byBzdGFiaWxpemUpXG5cbiAgICAgIGVhc2luZyA9IHNyYyQxLmFwcGx5KHZvaWQgMCwgX3RvQ29uc3VtYWJsZUFycmF5KGVhc2luZykpO1xuXG4gICAgICBpZiAodHlwZW9mIHRhcmdldCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgLy8gU2VsZWN0b3Igb3IgYm91bmRhcmllc1xuICAgICAgICBpZiAodGFyZ2V0ID09PSAndG9wJykge1xuICAgICAgICAgIHRhcmdldCA9IDA7XG4gICAgICAgIH0gZWxzZSBpZiAodGFyZ2V0ID09PSAnYm90dG9tJykge1xuICAgICAgICAgIHRhcmdldCA9IHRoaXMuaW5zdGFuY2UubGltaXQueTtcbiAgICAgICAgfSBlbHNlIGlmICh0YXJnZXQgPT09ICdsZWZ0Jykge1xuICAgICAgICAgIHRhcmdldCA9IDA7XG4gICAgICAgIH0gZWxzZSBpZiAodGFyZ2V0ID09PSAncmlnaHQnKSB7XG4gICAgICAgICAgdGFyZ2V0ID0gdGhpcy5pbnN0YW5jZS5saW1pdC54O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRhcmdldCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IodGFyZ2V0KTsgLy8gSWYgdGhlIHF1ZXJ5IGZhaWxzLCBhYm9ydFxuXG4gICAgICAgICAgaWYgKCF0YXJnZXQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHRhcmdldCA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgLy8gQWJzb2x1dGUgY29vcmRpbmF0ZVxuICAgICAgICB0YXJnZXQgPSBwYXJzZUludCh0YXJnZXQpO1xuICAgICAgfSBlbHNlIGlmICh0YXJnZXQgJiYgdGFyZ2V0LnRhZ05hbWUpIDsgZWxzZSB7XG4gICAgICAgIGNvbnNvbGUud2FybignYHRhcmdldGAgcGFyYW1ldGVyIGlzIG5vdCB2YWxpZCcpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9IC8vIFdlIGhhdmUgYSB0YXJnZXQgdGhhdCBpcyBub3QgYSBjb29yZGluYXRlIHlldCwgZ2V0IGl0XG5cblxuICAgICAgaWYgKHR5cGVvZiB0YXJnZXQgIT09ICdudW1iZXInKSB7XG4gICAgICAgIC8vIFZlcmlmeSB0aGUgZ2l2ZW4gdGFyZ2V0IGJlbG9uZ3MgdG8gdGhpcyBzY3JvbGwgc2NvcGVcbiAgICAgICAgdmFyIHRhcmdldEluU2NvcGUgPSBnZXRQYXJlbnRzKHRhcmdldCkuaW5jbHVkZXModGhpcy5lbCk7XG5cbiAgICAgICAgaWYgKCF0YXJnZXRJblNjb3BlKSB7XG4gICAgICAgICAgLy8gSWYgdGhlIHRhcmdldCBpc24ndCBpbnNpZGUgb3VyIG1haW4gZWxlbWVudCwgYWJvcnQgYW55IGFjdGlvblxuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfSAvLyBHZXQgdGFyZ2V0IG9mZnNldCBmcm9tIHRvcFxuXG5cbiAgICAgICAgdmFyIHRhcmdldEJDUiA9IHRhcmdldC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgdmFyIG9mZnNldFRvcCA9IHRhcmdldEJDUi50b3A7XG4gICAgICAgIHZhciBvZmZzZXRMZWZ0ID0gdGFyZ2V0QkNSLmxlZnQ7IC8vIFRyeSBhbmQgZmluZCB0aGUgdGFyZ2V0J3MgcGFyZW50IHNlY3Rpb25cblxuICAgICAgICB2YXIgdGFyZ2V0UGFyZW50cyA9IGdldFBhcmVudHModGFyZ2V0KTtcbiAgICAgICAgdmFyIHBhcmVudFNlY3Rpb24gPSB0YXJnZXRQYXJlbnRzLmZpbmQoZnVuY3Rpb24gKGNhbmRpZGF0ZSkge1xuICAgICAgICAgIHJldHVybiBPYmplY3QuZW50cmllcyhfdGhpczkuc2VjdGlvbnMpIC8vIEdldCBzZWN0aW9ucyBhc3NvY2lhdGl2ZSBhcnJheSBhcyBhIHJlZ3VsYXIgYXJyYXlcbiAgICAgICAgICAubWFwKGZ1bmN0aW9uIChfcmVmNykge1xuICAgICAgICAgICAgdmFyIF9yZWY4ID0gX3NsaWNlZFRvQXJyYXkoX3JlZjcsIDIpLFxuICAgICAgICAgICAgICAgIGtleSA9IF9yZWY4WzBdLFxuICAgICAgICAgICAgICAgIHNlY3Rpb24gPSBfcmVmOFsxXTtcblxuICAgICAgICAgICAgcmV0dXJuIHNlY3Rpb247XG4gICAgICAgICAgfSkgLy8gbWFwIHRvIHNlY3Rpb24gb25seSAod2UgZG9udCBuZWVkIHRoZSBrZXkgaGVyZSlcbiAgICAgICAgICAuZmluZChmdW5jdGlvbiAoc2VjdGlvbikge1xuICAgICAgICAgICAgcmV0dXJuIHNlY3Rpb24uZWwgPT0gY2FuZGlkYXRlO1xuICAgICAgICAgIH0pOyAvLyBmaW5hbGx5IGZpbmQgdGhlIHNlY3Rpb24gdGhhdCBtYXRjaGVzIHRoZSBjYW5kaWRhdGVcbiAgICAgICAgfSk7XG4gICAgICAgIHZhciBwYXJlbnRTZWN0aW9uT2Zmc2V0ID0gMDtcblxuICAgICAgICBpZiAocGFyZW50U2VjdGlvbikge1xuICAgICAgICAgIHBhcmVudFNlY3Rpb25PZmZzZXQgPSBnZXRUcmFuc2xhdGUocGFyZW50U2VjdGlvbilbdGhpcy5kaXJlY3Rpb25BeGlzXTsgLy8gV2UgZ290IGEgcGFyZW50IHNlY3Rpb24sIHN0b3JlIGl0J3MgY3VycmVudCBvZmZzZXQgdG8gcmVtb3ZlIGl0IGxhdGVyXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gaWYgbm8gcGFyZW50IHNlY3Rpb24gaXMgZm91bmQgd2UgbmVlZCB0byB1c2UgaW5zdGFuY2Ugc2Nyb2xsIGRpcmVjdGx5XG4gICAgICAgICAgcGFyZW50U2VjdGlvbk9mZnNldCA9IC10aGlzLmluc3RhbmNlLnNjcm9sbFt0aGlzLmRpcmVjdGlvbkF4aXNdO1xuICAgICAgICB9IC8vIEZpbmFsIHZhbHVlIG9mIHNjcm9sbCBkZXN0aW5hdGlvbiA6IG9mZnNldFRvcCArIChvcHRpb25hbCBvZmZzZXQgZ2l2ZW4gaW4gb3B0aW9ucykgLSAocGFyZW50J3Mgc2VjdGlvbiB0cmFuc2xhdGUpXG5cblxuICAgICAgICBpZiAodGhpcy5kaXJlY3Rpb24gPT09ICdob3Jpem9udGFsJykge1xuICAgICAgICAgIG9mZnNldCA9IG9mZnNldExlZnQgKyBvZmZzZXQgLSBwYXJlbnRTZWN0aW9uT2Zmc2V0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG9mZnNldCA9IG9mZnNldFRvcCArIG9mZnNldCAtIHBhcmVudFNlY3Rpb25PZmZzZXQ7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG9mZnNldCA9IHRhcmdldCArIG9mZnNldDtcbiAgICAgIH0gLy8gQWN0dWFsIHNjcm9sbHRvXG4gICAgICAvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICAgICAgLy8gU2V0dXBcblxuXG4gICAgICB2YXIgc2Nyb2xsU3RhcnQgPSBwYXJzZUZsb2F0KHRoaXMuaW5zdGFuY2UuZGVsdGFbdGhpcy5kaXJlY3Rpb25BeGlzXSk7XG4gICAgICB2YXIgc2Nyb2xsVGFyZ2V0ID0gTWF0aC5tYXgoMCwgTWF0aC5taW4ob2Zmc2V0LCB0aGlzLmluc3RhbmNlLmxpbWl0W3RoaXMuZGlyZWN0aW9uQXhpc10pKTsgLy8gTWFrZSBzdXJlIG91ciB0YXJnZXQgaXMgaW4gdGhlIHNjcm9sbCBib3VuZGFyaWVzXG5cbiAgICAgIHZhciBzY3JvbGxEaWZmID0gc2Nyb2xsVGFyZ2V0IC0gc2Nyb2xsU3RhcnQ7XG5cbiAgICAgIHZhciByZW5kZXIgPSBmdW5jdGlvbiByZW5kZXIocCkge1xuICAgICAgICBpZiAoZGlzYWJsZUxlcnApIHtcbiAgICAgICAgICBpZiAoX3RoaXM5LmRpcmVjdGlvbiA9PT0gJ2hvcml6b250YWwnKSB7XG4gICAgICAgICAgICBfdGhpczkuc2V0U2Nyb2xsKHNjcm9sbFN0YXJ0ICsgc2Nyb2xsRGlmZiAqIHAsIF90aGlzOS5pbnN0YW5jZS5kZWx0YS55KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgX3RoaXM5LnNldFNjcm9sbChfdGhpczkuaW5zdGFuY2UuZGVsdGEueCwgc2Nyb2xsU3RhcnQgKyBzY3JvbGxEaWZmICogcCk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIF90aGlzOS5pbnN0YW5jZS5kZWx0YVtfdGhpczkuZGlyZWN0aW9uQXhpc10gPSBzY3JvbGxTdGFydCArIHNjcm9sbERpZmYgKiBwO1xuICAgICAgICB9XG4gICAgICB9OyAvLyBQcmVwYXJlIHRoZSBzY3JvbGxcblxuXG4gICAgICB0aGlzLmFuaW1hdGluZ1Njcm9sbCA9IHRydWU7IC8vIFRoaXMgYm9vbGVhbiBhbGxvd3MgdG8gcHJldmVudCBgY2hlY2tTY3JvbGwoKWAgZnJvbSBjYWxsaW5nIGBzdG9wU2Nyb2xsaW5nYCB3aGVuIHRoZSBhbmltYXRpb24gaXMgc2xvdyAoaS5lLiBhdCB0aGUgYmVnaW5uaW5nIG9mIGFuIEVhc2VJbilcblxuICAgICAgdGhpcy5zdG9wU2Nyb2xsaW5nKCk7IC8vIFN0b3AgYW55IG1vdmVtZW50LCBhbGxvd3MgdG8ga2lsbCBhbnkgb3RoZXIgYHNjcm9sbFRvYCBzdGlsbCBoYXBwZW5pbmdcblxuICAgICAgdGhpcy5zdGFydFNjcm9sbGluZygpOyAvLyBSZXN0YXJ0IHRoZSBzY3JvbGxcbiAgICAgIC8vIFN0YXJ0IHRoZSBhbmltYXRpb24gbG9vcFxuXG4gICAgICB2YXIgc3RhcnQgPSBEYXRlLm5vdygpO1xuXG4gICAgICB2YXIgbG9vcCA9IGZ1bmN0aW9uIGxvb3AoKSB7XG4gICAgICAgIHZhciBwID0gKERhdGUubm93KCkgLSBzdGFydCkgLyBkdXJhdGlvbjsgLy8gQW5pbWF0aW9uIHByb2dyZXNzXG5cbiAgICAgICAgaWYgKHAgPiAxKSB7XG4gICAgICAgICAgLy8gQW5pbWF0aW9uIGVuZHNcbiAgICAgICAgICByZW5kZXIoMSk7XG4gICAgICAgICAgX3RoaXM5LmFuaW1hdGluZ1Njcm9sbCA9IGZhbHNlO1xuICAgICAgICAgIGlmIChkdXJhdGlvbiA9PSAwKSBfdGhpczkudXBkYXRlKCk7XG4gICAgICAgICAgaWYgKGNhbGxiYWNrKSBjYWxsYmFjaygpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIF90aGlzOS5zY3JvbGxUb1JhZiA9IHJlcXVlc3RBbmltYXRpb25GcmFtZShsb29wKTtcbiAgICAgICAgICByZW5kZXIoZWFzaW5nKHApKTtcbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgbG9vcCgpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJ1cGRhdGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdXBkYXRlKCkge1xuICAgICAgdGhpcy5zZXRTY3JvbGxMaW1pdCgpO1xuICAgICAgdGhpcy5hZGRTZWN0aW9ucygpO1xuICAgICAgdGhpcy5hZGRFbGVtZW50cygpO1xuICAgICAgdGhpcy5kZXRlY3RFbGVtZW50cygpO1xuICAgICAgdGhpcy51cGRhdGVTY3JvbGwoKTtcbiAgICAgIHRoaXMudHJhbnNmb3JtRWxlbWVudHModHJ1ZSk7XG4gICAgICB0aGlzLnJlaW5pdFNjcm9sbEJhcigpO1xuICAgICAgdGhpcy5jaGVja1Njcm9sbCh0cnVlKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwic3RhcnRTY3JvbGxcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc3RhcnRTY3JvbGwoKSB7XG4gICAgICB0aGlzLnN0b3AgPSBmYWxzZTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwic3RvcFNjcm9sbFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzdG9wU2Nyb2xsKCkge1xuICAgICAgdGhpcy5zdG9wID0gdHJ1ZTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwic2V0U2Nyb2xsXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNldFNjcm9sbCh4LCB5KSB7XG4gICAgICB0aGlzLmluc3RhbmNlID0gX29iamVjdFNwcmVhZDIoX29iamVjdFNwcmVhZDIoe30sIHRoaXMuaW5zdGFuY2UpLCB7fSwge1xuICAgICAgICBzY3JvbGw6IHtcbiAgICAgICAgICB4OiB4LFxuICAgICAgICAgIHk6IHlcbiAgICAgICAgfSxcbiAgICAgICAgZGVsdGE6IHtcbiAgICAgICAgICB4OiB4LFxuICAgICAgICAgIHk6IHlcbiAgICAgICAgfSxcbiAgICAgICAgc3BlZWQ6IDBcbiAgICAgIH0pO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJkZXN0cm95XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRlc3Ryb3koKSB7XG4gICAgICBfZ2V0KF9nZXRQcm90b3R5cGVPZihfZGVmYXVsdC5wcm90b3R5cGUpLCBcImRlc3Ryb3lcIiwgdGhpcykuY2FsbCh0aGlzKTtcblxuICAgICAgdGhpcy5zdG9wU2Nyb2xsaW5nKCk7XG4gICAgICB0aGlzLmh0bWwuY2xhc3NMaXN0LnJlbW92ZSh0aGlzLnNtb290aENsYXNzKTtcbiAgICAgIHRoaXMudnMuZGVzdHJveSgpO1xuICAgICAgdGhpcy5kZXN0cm95U2Nyb2xsQmFyKCk7XG4gICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcigna2V5ZG93bicsIHRoaXMuY2hlY2tLZXksIGZhbHNlKTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gX2RlZmF1bHQ7XG59KF9kZWZhdWx0KTtcblxudmFyIFNtb290aCA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIFNtb290aCgpIHtcbiAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge307XG5cbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgU21vb3RoKTtcblxuICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7IC8vIE92ZXJyaWRlIGRlZmF1bHQgb3B0aW9ucyB3aXRoIGdpdmVuIG9uZXNcblxuICAgIE9iamVjdC5hc3NpZ24odGhpcywgZGVmYXVsdHMsIG9wdGlvbnMpO1xuICAgIHRoaXMuc21hcnRwaG9uZSA9IGRlZmF1bHRzLnNtYXJ0cGhvbmU7XG4gICAgaWYgKG9wdGlvbnMuc21hcnRwaG9uZSkgT2JqZWN0LmFzc2lnbih0aGlzLnNtYXJ0cGhvbmUsIG9wdGlvbnMuc21hcnRwaG9uZSk7XG4gICAgdGhpcy50YWJsZXQgPSBkZWZhdWx0cy50YWJsZXQ7XG4gICAgaWYgKG9wdGlvbnMudGFibGV0KSBPYmplY3QuYXNzaWduKHRoaXMudGFibGV0LCBvcHRpb25zLnRhYmxldCk7XG4gICAgaWYgKCF0aGlzLnNtb290aCAmJiB0aGlzLmRpcmVjdGlvbiA9PSAnaG9yaXpvbnRhbCcpIGNvbnNvbGUud2Fybign8J+aqCBgc21vb3RoOmZhbHNlYCAmIGBob3Jpem9udGFsYCBkaXJlY3Rpb24gYXJlIG5vdCB5ZXQgY29tcGF0aWJsZScpO1xuICAgIGlmICghdGhpcy50YWJsZXQuc21vb3RoICYmIHRoaXMudGFibGV0LmRpcmVjdGlvbiA9PSAnaG9yaXpvbnRhbCcpIGNvbnNvbGUud2Fybign8J+aqCBgc21vb3RoOmZhbHNlYCAmIGBob3Jpem9udGFsYCBkaXJlY3Rpb24gYXJlIG5vdCB5ZXQgY29tcGF0aWJsZSAodGFibGV0KScpO1xuICAgIGlmICghdGhpcy5zbWFydHBob25lLnNtb290aCAmJiB0aGlzLnNtYXJ0cGhvbmUuZGlyZWN0aW9uID09ICdob3Jpem9udGFsJykgY29uc29sZS53YXJuKCfwn5qoIGBzbW9vdGg6ZmFsc2VgICYgYGhvcml6b250YWxgIGRpcmVjdGlvbiBhcmUgbm90IHlldCBjb21wYXRpYmxlIChzbWFydHBob25lKScpO1xuICAgIHRoaXMuaW5pdCgpO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKFNtb290aCwgW3tcbiAgICBrZXk6IFwiaW5pdFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBpbml0KCkge1xuICAgICAgdGhpcy5vcHRpb25zLmlzTW9iaWxlID0gL0FuZHJvaWR8aVBob25lfGlQYWR8aVBvZHxCbGFja0JlcnJ5fElFTW9iaWxlfE9wZXJhIE1pbmkvaS50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpIHx8IG5hdmlnYXRvci5wbGF0Zm9ybSA9PT0gJ01hY0ludGVsJyAmJiBuYXZpZ2F0b3IubWF4VG91Y2hQb2ludHMgPiAxIHx8IHdpbmRvdy5pbm5lcldpZHRoIDwgdGhpcy50YWJsZXQuYnJlYWtwb2ludDtcbiAgICAgIHRoaXMub3B0aW9ucy5pc1RhYmxldCA9IHRoaXMub3B0aW9ucy5pc01vYmlsZSAmJiB3aW5kb3cuaW5uZXJXaWR0aCA+PSB0aGlzLnRhYmxldC5icmVha3BvaW50O1xuXG4gICAgICBpZiAodGhpcy5zbW9vdGggJiYgIXRoaXMub3B0aW9ucy5pc01vYmlsZSB8fCB0aGlzLnRhYmxldC5zbW9vdGggJiYgdGhpcy5vcHRpb25zLmlzVGFibGV0IHx8IHRoaXMuc21hcnRwaG9uZS5zbW9vdGggJiYgdGhpcy5vcHRpb25zLmlzTW9iaWxlICYmICF0aGlzLm9wdGlvbnMuaXNUYWJsZXQpIHtcbiAgICAgICAgdGhpcy5zY3JvbGwgPSBuZXcgX2RlZmF1bHQkMih0aGlzLm9wdGlvbnMpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5zY3JvbGwgPSBuZXcgX2RlZmF1bHQkMSh0aGlzLm9wdGlvbnMpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLnNjcm9sbC5pbml0KCk7XG5cbiAgICAgIGlmICh3aW5kb3cubG9jYXRpb24uaGFzaCkge1xuICAgICAgICAvLyBHZXQgdGhlIGhhc2ggd2l0aG91dCB0aGUgJyMnIGFuZCBmaW5kIHRoZSBtYXRjaGluZyBlbGVtZW50XG4gICAgICAgIHZhciBpZCA9IHdpbmRvdy5sb2NhdGlvbi5oYXNoLnNsaWNlKDEsIHdpbmRvdy5sb2NhdGlvbi5oYXNoLmxlbmd0aCk7XG4gICAgICAgIHZhciB0YXJnZXQgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChpZCk7IC8vIElmIGZvdW5kLCBzY3JvbGwgdG8gdGhlIGVsZW1lbnRcblxuICAgICAgICBpZiAodGFyZ2V0KSB0aGlzLnNjcm9sbC5zY3JvbGxUbyh0YXJnZXQpO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJ1cGRhdGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdXBkYXRlKCkge1xuICAgICAgdGhpcy5zY3JvbGwudXBkYXRlKCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInN0YXJ0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHN0YXJ0KCkge1xuICAgICAgdGhpcy5zY3JvbGwuc3RhcnRTY3JvbGwoKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwic3RvcFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzdG9wKCkge1xuICAgICAgdGhpcy5zY3JvbGwuc3RvcFNjcm9sbCgpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJzY3JvbGxUb1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzY3JvbGxUbyh0YXJnZXQsIG9wdGlvbnMpIHtcbiAgICAgIHRoaXMuc2Nyb2xsLnNjcm9sbFRvKHRhcmdldCwgb3B0aW9ucyk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInNldFNjcm9sbFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRTY3JvbGwoeCwgeSkge1xuICAgICAgdGhpcy5zY3JvbGwuc2V0U2Nyb2xsKHgsIHkpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJvblwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBvbihldmVudCwgZnVuYykge1xuICAgICAgdGhpcy5zY3JvbGwuc2V0RXZlbnRzKGV2ZW50LCBmdW5jKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwib2ZmXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG9mZihldmVudCwgZnVuYykge1xuICAgICAgdGhpcy5zY3JvbGwudW5zZXRFdmVudHMoZXZlbnQsIGZ1bmMpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJkZXN0cm95XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRlc3Ryb3koKSB7XG4gICAgICB0aGlzLnNjcm9sbC5kZXN0cm95KCk7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIFNtb290aDtcbn0oKTtcblxudmFyIE5hdGl2ZSA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIE5hdGl2ZSgpIHtcbiAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge307XG5cbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgTmF0aXZlKTtcblxuICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7IC8vIE92ZXJyaWRlIGRlZmF1bHQgb3B0aW9ucyB3aXRoIGdpdmVuIG9uZXNcblxuICAgIE9iamVjdC5hc3NpZ24odGhpcywgZGVmYXVsdHMsIG9wdGlvbnMpO1xuICAgIHRoaXMuc21hcnRwaG9uZSA9IGRlZmF1bHRzLnNtYXJ0cGhvbmU7XG4gICAgaWYgKG9wdGlvbnMuc21hcnRwaG9uZSkgT2JqZWN0LmFzc2lnbih0aGlzLnNtYXJ0cGhvbmUsIG9wdGlvbnMuc21hcnRwaG9uZSk7XG4gICAgdGhpcy50YWJsZXQgPSBkZWZhdWx0cy50YWJsZXQ7XG4gICAgaWYgKG9wdGlvbnMudGFibGV0KSBPYmplY3QuYXNzaWduKHRoaXMudGFibGV0LCBvcHRpb25zLnRhYmxldCk7XG4gICAgdGhpcy5pbml0KCk7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoTmF0aXZlLCBbe1xuICAgIGtleTogXCJpbml0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGluaXQoKSB7XG4gICAgICB0aGlzLnNjcm9sbCA9IG5ldyBfZGVmYXVsdCQxKHRoaXMub3B0aW9ucyk7XG4gICAgICB0aGlzLnNjcm9sbC5pbml0KCk7XG5cbiAgICAgIGlmICh3aW5kb3cubG9jYXRpb24uaGFzaCkge1xuICAgICAgICAvLyBHZXQgdGhlIGhhc2ggd2l0aG91dCB0aGUgJyMnIGFuZCBmaW5kIHRoZSBtYXRjaGluZyBlbGVtZW50XG4gICAgICAgIHZhciBpZCA9IHdpbmRvdy5sb2NhdGlvbi5oYXNoLnNsaWNlKDEsIHdpbmRvdy5sb2NhdGlvbi5oYXNoLmxlbmd0aCk7XG4gICAgICAgIHZhciB0YXJnZXQgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChpZCk7IC8vIElmIGZvdW5kLCBzY3JvbGwgdG8gdGhlIGVsZW1lbnRcblxuICAgICAgICBpZiAodGFyZ2V0KSB0aGlzLnNjcm9sbC5zY3JvbGxUbyh0YXJnZXQpO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJ1cGRhdGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdXBkYXRlKCkge1xuICAgICAgdGhpcy5zY3JvbGwudXBkYXRlKCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInN0YXJ0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHN0YXJ0KCkge1xuICAgICAgdGhpcy5zY3JvbGwuc3RhcnRTY3JvbGwoKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwic3RvcFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzdG9wKCkge1xuICAgICAgdGhpcy5zY3JvbGwuc3RvcFNjcm9sbCgpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJzY3JvbGxUb1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzY3JvbGxUbyh0YXJnZXQsIG9wdGlvbnMpIHtcbiAgICAgIHRoaXMuc2Nyb2xsLnNjcm9sbFRvKHRhcmdldCwgb3B0aW9ucyk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInNldFNjcm9sbFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRTY3JvbGwoeCwgeSkge1xuICAgICAgdGhpcy5zY3JvbGwuc2V0U2Nyb2xsKHgsIHkpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJvblwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBvbihldmVudCwgZnVuYykge1xuICAgICAgdGhpcy5zY3JvbGwuc2V0RXZlbnRzKGV2ZW50LCBmdW5jKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwib2ZmXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG9mZihldmVudCwgZnVuYykge1xuICAgICAgdGhpcy5zY3JvbGwudW5zZXRFdmVudHMoZXZlbnQsIGZ1bmMpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJkZXN0cm95XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRlc3Ryb3koKSB7XG4gICAgICB0aGlzLnNjcm9sbC5kZXN0cm95KCk7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIE5hdGl2ZTtcbn0oKTtcblxuZXhwb3J0IGRlZmF1bHQgU21vb3RoO1xuZXhwb3J0IHsgTmF0aXZlLCBTbW9vdGggfTtcbiJdLCJuYW1lcyI6WyJfY2xhc3NDYWxsQ2hlY2siLCJpbnN0YW5jZSIsIkNvbnN0cnVjdG9yIiwiVHlwZUVycm9yIiwiX2RlZmluZVByb3BlcnRpZXMiLCJ0YXJnZXQiLCJwcm9wcyIsImkiLCJsZW5ndGgiLCJkZXNjcmlwdG9yIiwiZW51bWVyYWJsZSIsImNvbmZpZ3VyYWJsZSIsIndyaXRhYmxlIiwiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJrZXkiLCJfY3JlYXRlQ2xhc3MiLCJwcm90b1Byb3BzIiwic3RhdGljUHJvcHMiLCJwcm90b3R5cGUiLCJfZGVmaW5lUHJvcGVydHkiLCJvYmoiLCJ2YWx1ZSIsIm93bktleXMiLCJvYmplY3QiLCJlbnVtZXJhYmxlT25seSIsImtleXMiLCJnZXRPd25Qcm9wZXJ0eVN5bWJvbHMiLCJzeW1ib2xzIiwiZmlsdGVyIiwic3ltIiwiZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yIiwicHVzaCIsImFwcGx5IiwiX29iamVjdFNwcmVhZDIiLCJhcmd1bWVudHMiLCJzb3VyY2UiLCJmb3JFYWNoIiwiZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyIsImRlZmluZVByb3BlcnRpZXMiLCJfaW5oZXJpdHMiLCJzdWJDbGFzcyIsInN1cGVyQ2xhc3MiLCJjcmVhdGUiLCJjb25zdHJ1Y3RvciIsIl9zZXRQcm90b3R5cGVPZiIsIl9nZXRQcm90b3R5cGVPZiIsIm8iLCJzZXRQcm90b3R5cGVPZiIsImdldFByb3RvdHlwZU9mIiwiX19wcm90b19fIiwicCIsIl9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QiLCJSZWZsZWN0IiwiY29uc3RydWN0Iiwic2hhbSIsIlByb3h5IiwiRGF0ZSIsInRvU3RyaW5nIiwiY2FsbCIsImUiLCJfYXNzZXJ0VGhpc0luaXRpYWxpemVkIiwic2VsZiIsIlJlZmVyZW5jZUVycm9yIiwiX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4iLCJfY3JlYXRlU3VwZXIiLCJEZXJpdmVkIiwiaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCIsIl9jcmVhdGVTdXBlckludGVybmFsIiwiU3VwZXIiLCJyZXN1bHQiLCJOZXdUYXJnZXQiLCJfc3VwZXJQcm9wQmFzZSIsInByb3BlcnR5IiwiaGFzT3duUHJvcGVydHkiLCJfZ2V0IiwicmVjZWl2ZXIiLCJnZXQiLCJiYXNlIiwiZGVzYyIsIl9zbGljZWRUb0FycmF5IiwiYXJyIiwiX2FycmF5V2l0aEhvbGVzIiwiX2l0ZXJhYmxlVG9BcnJheUxpbWl0IiwiX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5IiwiX25vbkl0ZXJhYmxlUmVzdCIsIl90b0NvbnN1bWFibGVBcnJheSIsIl9hcnJheVdpdGhvdXRIb2xlcyIsIl9pdGVyYWJsZVRvQXJyYXkiLCJfbm9uSXRlcmFibGVTcHJlYWQiLCJBcnJheSIsImlzQXJyYXkiLCJfYXJyYXlMaWtlVG9BcnJheSIsIml0ZXIiLCJTeW1ib2wiLCJpdGVyYXRvciIsImZyb20iLCJfYXJyIiwiX24iLCJfZCIsIl9lIiwidW5kZWZpbmVkIiwiX2kiLCJfcyIsIm5leHQiLCJkb25lIiwiZXJyIiwibWluTGVuIiwibiIsInNsaWNlIiwibmFtZSIsInRlc3QiLCJsZW4iLCJhcnIyIiwiZGVmYXVsdHMiLCJlbCIsImRvY3VtZW50Iiwib2Zmc2V0IiwicmVwZWF0Iiwic21vb3RoIiwiaW5pdFBvc2l0aW9uIiwieCIsInkiLCJkaXJlY3Rpb24iLCJnZXN0dXJlRGlyZWN0aW9uIiwicmVsb2FkT25Db250ZXh0Q2hhbmdlIiwibGVycCIsInNjcm9sbGJhckNvbnRhaW5lciIsInNjcm9sbGJhckNsYXNzIiwic2Nyb2xsaW5nQ2xhc3MiLCJkcmFnZ2luZ0NsYXNzIiwic21vb3RoQ2xhc3MiLCJpbml0Q2xhc3MiLCJnZXRTcGVlZCIsImdldERpcmVjdGlvbiIsInNjcm9sbEZyb21Bbnl3aGVyZSIsIm11bHRpcGxpZXIiLCJmaXJlZm94TXVsdGlwbGllciIsInRvdWNoTXVsdGlwbGllciIsInJlc2V0TmF0aXZlU2Nyb2xsIiwidGFibGV0IiwiYnJlYWtwb2ludCIsInNtYXJ0cGhvbmUiLCJfZGVmYXVsdCIsIm9wdGlvbnMiLCJhc3NpZ24iLCJuYW1lc3BhY2UiLCJodG1sIiwiZG9jdW1lbnRFbGVtZW50Iiwid2luZG93SGVpZ2h0Iiwid2luZG93IiwiaW5uZXJIZWlnaHQiLCJ3aW5kb3dXaWR0aCIsImlubmVyV2lkdGgiLCJ3aW5kb3dNaWRkbGUiLCJlbHMiLCJjdXJyZW50RWxlbWVudHMiLCJsaXN0ZW5lcnMiLCJoYXNTY3JvbGxUaWNraW5nIiwiaGFzQ2FsbEV2ZW50U2V0IiwiY2hlY2tTY3JvbGwiLCJiaW5kIiwiY2hlY2tSZXNpemUiLCJjaGVja0V2ZW50Iiwic2Nyb2xsIiwibGltaXQiLCJvZmZzZXRXaWR0aCIsIm9mZnNldEhlaWdodCIsImlzTW9iaWxlIiwiaXNUYWJsZXQiLCJjb250ZXh0IiwiZGlyZWN0aW9uQXhpcyIsInNwZWVkIiwiY2xhc3NMaXN0IiwiYWRkIiwiYWRkRXZlbnRMaXN0ZW5lciIsImluaXQiLCJpbml0RXZlbnRzIiwiZGlzcGF0Y2hTY3JvbGwiLCJfdGhpcyIsInJlc2l6ZVRpY2siLCJyZXF1ZXN0QW5pbWF0aW9uRnJhbWUiLCJyZXNpemUiLCJjaGVja0NvbnRleHQiLCJuYXZpZ2F0b3IiLCJ1c2VyQWdlbnQiLCJwbGF0Zm9ybSIsIm1heFRvdWNoUG9pbnRzIiwib2xkQ29udGV4dCIsIm9sZFNtb290aCIsIm5ld1Ntb290aCIsImxvY2F0aW9uIiwicmVsb2FkIiwiX3RoaXMyIiwic2Nyb2xsVG9FbHMiLCJxdWVyeVNlbGVjdG9yQWxsIiwiY29uY2F0Iiwic2V0U2Nyb2xsVG8iLCJldmVudCIsInByZXZlbnREZWZhdWx0Iiwic2Nyb2xsVG8iLCJjdXJyZW50VGFyZ2V0IiwiZ2V0QXR0cmlidXRlIiwiYWRkRWxlbWVudHMiLCJkZXRlY3RFbGVtZW50cyIsIl90aGlzMyIsInNjcm9sbFRvcCIsInNjcm9sbEJvdHRvbSIsInNjcm9sbExlZnQiLCJzY3JvbGxSaWdodCIsImVudHJpZXMiLCJfcmVmIiwiX3JlZjIiLCJpblZpZXciLCJsZWZ0IiwicmlnaHQiLCJzZXRJblZpZXciLCJ0b3AiLCJib3R0b20iLCJ3aWR0aCIsInByb2dyZXNzIiwic2V0T3V0T2ZWaWV3IiwiaGVpZ2h0IiwiY3VycmVudCIsImRpc3BhdGNoQ2FsbCIsIl90aGlzNCIsInJlbW92ZSIsIndheSIsImNhbGxXYXkiLCJjYWxsVmFsdWUiLCJzcGxpdCIsIm1hcCIsIml0ZW0iLCJ0cmltIiwiY2FsbE9iaiIsImNhbGxFdmVudCIsIkV2ZW50IiwiZGlzcGF0Y2hFdmVudCIsInNjcm9sbEV2ZW50Iiwic2V0RXZlbnRzIiwiZnVuYyIsImxpc3QiLCJ1bnNldEV2ZW50cyIsImluZGV4IiwiaW5kZXhPZiIsInNwbGljZSIsInJlbW92ZUV2ZW50TGlzdGVuZXIiLCJfdGhpczUiLCJ0eXBlIiwicmVwbGFjZSIsInN0YXJ0U2Nyb2xsIiwic3RvcFNjcm9sbCIsInNldFNjcm9sbCIsImRlc3Ryb3kiLCJfdGhpczYiLCJjb21tb25qc0dsb2JhbCIsImdsb2JhbFRoaXMiLCJnbG9iYWwiLCJjcmVhdGVDb21tb25qc01vZHVsZSIsImZuIiwibW9kdWxlIiwiZXhwb3J0cyIsInNtb290aHNjcm9sbCIsInBvbHlmaWxsIiwidyIsImQiLCJzdHlsZSIsIl9fZm9yY2VTbW9vdGhTY3JvbGxQb2x5ZmlsbF9fIiwiRWxlbWVudCIsIkhUTUxFbGVtZW50IiwiU0NST0xMX1RJTUUiLCJvcmlnaW5hbCIsInNjcm9sbEJ5IiwiZWxlbWVudFNjcm9sbCIsInNjcm9sbEVsZW1lbnQiLCJzY3JvbGxJbnRvVmlldyIsIm5vdyIsInBlcmZvcm1hbmNlIiwiaXNNaWNyb3NvZnRCcm93c2VyIiwidXNlckFnZW50UGF0dGVybnMiLCJSZWdFeHAiLCJqb2luIiwiUk9VTkRJTkdfVE9MRVJBTkNFIiwiZWFzZSIsImsiLCJNYXRoIiwiY29zIiwiUEkiLCJzaG91bGRCYWlsT3V0IiwiZmlyc3RBcmciLCJiZWhhdmlvciIsImhhc1Njcm9sbGFibGVTcGFjZSIsImF4aXMiLCJjbGllbnRIZWlnaHQiLCJzY3JvbGxIZWlnaHQiLCJjbGllbnRXaWR0aCIsInNjcm9sbFdpZHRoIiwiY2FuT3ZlcmZsb3ciLCJvdmVyZmxvd1ZhbHVlIiwiZ2V0Q29tcHV0ZWRTdHlsZSIsImlzU2Nyb2xsYWJsZSIsImlzU2Nyb2xsYWJsZVkiLCJpc1Njcm9sbGFibGVYIiwiZmluZFNjcm9sbGFibGVQYXJlbnQiLCJib2R5IiwicGFyZW50Tm9kZSIsImhvc3QiLCJzdGVwIiwidGltZSIsImN1cnJlbnRYIiwiY3VycmVudFkiLCJlbGFwc2VkIiwic3RhcnRUaW1lIiwic3RhcnRYIiwic3RhcnRZIiwibWV0aG9kIiwic2Nyb2xsYWJsZSIsInNtb290aFNjcm9sbCIsInNjcm9sbFgiLCJwYWdlWE9mZnNldCIsInNjcm9sbFkiLCJwYWdlWU9mZnNldCIsIlN5bnRheEVycm9yIiwic2Nyb2xsYWJsZVBhcmVudCIsInBhcmVudFJlY3RzIiwiZ2V0Qm91bmRpbmdDbGllbnRSZWN0IiwiY2xpZW50UmVjdHMiLCJwb3NpdGlvbiIsInNtb290aHNjcm9sbF8xIiwiX2RlZmF1bHQkMSIsIl9Db3JlIiwiX3N1cGVyIiwiaGlzdG9yeSIsInNjcm9sbFJlc3RvcmF0aW9uIiwic21vb3Roc2Nyb2xsUG9seWZpbGwiLCJhZGREaXJlY3Rpb24iLCJhZGRTcGVlZCIsInNwZWVkVHMiLCJtYXgiLCJ1cGRhdGVFbGVtZW50cyIsIkJDUiIsImNsIiwiZGF0YXNldCIsImlkIiwidGFyZ2V0RWwiLCJxdWVyeVNlbGVjdG9yIiwidGFyZ2V0RWxCQ1IiLCJyZWxhdGl2ZU9mZnNldCIsImdldFJlbGF0aXZlT2Zmc2V0IiwibWFwcGVkRWwiLCJjb250YWlucyIsImluY2x1ZGVzIiwicGFyc2VJbnQiLCJjYWxsYmFjayIsInRhZ05hbWUiLCJjb25zb2xlIiwid2FybiIsImlzVGFyZ2V0UmVhY2hlZCIsIm9uU2Nyb2xsIiwiZHVyYXRpb24iLCJ1cGRhdGUiLCJwcm9wSXNFbnVtZXJhYmxlIiwicHJvcGVydHlJc0VudW1lcmFibGUiLCJ0b09iamVjdCIsInZhbCIsInNob3VsZFVzZU5hdGl2ZSIsInRlc3QxIiwiU3RyaW5nIiwiZ2V0T3duUHJvcGVydHlOYW1lcyIsInRlc3QyIiwiZnJvbUNoYXJDb2RlIiwib3JkZXIyIiwidGVzdDMiLCJsZXR0ZXIiLCJvYmplY3RBc3NpZ24iLCJ0byIsInMiLCJFIiwib24iLCJjdHgiLCJvbmNlIiwibGlzdGVuZXIiLCJvZmYiLCJfIiwiZW1pdCIsImRhdGEiLCJldnRBcnIiLCJldnRzIiwibGl2ZUV2ZW50cyIsInRpbnlFbWl0dGVyIiwibGV0aGFyZ3kiLCJyb290IiwiTGV0aGFyZ3kiLCJzdGFiaWxpdHkiLCJzZW5zaXRpdml0eSIsInRvbGVyYW5jZSIsImRlbGF5IiwiYWJzIiwibGFzdFVwRGVsdGFzIiwicmVmIiwicmVzdWx0cyIsImxhc3REb3duRGVsdGFzIiwiZGVsdGFzVGltZXN0YW1wIiwiY2hlY2siLCJsYXN0RGVsdGEiLCJvcmlnaW5hbEV2ZW50Iiwid2hlZWxEZWx0YSIsImRlbHRhWSIsImRldGFpbCIsInNoaWZ0IiwiaXNJbmVydGlhIiwibGFzdERlbHRhcyIsImxhc3REZWx0YXNOZXciLCJsYXN0RGVsdGFzT2xkIiwibmV3QXZlcmFnZSIsIm5ld1N1bSIsIm9sZEF2ZXJhZ2UiLCJvbGRTdW0iLCJyZWR1Y2UiLCJ0Iiwic2hvd0xhc3RVcERlbHRhcyIsInNob3dMYXN0RG93bkRlbHRhcyIsInN1cHBvcnQiLCJnZXRTdXBwb3J0IiwiaGFzV2hlZWxFdmVudCIsImhhc01vdXNlV2hlZWxFdmVudCIsImhhc1RvdWNoIiwiVG91Y2hFdmVudCIsIkRvY3VtZW50VG91Y2giLCJoYXNUb3VjaFdpbiIsIm1zTWF4VG91Y2hQb2ludHMiLCJoYXNQb2ludGVyIiwibXNQb2ludGVyRW5hYmxlZCIsImhhc0tleURvd24iLCJpc0ZpcmVmb3giLCJoYXNPd25Qcm9wZXJ0eSQxIiwiYmluZGFsbFN0YW5kYWxvbmUiLCJmdW5jdGlvbnMiLCJmIiwiRVZUX0lEIiwic3JjIiwiVmlydHVhbFNjcm9sbCIsImtleUNvZGVzIiwiTEVGVCIsIlVQIiwiUklHSFQiLCJET1dOIiwiU1BBQ0UiLCJtb3VzZU11bHRpcGxpZXIiLCJrZXlTdGVwIiwicHJldmVudFRvdWNoIiwidW5wcmV2ZW50VG91Y2hDbGFzcyIsImxpbWl0SW5lcnRpYSIsInVzZUtleWJvYXJkIiwidXNlVG91Y2giLCJfbGV0aGFyZ3kiLCJfZW1pdHRlciIsIl9ldmVudCIsImRlbHRhWCIsInRvdWNoU3RhcnRYIiwidG91Y2hTdGFydFkiLCJib2R5VG91Y2hBY3Rpb24iLCJwYXNzaXZlIiwibGlzdGVuZXJPcHRpb25zIiwiX25vdGlmeSIsImV2dCIsIl9vbldoZWVsIiwid2hlZWxEZWx0YVgiLCJ3aGVlbERlbHRhWSIsImRlbHRhTW9kZSIsIl9vbk1vdXNlV2hlZWwiLCJfb25Ub3VjaFN0YXJ0IiwidGFyZ2V0VG91Y2hlcyIsInBhZ2VYIiwicGFnZVkiLCJfb25Ub3VjaE1vdmUiLCJfb25LZXlEb3duIiwia2V5Q29kZSIsInNoaWZ0S2V5IiwiX2JpbmQiLCJtc1RvdWNoQWN0aW9uIiwiX3VuYmluZCIsImNiIiwiZXZlbnRzIiwicmVzZXQiLCJzdGFydCIsImVuZCIsImFtdCIsImdldFRyYW5zbGF0ZSIsInRyYW5zbGF0ZSIsInRyYW5zZm9ybSIsIndlYmtpdFRyYW5zZm9ybSIsIm1velRyYW5zZm9ybSIsIm1hdCIsIm1hdGNoIiwicGFyc2VGbG9hdCIsImdldFBhcmVudHMiLCJlbGVtIiwicGFyZW50cyIsIk5FV1RPTl9JVEVSQVRJT05TIiwiTkVXVE9OX01JTl9TTE9QRSIsIlNVQkRJVklTSU9OX1BSRUNJU0lPTiIsIlNVQkRJVklTSU9OX01BWF9JVEVSQVRJT05TIiwia1NwbGluZVRhYmxlU2l6ZSIsImtTYW1wbGVTdGVwU2l6ZSIsImZsb2F0MzJBcnJheVN1cHBvcnRlZCIsIkZsb2F0MzJBcnJheSIsIkEiLCJhQTEiLCJhQTIiLCJCIiwiQyIsImNhbGNCZXppZXIiLCJhVCIsImdldFNsb3BlIiwiYmluYXJ5U3ViZGl2aWRlIiwiYVgiLCJhQSIsImFCIiwibVgxIiwibVgyIiwiY3VycmVudFQiLCJuZXd0b25SYXBoc29uSXRlcmF0ZSIsImFHdWVzc1QiLCJjdXJyZW50U2xvcGUiLCJMaW5lYXJFYXNpbmciLCJzcmMkMSIsImJlemllciIsIm1ZMSIsIm1ZMiIsIkVycm9yIiwic2FtcGxlVmFsdWVzIiwiZ2V0VEZvclgiLCJpbnRlcnZhbFN0YXJ0IiwiY3VycmVudFNhbXBsZSIsImxhc3RTYW1wbGUiLCJkaXN0IiwiZ3Vlc3NGb3JUIiwiaW5pdGlhbFNsb3BlIiwiQmV6aWVyRWFzaW5nIiwia2V5Q29kZXMkMSIsIlRBQiIsIlBBR0VVUCIsIlBBR0VET1dOIiwiSE9NRSIsIkVORCIsIl9kZWZhdWx0JDIiLCJpbmVydGlhIiwiaXNTY3JvbGxpbmciLCJpc0RyYWdnaW5nU2Nyb2xsYmFyIiwiaXNUaWNraW5nIiwicGFyYWxsYXhFbGVtZW50cyIsInN0b3AiLCJjaGVja0tleSIsInNldEF0dHJpYnV0ZSIsImRlbHRhIiwidnMiLCJ1cGRhdGVEZWx0YSIsInN0YXJ0U2Nyb2xsaW5nIiwic2V0U2Nyb2xsTGltaXQiLCJpbml0U2Nyb2xsQmFyIiwiYWRkU2VjdGlvbnMiLCJ0cmFuc2Zvcm1FbGVtZW50cyIsInRvdGFsV2lkdGgiLCJub2RlcyIsImNoaWxkcmVuIiwic3RhcnRTY3JvbGxUcyIsInN0b3BTY3JvbGxpbmciLCJjYW5jZWxBbmltYXRpb25GcmFtZSIsImNoZWNrU2Nyb2xsUmFmIiwic2Nyb2xsVG9SYWYiLCJyb3VuZCIsImFjdGl2ZUVsZW1lbnQiLCJpc0FjdGl2ZUVsZW1lbnRTY3JvbGxTZW5zaXRpdmUiLCJIVE1MSW5wdXRFbGVtZW50IiwiSFRNTFRleHRBcmVhRWxlbWVudCIsIkhUTUxCdXR0b25FbGVtZW50IiwiSFRNTFNlbGVjdEVsZW1lbnQiLCJmb3JjZWQiLCJ1cGRhdGVTY3JvbGwiLCJkaXN0YW5jZSIsInRpbWVTaW5jZVN0YXJ0IiwiYW5pbWF0aW5nU2Nyb2xsIiwic2VjdGlvbnMiLCJzZWN0aW9uIiwicGVyc2lzdGVudCIsIm9wYWNpdHkiLCJwb2ludGVyRXZlbnRzIiwicmVtb3ZlQXR0cmlidXRlIiwiaGFzU2Nyb2xsYmFyIiwic2Nyb2xsQmFyVHJhbnNsYXRpb24iLCJzY3JvbGxCYXJMaW1pdCIsInNjcm9sbGJhclRodW1iIiwic2Nyb2xsYmFyIiwiY3JlYXRlRWxlbWVudCIsImFwcGVuZCIsImdldFNjcm9sbEJhciIsInJlbGVhc2VTY3JvbGxCYXIiLCJtb3ZlU2Nyb2xsQmFyIiwic2Nyb2xsYmFyQkNSIiwic2Nyb2xsYmFySGVpZ2h0Iiwic2Nyb2xsYmFyV2lkdGgiLCJzY3JvbGxiYXJUaHVtYkJDUiIsInJlaW5pdFNjcm9sbEJhciIsImRlc3Ryb3lTY3JvbGxCYXIiLCJjbGllbnRYIiwiY2xpZW50WSIsInRhcmdldFBhcmVudHMiLCJfcmVmMyIsIl9yZWY0IiwiZmluZCIsInN0aWNreSIsIm1pZGRsZSIsImVsQkNSIiwiZWxUb3AiLCJlbExlZnQiLCJlbERpc3RhbmNlIiwiX3RoaXM3Iiwic2VjdGlvbkJDUiIsIm1hcHBlZFNlY3Rpb24iLCJlbGVtZW50IiwibGVycFgiLCJsZXJwWSIsIm1zVHJhbnNmb3JtIiwiaXNGb3JjZWQiLCJfdGhpczgiLCJzZXRBbGxFbGVtZW50cyIsInNjcm9sbE1pZGRsZSIsIl9yZWY1IiwiX3JlZjYiLCJ0cmFuc2Zvcm1EaXN0YW5jZSIsIl90aGlzOSIsImlzTmFOIiwiZWFzaW5nIiwiZGlzYWJsZUxlcnAiLCJ0YXJnZXRJblNjb3BlIiwidGFyZ2V0QkNSIiwib2Zmc2V0VG9wIiwib2Zmc2V0TGVmdCIsInBhcmVudFNlY3Rpb24iLCJjYW5kaWRhdGUiLCJfcmVmNyIsIl9yZWY4IiwicGFyZW50U2VjdGlvbk9mZnNldCIsInNjcm9sbFN0YXJ0Iiwic2Nyb2xsVGFyZ2V0IiwibWluIiwic2Nyb2xsRGlmZiIsInJlbmRlciIsImxvb3AiLCJTbW9vdGgiLCJoYXNoIiwiZ2V0RWxlbWVudEJ5SWQiLCJOYXRpdmUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/locomotive-scroll/dist/locomotive-scroll.esm.js\n"));

/***/ })

}]);